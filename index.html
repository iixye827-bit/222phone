<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0"> -->
<!-- <meta http-equiv="Pragma" content="no-cache"> -->
<!-- <meta http-equiv="Expires" content="0"> -->

    <!-- PWA & Mobile App Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#16213e">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">

    <title>Jellyfish Island</title>
    <style>
        /* [CSS - V12.5.0 "Cascade Select"] */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Arial', -apple-system, BlinkMacSystemFont, sans-serif; }
        :root {
            --day-color1: #f5f7fa; --day-color2: #e4eaf5;
            --night-color1: #1f2a40; --night-color2: #16213e;
            --hold-border: #5B99E2; --text-day: #2d3748; --text-night: #e0e6f0;
            --handle-color-day: #5a6778; --handle-color-night: #ffffff;
            --bg-day-element: linear-gradient(135deg, var(--day-color2), var(--day-color1));
            --bg-night-element: linear-gradient(135deg, var(--night-color2), var(--night-color1));
            --shadow-light-day: rgba(255, 255, 255, 0.9); --shadow-dark-day: rgba(174, 190, 212, 0.4);
            --shadow-light-night: rgba(40, 52, 79, 0.9); --shadow-dark-night: rgba(0, 0, 0, 0.3);
        }
        body { 
            height: 100vh; /* 使用vh确保占满屏幕高度 */
            background-color: var(--day-color1);
            background-image: linear-gradient(135deg, var(--day-color1) 0%, var(--day-color2) 100%); 
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            padding: 0; /* [核心修改] 移除所有padding，让子元素可以触及屏幕边缘 */
            display: flex; flex-direction: column; align-items: center; 
            transition: background 0.5s ease; 
            touch-action: manipulation; 
            overflow: hidden; /* 禁止body本身滚动 */
        }
        body.dark-mode { 
            background-color: var(--night-color1);
            background-image: linear-gradient(135deg, var(--night-color1) 0%, var(--night-color2) 100%); 
            --hold-border: #63b3ed; color: var(--text-night); 
            --shadow-dark-night: rgba(0, 0, 0, 0.3);
        }
        body.dark-mode .nav-btn {
            box-shadow: 12px 12px 24px var(--shadow-dark-night), -12px -12px 24px var(--shadow-light-night);
        }
        body.dark-mode.theme-glass .nav-btn {
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
        }
        .title-card { 
            width: 100%; max-width: 800px; padding: 40px 20px; margin: 20px; /* [核心修改] 将左右margin设为20px来替代body的padding */
            box-sizing: border-box; /* [新增] 确保padding和border包含在width内 */
            border-radius: 16px; 
            box-shadow: 12px 12px 24px var(--shadow-dark-day), -12px -12px 24px var(--shadow-light-day); 
            background: var(--bg-day-element); backdrop-filter: blur(8px); text-align: center; 
            transition: all 0.5s ease; background-size: cover; background-position: center;
            flex-shrink: 0; /* 防止此元素在Flex布局中被压缩 */
        }

        body.dark-mode .title-card { box-shadow: 12px 12px 24px var(--shadow-dark-night), -12px -12px 24px var(--shadow-light-night); background: var(--bg-night-element); }
        .editable-title, .editable-subtitle { opacity: 0; transition: opacity 0.5s ease; background-color: rgba(255,255,255,0.1); backdrop-filter: blur(4px); } /* FOUC Fix */
        .editable-title { font-size: 36px; font-weight: 700; color: var(--text-day); margin-bottom: 20px; cursor: pointer; padding: 6px 12px; border-radius: 8px; display: block; width: fit-content; margin: 0 auto 20px auto; user-select: none; }
        body.dark-mode .editable-title { color: var(--text-night); background-color: rgba(0,0,0,0.1); }
        .editable-title:hover { background-color: rgba(255, 255, 255, 0.8); } body.dark-mode .editable-title:hover { background-color: rgba(50, 55, 75, 0.8); }
        .editable-subtitle { font-size: 16px; color: #5a6778; cursor: pointer; padding: 4px 8px; border-radius: 6px; display: block; width: fit-content; margin: 0 auto; line-height: 1.5; user-select: none; }
        body.dark-mode .editable-subtitle { color: #c0c6cc; background-color: rgba(0,0,0,0.1); }
        .editable-subtitle:hover { background-color: rgba(255, 255, 255, 0.8); color: var(--text-day); } body.dark-mode .editable-subtitle:hover { background-color: rgba(50, 55, 75, 0.8); color: var(--text-night); }
        
        .category-nav-container { 
            width: 100%; max-width: 1200px; overflow-x: auto; -webkit-overflow-scrolling: touch; 
            scrollbar-width: none; padding: 10px 20px; /* [核心修改] 增加左右padding */
            margin-bottom: 10px;
            box-sizing: border-box; /* [新增] 确保padding和border包含在width内 */
            flex-shrink: 0; /* 防止此元素在Flex布局中被压缩 */
        }

        .category-nav-container::-webkit-scrollbar { display: none; }
        .category-nav { display: flex; flex-wrap: nowrap; gap: 12px; padding: 0 20px; }
        .category-pill { flex-shrink: 0; padding: 8px 18px; border: none; border-radius: 20px; background: var(--bg-day-element); box-shadow: none; color: var(--text-day); font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; opacity: 0.6; }
        body.dark-mode .category-pill { background: var(--bg-night-element); color: var(--text-night); }
        body:not(.theme-glass) .category-pill.active { background: var(--bg-day-element); color: var(--text-day); font-weight: 700; box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); opacity: 1; }
        body.dark-mode:not(.theme-glass) .category-pill.active { background: #000000; color: var(--text-night); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        body.theme-glass .category-pill.active { background: rgba(255, 255, 255, 0.4); border-color: rgba(255, 255, 255, 0.6); opacity: 1; transform: scale(1.05); color: #000; }
        body.dark-mode.theme-glass .category-pill.active { color: #fff; background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.3); }

        /* ===== [新增] 包裹和滚动容器的样式 (V2 - 无感边界) ===== */
        .scrollable-nav-wrapper {
            width: 100%;
            flex-grow: 1; /* 让此容器占据所有剩余的垂直空间 */
            overflow-y: auto; /* 当内容超出时，只在此容器内显示垂直滚动条 */
            min-height: 0; /* Flex布局中的重要技巧，防止内容撑开容器 */
            padding-bottom: 30px; /* 保留底部空间，避免按钮紧贴屏幕边缘 */
            /* [核心修改] 使用遮罩创建无感的渐变分界线 */
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15px);
            mask-image: linear-gradient(to bottom, transparent 0%, black 15px);
        }
        /* 美化滚动条 (可选，但推荐) */
        .scrollable-nav-wrapper::-webkit-scrollbar {
            width: 5px;
        }
        .scrollable-nav-wrapper::-webkit-scrollbar-thumb {
            background: rgba(128, 128, 128, 0.3);
            border-radius: 3px;
        }
        /* ===== [新增结束] ===== */


        .nav-container { 
            width: 100%; max-width: 1200px; margin: 0 auto; /* [修改] 移除垂直margin，改为水平居中 */
            display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
            gap: 25px; padding: 10px 20px; /* [修改] 调整内边距 */
            position: relative; z-index: 10; touch-action: pan-y; 
        }

        .nav-btn { position: relative; padding: 22px 16px; border: none; border-radius: 14px; box-shadow: 10px 10px 20px var(--shadow-dark-day), -10px -10px 20px var(--shadow-light-day); background: var(--bg-day-element); backdrop-filter: blur(8px); font-size: 17px; font-weight: 600; color: var(--text-day); cursor: pointer; transition: all 0.3s ease; text-align: center; user-select: none; -webkit-tap-highlight-color: transparent; }
        .nav-btn.hold { border: 2px solid var(--hold-border); transform: scale(1.02); z-index: 5; box-shadow: 8px 8px 16px rgba(174, 190, 212, 0.5), -8px -8px 16px rgba(255, 255, 255, 0.8), 0 0 0 2px rgba(91, 153, 226, 0.3); }
        body.dark-mode .nav-btn { box-shadow: 10px 10px 20px var(--shadow-dark-night), -10px -10px 20px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        body.dark-mode .nav-btn:active { box-shadow: inset 6px 6px 12px rgba(0, 0, 0, 0.25), inset -6px -6px 12px var(--shadow-dark-night); }
        body.dark-mode .nav-btn.hold { box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.4), -8px -8px 16px rgba(40, 52, 79, 0.8), 0 0 0 2px rgba(99, 179, 237, 0.3); }
        .nav-btn:hover { transform: translateY(-3px); filter: brightness(1.05); }
        .nav-btn:active { box-shadow: inset 6px 6px 12px var(--shadow-dark-day), inset -6px -6px 12px var(--shadow-light-day); transform: translateY(0); }
        body.dark-mode .nav-btn:active { box-shadow: inset 6px 6px 12px rgba(0, 0, 0, 0.25), inset -6px -6px 12px rgba(40, 52, 79, 0.8); }
        .delete-icon { display: none; position: absolute; top: -5px; right: -5px; width: 24px; height: 24px; background-color: #f56565; color: white; border-radius: 50%; border: 2px solid white; font-size: 16px; font-weight: bold; line-height: 20px; text-align: center; cursor: pointer; z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .page-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(2px); z-index: 99; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .page-overlay.show { opacity: 1; pointer-events: auto; }
        .page-overlay.management-overlay { background: transparent; backdrop-filter: none; z-index: 5; }
        .management-active .nav-btn { animation: wiggle 0.2s ease-in-out infinite alternate; pointer-events: auto !important; -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; }
        .management-active .nav-btn > .delete-icon { display: block; }
        @keyframes wiggle { from { transform: rotate(-0.5deg); } to { transform: rotate(0.5deg); } }
        .fab-container { position: fixed; right: 30px; bottom: 30px; z-index: 100; }
        .fab-main, .fab-drawer-item { position: relative; width: 50px; height: 50px; border-radius: 50%; border: none; cursor: pointer; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day); background: var(--bg-day-element); color: var(--text-day); font-size: 22px; display: flex; align-items: center; justify-content: center; user-select: none; -webkit-tap-highlight-color: transparent; }
        body.dark-mode .fab-main, body.dark-mode .fab-drawer-item { box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        .fab-main:active, .fab-drawer-item:active { transform: scale(0.95); }
        .fab-container.active .fab-main { transform: rotate(45deg); }
        .fab-drawer { position: absolute; bottom: 65px; left: 0; display: flex; flex-direction: column; gap: 15px; opacity: 0; transform: translateY(20px); transition: opacity 0.2s ease-out, transform 0.2s ease-out; pointer-events: none; }
        .fab-container.active .fab-drawer { opacity: 1; transform: translateY(0); pointer-events: auto; }
        #sync-status-indicator { position: absolute; right: 5px; top: 5px; width: 10px; height: 10px; border-radius: 50%; background-color: transparent; transition: all 0.3s ease; box-shadow: 0 0 5px rgba(0,0,0,0.2); }
        #sync-status-indicator.synced { background-color: #28a745; } #sync-status-indicator.syncing { background-color: #ffc107; animation: pulse 1.5s infinite; } #sync-status-indicator.error { background-color: #dc3545; animation: none; }
        @keyframes pulse { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.3); opacity: 0.7; } 100% { transform: scale(1); opacity: 1; } }
        .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);backdrop-filter:blur(5px);display:none;align-items:center;justify-content:center;z-index:1000;opacity:0;transition:opacity .3s ease}.modal-overlay.show{display:flex;opacity:1}.modal-content{width:90%;background:var(--bg-day-element);color:var(--text-day);border-radius:16px;box-shadow:12px 12px 24px var(--shadow-dark-day),-12px -12px 24px var(--shadow-light-day);padding:12px;transition:transform .3s ease,background .5s ease,box-shadow .5s ease;transform:scale(.95);display:flex;flex-direction:column;max-height:90vh}.modal-overlay.show .modal-content{transform:scale(1)}body.dark-mode .modal-content{background:var(--bg-night-element);color:var(--text-night);box-shadow:12px 12px 24px var(--shadow-dark-night),-12px -12px 24px var(--shadow-light-night)}.modal-header{display:flex;justify-content:space-between;align-items:center;font-size:20px;font-weight:600;margin-bottom:20px;flex-shrink:0; padding: 0 3px;}.modal-title-group{display:flex;align-items:center;gap:8px}.modal-header .close-btn,.modal-header .settings-btn{cursor:pointer;border:none;background:transparent;color:inherit;padding:5px;border-radius:50%;display:flex;align-items:center;justify-content:center;transition:background .2s ease}.modal-header .close-btn{font-size:24px;font-weight:bold;width:36px;height:36px}.modal-header .settings-btn{font-size:20px;width:32px;height:32px}.modal-header .close-btn:hover,.modal-header .settings-btn:hover{background:rgba(0,0,0,0.05)}body.dark-mode .modal-header .close-btn:hover,body.dark-mode .modal-header .settings-btn:hover{background:rgba(255,255,255,0.08)}
                .modal-body { overflow-y: auto; overflow-x: hidden; flex-grow: 1; display:flex; flex-direction:column; gap: 15px; margin-right: -5px; padding-right: 5px; scrollbar-width: none; -ms-overflow-style: none; -webkit-mask-image: linear-gradient(to bottom, black 95%, transparent 100%); mask-image: linear-gradient(to bottom, black 95%, transparent 100%); }


        .modal-body > * { margin-left: 3px; margin-right: 3px; width: calc(100% - 6px); }
        .modal-body::-webkit-scrollbar { width: 0; background: transparent; }
        .modal-input,.modal-select,.modal-textarea{padding:12px 15px;border:none;border-radius:10px;font-size:16px;background:var(--bg-day-element);color:var(--text-day);box-shadow:inset 4px 4px 8px var(--shadow-dark-day),inset -4px -4px 8px var(--shadow-light-day);transition:all .3s ease;caret-color:var(--hold-border)}body.dark-mode .modal-input,body.dark-mode .modal-select,body.dark-mode .modal-textarea{background:var(--bg-night-element);color:var(--text-night);box-shadow:inset 4px 4px 8px var(--shadow-dark-night),inset -4px -4px 8px var(--shadow-light-night)}.modal-input:focus,.modal-select:focus,.modal-textarea:focus{outline:none;box-shadow:inset 4px 4px 8px var(--shadow-dark-day),inset -4px -4px 8px var(--shadow-light-day),0 0 0 2px var(--hold-border)}body.dark-mode .modal-input:focus,body.dark-mode .modal-select:focus,body.dark-mode .modal-textarea:focus{box-shadow:inset 4px 4px 8px var(--shadow-dark-night),inset -4px -4px 8px var(--shadow-light-night),0 0 0 2px var(--hold-border)} .modal-textarea{resize:vertical;min-height:80px;}
        .modal-button{padding:14px;border:none;border-radius:12px;font-size:16px;font-weight:600;cursor:pointer;color:var(--hold-border);background:var(--bg-day-element);box-shadow:4px 4px 8px var(--shadow-dark-day),-4px -4px 8px var(--shadow-light-day);transition:all .2s ease}body.dark-mode .modal-button{color:var(--hold-border);background:var(--bg-night-element);box-shadow:4px 4px 8px var(--shadow-dark-night),-4px -4px 8px var(--shadow-light-night)}.modal-button:active{box-shadow:inset 4px 4px 8px var(--shadow-dark-day),inset -4px -4px 8px var(--shadow-light-day)}body.dark-mode .modal-button:active{box-shadow:inset 4px 4px 8px var(--shadow-dark-night),inset -4px -4px 8px var(--shadow-light-night)}.modal-button:disabled{color:#9db2c2;cursor:not-allowed;box-shadow:none;}
        #nukeDataBtn { background: #e53e3e !important; color: white !important; box-shadow: 4px 4px 8px rgba(229, 62, 62, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.9) !important; }
        #nukeDataBtn:active { background: #c53030 !important; box-shadow: inset 4px 4px 8px rgba(155, 37, 37, 0.7) !important; }
        #settingsModal .modal-body .nuke-section { margin: 15px 0 10px; border-top: 1px solid rgba(128,128,128,0.3); padding-top: 15px; display: flex; justify-content: center; }
        #syncErrorModal .modal-content { max-width: 450px; } #sync-error-message { padding: 12px; border-radius: 8px; background: rgba(255, 0, 0, 0.1); border: 1px solid rgba(255, 0, 0, 0.2); font-family: monospace; font-size: 14px; word-wrap: break-word; user-select: text; } body.dark-mode #sync-error-message { background: rgba(252, 129, 129, 0.1); border-color: rgba(252, 129, 129, 0.2); }
        #colorPaletteModal .modal-content, #helpModal .modal-content { max-width: 500px; } 
        .theme-style-selector { border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 20px; margin-bottom: 20px; } body.dark-mode .theme-style-selector { border-color: rgba(255,255,255,0.1); }
        .theme-style-selector label { font-size: 14px; color: #5a6778; display: block; margin-bottom: 8px; } body.dark-mode .theme-style-selector label { color: #c0c6cc; }
        #pneumorphism-settings.hidden { display: none; }
        #colorPaletteModal .modal-body { gap: 20px; padding-bottom: 15px; }
        .color-picker-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; } .color-picker-group { display: flex; flex-direction: column; gap: 8px; }
        .color-picker-group label { font-size: 14px; color: #5a6778; } body.dark-mode .color-picker-group label { color: #c0c6cc; }
        .color-input-wrapper { display: flex; align-items: center; border-radius: 10px; padding: 5px; background:var(--bg-day-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); } body.dark-mode .color-input-wrapper { background:var(--bg-night-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        input[type="color"] { width: 36px; height: 30px; border: none; background: transparent; cursor: pointer; -webkit-appearance: none; padding: 0; flex-shrink: 0; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; } input[type="color"]::-webkit-color-swatch { border-radius: 6px; border: none; }
               .hex-display { 
            flex-grow: 0; /* 核心修改：禁止输入框拉伸 */
            flex-shrink: 0; /* 禁止输入框收缩 */
            width: 4.5em; /* 核心修改：设置一个刚好容纳7个字符的宽度 (em单位相对于字体大小) */
            text-align: center; /* 文本居中更美观 */
            padding: 0; /* 移除内部左右边距 */
            font-family: monospace; 
            font-size: 16px; 
            color: #889;
             /* 覆盖 .modal-input 带来的额外内边距 */
            padding-left: 5px !important;
            padding-right: 5px !important;
        }
        .color-input-wrapper { 
            display: flex; 
            align-items: center; 
            gap: 8px; /* 新增：在颜色面板和输入框之间设置一个固定的8px间距 */
            border-radius: 10px; 
            padding: 5px 8px; /* 优化：稍微减少容器的左右内边距 */
            background:var(--bg-day-element); 
            box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); 
        } 
        body.dark-mode .color-input-wrapper { 
            background:var(--bg-night-element); 
            box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); 
        }

        .preview-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; } .preview-box { height: 40px; border-radius: 8px; position: relative; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .preview-box::before { content: attr(data-label); } #dayPreview { border: 2px solid var(--bg-day-element); color: var(--text-day); } body.dark-mode #dayPreview { border-color: rgba(255,255,255,0.1); }
        #nightPreview { border: 2px solid var(--bg-night-element); color: var(--text-night); } body.dark-mode #nightPreview { border-color: rgba(255,255,255,0.2); }
        .preset-manager, .background-image-manager { border-top: 1px solid rgba(0,0,0,0.1); padding-top: 20px; display: flex; flex-direction: column; gap: 15px; }
        body.dark-mode .preset-manager, body.dark-mode .background-image-manager { border-color: rgba(255,255,255,0.1); } 
        .preset-row, .background-image-row { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            /* [新增] 核心修复：确保容器不会因为内容溢出而被撑开 */
            min-width: 0; 
        }
        
        /* [新增] 针对 preset-row 内部输入框的特殊处理 */
        .preset-row .modal-input {
            /* [新增] 确保输入框本身不会被内容无限撑大 */
            min-width: 0;
            /* [新增] 当文本溢出时，用省略号显示 */
            text-overflow: ellipsis;
            /* [新增] 防止文本换行，与 ellipsis 配合使用 */
            white-space: nowrap;
            overflow: hidden;
        }

        .preset-row .modal-input, .preset-row .modal-select { flex-grow: 1; }
        .preset-row .modal-button, .background-image-row .modal-button { width: auto; padding: 12px 15px; flex-shrink: 0; font-size: 14px; }
        .preset-row .modal-button.save { color: #28a745; } .preset-row .modal-button.delete, .background-image-row .modal-button.delete { color: #dc3545; }
        .background-image-row .status { flex-grow: 1; font-size: 12px; color: #889; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .toggle-section { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-radius: 12px; background:var(--bg-day-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); }
        body.dark-mode .toggle-section { background:var(--bg-night-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; } .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 22px; } .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--hold-border); } input:checked + .slider:before { transform: translateX(18px); }
        
        #projectSelector.hidden { display: none; }
        #settingsModal .modal-content,#addNavModal .modal-content, #musicSettingsModal .modal-content {max-width:400px}
        #settingsModal .modal-body .form-section,#addNavModal .modal-body .form-section{display:flex;flex-direction:column;gap:8px}#settingsModal label,#addNavModal label{font-size:14px;color:#5a6778}body.dark-mode #settingsModal label,body.dark-mode #addNavModal label{color:#c0c6cc}
        .segmented-control { position: relative; display: flex; border-radius: 12px; padding: 5px; background:var(--bg-day-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); }
        body.dark-mode .segmented-control { background:var(--bg-night-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        .segmented-control label { position: relative; z-index: 1; flex: 1; text-align: center; padding: 10px; border-radius: 8px; cursor: pointer; transition: color .3s ease; font-weight: 600; }
        .segmented-control .slider-indicator { position: absolute; top: 5px; left: 5px; bottom: 5px; background: var(--bg-day-element); box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day); border-radius: 8px; transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); z-index: 0; }
        body.dark-mode .segmented-control .slider-indicator { background: var(--bg-night-element); box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night); }
        #addNavModal input[type="radio"]:checked + label, #helpModal input[type="radio"]:checked + label, #colorPaletteModal input[type="radio"]:checked + label { color: var(--hold-border); }
        #type-upload:checked ~ .slider-indicator { transform: translateX(100%); }
        #theme-style-glass:checked ~ .slider-indicator { transform: translateX(100%); }
        .segmented-control.two-segments .slider-indicator { width: calc(50% - 5px); }
        .segmented-control.three-segments .slider-indicator { width: calc(33.33% - 4px); }
        #addNavModal .status-text{text-align:center;font-size:14px;color:#889;min-height:20px} #addNavModal .modal-header { gap: 10px; } #addNavModal .modal-title-group { flex-grow: 1; }
        .header-toggle-group { display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: normal; color: #5a6778; } body.dark-mode .header-toggle-group { color: #c0c6cc; }
        .file-select-wrapper { display: flex; align-items: center; gap: 10px; width: 100%; } .file-select-wrapper .modal-button { flex-shrink: 0; width: auto; padding: 10px 15px; font-size: 14px; }
        .file-select-wrapper .status-text { flex-grow: 1; font-size: 14px; color: #889; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .file-upload-section { display: flex; flex-direction: column; gap: 10px; flex-shrink: 0; } input[type="file"] { display: none; }
.progress-container { 
    display: none; /* 初始隐藏 */
    align-items: center; 
    gap: 10px; /* 进度条和按钮的间距 */
    height: 36px; /* 增加容器高度以容纳按钮 */
} 
.progress-bar-wrapper {
    flex-grow: 1; /* 让进度条容器占据大部分空间 */
    height: 12px; 
    background: var(--bg-day-element); 
    border-radius: 6px; 
    box-shadow: inset 2px 2px 4px var(--shadow-dark-day), inset -2px -2px 4px var(--shadow-light-day); 
    padding: 2px;
}
body.dark-mode .progress-bar-wrapper { 
    box-shadow: inset 2px 2px 4px var(--shadow-dark-night), inset -2px -2px 4px var(--shadow-light-night); 
}
.progress-bar { 
    width: 0%; 
    height: 100%; 
    border-radius: 4px; 
    background-color: var(--hold-border); /* 使用主题高亮色 */ 
    transition: width 0.2s linear; 
}
#upload-cancel-btn {
    flex-shrink: 0; /* 防止按钮被压缩 */
    background: transparent;
    border: none;
    font-size: 20px;
    color: #aaa;
    cursor: pointer;
    padding: 5px;
    line-height: 1;
    transition: color 0.2s;
}
#upload-cancel-btn:hover {
    color: #e53e3e;
}

        #helpModal .modal-body { gap: 0; padding-top: 15px; } #helpModal .modal-body > input[name="help-tab"] { display: none; } 
      .help-page-content { display: none; padding: 15px 5px 40px 5px; overflow-x: hidden; } /* 修改点：底部内边距调整为 40px */


        .help-page-content h3 { font-size: 1.3em; margin: 20px 0 10px 0; padding-bottom: 5px; border-bottom: 1px solid rgba(128,128,128,0.3); } .help-page-content h4 { font-size: 1.1em; margin: 18px 0 8px 0; }
        .help-page-content p, .help-page-content li, .help-page-content a { line-height: 1.7; color: #4a5568; margin-bottom: 8px; word-wrap: break-word; }
        body.dark-mode .help-page-content p, body.dark-mode .help-page-content li, body.dark-mode .help-page-content a { color: #a0aec0; }
        .help-page-content ul, .help-page-content ol { padding-left: 25px; } .help-page-content ol li { margin-bottom: 12px; }
        .help-page-content strong { color: var(--hold-border); font-weight: 600; } .help-page-content code { background-color: rgba(128,128,128,0.15); padding: 2px 5px; border-radius: 4px; font-family: monospace; word-wrap: break-word; }
        .help-page-content a { color: var(--hold-border); text-decoration: none; font-weight: 600; } .help-page-content a:hover { text-decoration: underline; }
        .help-page-content .warning { background-color: rgba(229, 62, 62, 0.1); border-left: 4px solid #e53e3e; padding: 10px 15px; margin: 15px 0; border-radius: 0 8px 8px 0; }
        .help-page-content .important-note { background-color: rgba(91, 153, 226, 0.1); border-left: 4px solid var(--hold-border); padding: 10px 15px; margin: 15px 0; border-radius: 0 8px 8px 0; }
        /* == Iframe Modal & Confirmation Toast Styles == */
        .iframe-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000; transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        .iframe-modal-overlay.active { transform: translateX(0); }
        .iframe-modal-content { width: 100%; height: 100%; background: #fff; box-shadow: -5px 0 15px rgba(0,0,0,0.2); transition: transform 0.3s ease-out; }
        .iframe-modal-content.dragging { transition: none; }
        .iframe-modal-content iframe { width: 100%; height: 100%; border: none; }
        .swipe-hint { position: fixed; left: 0; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; background: rgba(0,0,0,0.6); color: white; padding: 15px 8px; border-radius: 0 8px 8px 0; z-index: 2001; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
        .swipe-hint.show { opacity: 1; }
        .swipe-hint .arrow { width: 16px; height: 16px; border-right: 3px solid white; border-bottom: 3px solid white; transform: rotate(-45deg); animation: hint-pulse 1.5s infinite; margin-bottom: 10px; }
        .swipe-hint span { writing-mode: vertical-rl; }
        @keyframes hint-pulse { 0% { opacity: 0.3; } 50% { opacity: 1; transform: rotate(-45deg) scale(1.1); } 100% { opacity: 0.3; } }
        #gestureCaptureZone { position: fixed; top: 50%; left: 0; width: 20px; height: 200px; transform: translateY(-50%); z-index: 2002; } /* REFINED: Gesture Area */
        #returnConfirmationToast { position: fixed; top: 0; left: 50%; transform: translate(-50%, -120%); width: calc(100% - 30px); max-width: 400px; background: var(--bg-night-element); color: var(--text-night); padding: 12px 16px; border-radius: 0 0 12px 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 2003; display: flex; justify-content: space-between; align-items: center; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); user-select: none; }
        #returnConfirmationToast.show { transform: translate(-50%, 0); }
        .toast-btn { background: transparent; border: none; color: white; font-size: 15px; font-weight: 600; padding: 8px 12px; border-radius: 8px; cursor: pointer; transition: background 0.2s; }
        .toast-btn-confirm { background-color: rgba(99, 179, 237, 0.8); } .toast-btn-confirm:hover { background-color: rgba(99, 179, 237, 1); }
        .toast-btn-cancel { background-color: rgba(255, 255, 255, 0.2); } .toast-btn-cancel:hover { background-color: rgba(255, 255, 255, 0.3); }
        @media (max-width: 480px) { .editable-title { font-size: 28px; } .editable-subtitle { font-size: 14px; } .title-card { padding: 30px 15px; } .nav-container { grid-template-columns: 1fr 1fr; gap: 18px; padding: 10px; } .nav-btn { padding: 18px 10px; font-size: 15px; } .fab-container { right: 20px; bottom: 20px; } .fab-main, .fab-drawer-item { width: 44px; height: 44px; font-size: 20px; } .fab-drawer { bottom: 55px; } .segmented-control label { font-size: 13px; padding: 8px 5px; } .category-nav { padding: 0 15px; } }
        
        /* ===== [START] MEMORY MODAL STYLES ===== */
        #memoryModal .modal-content { max-width: 800px; height: calc(100vh - 40px); padding: 0; display: flex; flex-direction: column; overflow: hidden; }
        #memoryModal .modal-header { padding: 0 15px; margin-top: 15px; margin-bottom: 10px; }
        #memoryModal .app-container { width: 100%; flex-grow: 1; display: flex; flex-direction: column; position: relative; overflow: hidden; }
        #memoryModal .page { width: 100%; height: 100%; display: none; flex-direction: column; position: absolute; top: 0; left: 0; opacity: 0; transform: scale(0.98); transition: opacity 0.3s ease, transform 0.3s ease; pointer-events: none; }
        #memoryModal .page.active { display: flex; opacity: 1; transform: scale(1); pointer-events: auto; z-index: 10; }
        #memoryModal .page-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; flex-shrink: 0; position: relative; }
        #memoryModal .page-header .title { position: absolute; left: 50%; transform: translateX(-50%); font-size: 20px; font-weight: 700; white-space: nowrap; }
        #memoryModal .header-btn { font-size: 16px; font-weight: 600; cursor: pointer; padding: 8px 12px; border-radius: 10px; transition: background-color 0.2s; border: none; background: transparent; color: inherit; z-index: 5; }
        #memoryModal .header-btn:hover { background-color: rgba(0,0,0,0.05); } body.dark-mode #memoryModal .header-btn:hover { background-color: rgba(255,255,255,0.1); }
        #memoryModal .header-btn.back-btn { font-size: 24px; padding: 5px 10px; }
        #memoryModal .header-btn.manage-btn { color: var(--hold-border); }
        #memoryModal .header-btn.wander-btn { font-size: 20px; padding: 6px; }
        #memoryModal .header-controls { display: flex; gap: 8px; align-items:center; }
#memoryModal .list-container { flex-grow: 1; overflow-y: auto; padding: 0 15px 80px 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 20px; align-content: flex-start; min-height: 0; /* [核心修复] 允许Flex容器在内容溢出时正确收缩 */ }
        #memoryModal #hub-view-content { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 30px; }
        #memoryModal .hub-btn { width: 80%; max-width: 300px; padding: 40px 20px; border: none; border-radius: 20px; box-shadow: 10px 10px 20px var(--shadow-dark-day), -10px -10px 20px var(--shadow-light-day); background: var(--bg-day-element); color: var(--text-day); font-size: 24px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        body.dark-mode #memoryModal .hub-btn { box-shadow: 10px 10px 20px var(--shadow-dark-night), -10px -10px 20px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        #memoryModal .hub-btn:active { box-shadow: inset 6px 6px 12px var(--shadow-dark-day), inset -6px -6px 12px var(--shadow-light-day); } body.dark-mode #memoryModal .hub-btn:active { box-shadow: inset 6px 6px 12px var(--shadow-dark-night), inset -6px -6px 12px var(--shadow-light-night); }
        #memoryModal #notes-list-container { grid-template-columns: 1fr; }
        #memoryModal .folder-item, #memoryModal .album-item { margin-bottom: 10px; position: relative; padding: 20px 15px; border: none; border-radius: 14px; box-shadow: 8px 8px 16px var(--shadow-dark-day), -8px -8px 16px var(--shadow-light-day); background: var(--bg-day-element); font-size: 16px; font-weight: 600; color: var(--text-day); cursor: pointer; transition: all 0.3s ease; user-select: none; -webkit-tap-highlight-color: transparent; text-align: left; }
        #memoryModal .note-item { position: relative; padding: 20px 15px; border: none; border-radius: 14px; box-shadow: 8px 8px 16px var(--shadow-dark-day), -8px -8px 16px var(--shadow-light-day); background: var(--bg-day-element); font-size: 16px; color: var(--text-day); cursor: pointer; transition: all 0.3s ease; user-select: none; -webkit-tap-highlight-color: transparent; text-align: left; }
        body.dark-mode #memoryModal .folder-item, body.dark-mode #memoryModal .note-item, body.dark-mode #memoryModal .album-item { box-shadow: 8px 8px 16px var(--shadow-dark-night), -8px -8px 16px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        #memoryModal .folder-item:active, #memoryModal .note-item:active, #memoryModal .album-item:active { box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); transform: translateY(0); }
        body.dark-mode #memoryModal .folder-item:active, body.dark-mode #memoryModal .note-item:active, body.dark-mode #memoryModal .album-item:active { box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        #memoryModal .folder-icon { font-size: 24px; margin-bottom: 10px; }
        #memoryModal .note-title { font-size: 18px; font-weight: bold; margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #memoryModal .note-preview { font-size: 14px; font-weight: normal; color: #6a7889; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        body.dark-mode #memoryModal .note-preview { color: #a0aec0; }
        #memoryModal .note-timestamp { font-size: 12px; font-weight: 300; color: #9A86A4; margin-top: 12px; }
        #memoryModal .album-item { aspect-ratio: 1 / 1; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-start; }
        #memoryModal .album-item .folder-icon { font-size: 32px; }
        #memoryModal .album-info { font-size: 12px; color: #889; }
#memoryModal #photo-list-container {
    display: flex;          /* 1. 声明为 Flexbox 弹性布局 */
    flex-wrap: wrap;        /* 2. 允许项目自动换行 */
    justify-content: flex-start; /* 3. 核心：实现从左到右排列 */
    min-height: 0;
    gap: 10px;              /* 4. 使用 gap 属性创建统一的 10px 间隙 */
}

        #memoryModal .photo-item, .photo-item-set {
    /* 核心：计算项目宽度，减去 gap 的空间，实现每行完美的3列 */
    width: calc(33.333% - 6.7px); 
    
    /* 你可以调整这里的百分比和减去的值来改变列数，例如 4 列：
       width: calc(25% - 7.5px);
       5 列：
       width: calc(20% - 8px);
    */
    
    aspect-ratio: 1 / 1;
    position: relative;
    overflow: hidden;
    border-radius: 25px;
    background-color: var(--item-bg-color);
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    
    /* 删除了所有旧的 display, vertical-align, width, margin 属性 */
}


        #memoryModal .photo-item img, .photo-item-set img { width: 100%; height: 100%; object-fit: cover; transition: transform 0.3s ease; }
        .photo-item-set .photo-stack-img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 12px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); transition: transform 0.3s ease; border: 2px solid var(--bg-day-element); }
        body.dark-mode .photo-item-set .photo-stack-img { border-color: var(--bg-night-element); }
        .photo-item-set .photo-stack-img:nth-child(1) { transform: translate(6px, 6px); z-index: 1; }
        .photo-item-set .photo-stack-img:nth-child(2) { transform: translate(3px, 3px); z-index: 2; }
        .photo-item-set .photo-stack-img:nth-child(3) { transform: translate(0, 0); z-index: 3; }
        .photo-item-set:hover .photo-stack-img:nth-child(1) { transform: translate(10px, 10px); }
        .photo-item-set:hover .photo-stack-img:nth-child(2) { transform: translate(5px, 5px); }
        #memoryModal .photo-title-overlay { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.6), transparent); color: white; font-size: 12px; padding: 12px 8px 4px 8px; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; z-index: 5; }
        .photo-item-set .count-overlay { position: absolute; bottom: 5px; right: 8px; background: rgba(0,0,0,0.5); color: white; padding: 2px 6px; font-size: 10px; font-weight: bold; border-radius: 4px; z-index: 5; }
        #memoryPhotoViewerOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 5000; display: flex; flex-direction: column; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        #memoryPhotoViewerOverlay.active { opacity: 1; pointer-events: auto; }
        #memoryPhotoViewerOverlay .viewer-header { flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; padding: 20px; color: white; background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent); z-index: 10;}
        #memoryPhotoViewerOverlay .viewer-header .counter { font-size: 16px; font-weight: bold; }
        #memoryPhotoViewerOverlay .viewer-btn { background: rgba(40,40,40,0.5); border: none; color: white; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; transition: background-color 0.2s; }
        #memoryPhotoViewerOverlay .viewer-btn:hover { background: rgba(60,60,60,0.7); }
        #memoryPhotoViewerOverlay .viewer-content { flex-grow: 1; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; }
        #viewer-img-container { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: padding 0.3s ease; }
        #memoryPhotoViewerOverlay #viewer-img { max-width: 100%; max-height: 100%; object-fit: contain; }
        #memoryPhotoViewerOverlay .nav-arrow { position: absolute; top: 50%; transform: translateY(-50%); width: 44px; height: 44px; font-size: 24px; opacity: 0.6; display: flex; align-items: center; justify-content: center; }
        #memoryPhotoViewerOverlay .nav-arrow:hover { opacity: 1; }
        #prev-photo-btn { left: 15px; } #next-photo-btn { right: 15px; }
        #memoryPhotoViewerOverlay .viewer-footer { flex-shrink: 0; padding: 20px; color: white; text-align: center; background: linear-gradient(to top, rgba(0,0,0,0.5), transparent); z-index: 10;}
        #viewer-title { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        #viewer-description { font-size: 14px; margin-bottom: 8px; }
        #viewer-timestamp { font-size: 12px; color: #ccc; }
        #memoryModal .empty-list-placeholder { grid-column: 1 / -1; text-align: center; color: #889; margin-top: 50px; }
        #memoryModal .fab { position: absolute; right: 25px; bottom: 25px; width: 50px; height: 50px; border-radius: 50%; border: none; cursor: pointer; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day); background: var(--bg-day-element); color: var(--text-day); font-size: 28px; display: flex; align-items: center; justify-content: center; user-select: none; z-index: 100; }
        body.dark-mode #memoryModal .fab { box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        #memoryModal .fab:active { transform: scale(0.95); }
        #memoryModal #note-editor-view { background: var(--bg-day-element); z-index: 200; padding: 10px; transform: translateY(100%); }
        body.dark-mode #memoryModal #note-editor-view { background: var(--bg-night-element); }
        body.theme-glass #memoryModal #note-editor-view, body.theme-glass.dark-mode #memoryModal #note-editor-view { background: transparent; }
        #memoryModal #note-editor-view.active { transform: translateY(0); }
        #memoryModal .editor-header{display:flex;justify-content:space-between;align-items:center;padding:10px 5px;flex-shrink:0}
        #memoryModal .editor-btn{padding:10px 18px;border:none;border-radius:12px;font-size:16px;font-weight:600;cursor:pointer;color:var(--hold-border);background:var(--bg-day-element);box-shadow:4px 4px 8px var(--shadow-dark-day),-4px -4px 8px var(--shadow-light-day);transition:all .2s ease}body.dark-mode #memoryModal .editor-btn{color:var(--hold-border);background:var(--bg-night-element);box-shadow:4px 4px 8px var(--shadow-dark-night),-4px -4px 8px var(--shadow-light-night)}
        #memoryModal .editor-btn:active{box-shadow:inset 4px 4px 8px var(--shadow-dark-day),inset -4px -4px 8px var(--shadow-light-day)}body.dark-mode #memoryModal .editor-btn:active{box-shadow:inset 4px 4px 8px var(--shadow-dark-night),inset -4px -4px 8px var(--shadow-light-night)}
        #memoryModal #delete-note-btn{color:#f56565}
        #memoryModal .editor-content{flex-grow:1;display:flex;flex-direction:column;gap:10px;padding:10px 5px; overflow-y: auto; min-height: 0;}
        #memoryModal #note-title-input,#memoryModal #note-content-textarea{width:100%;border:none;background:transparent;color:inherit;font-size:18px;padding:10px}
        #memoryModal #note-title-input{font-size:24px;font-weight:bold;flex-shrink:0}
       #memoryModal #note-content-textarea{resize:none;line-height:1.6}
        #memoryModal #note-title-input:focus,#memoryModal #note-content-textarea:focus{outline:none}
        #memoryFolderModal .modal-content, #memoryPhotoDetailsModal .modal-content { max-width: 400px; }
        #memoryPhotoDetailsModal #upload-thumbnail { max-width: 100px; max-height: 100px; border-radius: 8px; margin: 10px auto; object-fit: cover; }
        #memoryPhotoDetailsModal #photoset-toggle-container { display: none; padding: 10px; border-bottom: 1px solid rgba(128,128,128,0.2); }
        #memoryPhotoDetailsModal .modal-footer { display:flex; justify-content:flex-end; gap:10px; margin-top:20px; }
        #memoryPhotoDetailsModal .modal-button.primary { color: var(--hold-border); }
        #memoryModal .pin-btn { position: absolute; top: 10px; right: 10px; background: transparent; border: none; font-size: 13px; font-weight: 600; cursor: pointer; opacity: 0.3; transition: opacity 0.2s, transform 0.2s; z-index: 5; border-radius: 4px; padding: 2px 5px; }
        #memoryModal .note-item.pinned .pin-btn { opacity: 1; color: var(--hold-border); }
        #memoryModal .pin-btn:hover { transform: scale(1.2); }
        .management-controls { display: none; position: absolute; bottom: 0; left: 0; right: 0; padding: 15px; background: var(--bg-day-element); box-shadow: 0 -4px 12px rgba(0,0,0,0.1); z-index: 101; flex-direction: row; justify-content: space-between; gap: 10px; border-radius: 16px 16px 0 0;}
        body.dark-mode .management-controls { background: var(--bg-night-element); }
        .management-controls.active { display: flex; }
        .management-controls .modal-button { flex-grow: 1; margin: 0; padding: 12px; }
.folder-item.manage-mode, .album-item.manage-mode, .photo-item.manage-mode, .photo-item-set.manage-mode, .note-item.manage-mode { cursor: pointer; }
.folder-item .manage-checkbox, .album-item .manage-checkbox, .photo-item .manage-checkbox, .photo-item-set .manage-checkbox, .note-item .manage-checkbox { display: none; position: absolute; top: 10px; left: 10px; width: 22px; height: 22px; z-index: 5; }
.folder-item.manage-mode .manage-checkbox, .album-item.manage-mode .manage-checkbox, .photo-item.manage-mode .manage-checkbox, .photo-item-set.manage-mode .manage-checkbox, .note-item.manage-mode .manage-checkbox { display: block; }
.folder-item.manage-selected, .album-item.manage-selected, .photo-item.manage-selected, .photo-item-set.manage-selected, .note-item.manage-selected { border: 2px solid var(--hold-border); box-shadow: 0 0 0 2px var(--hold-border), 8px 8px 16px var(--shadow-dark-day), -8px -8px 16px var(--shadow-light-day) !important; }
body.dark-mode .folder-item.manage-selected, body.dark-mode .album-item.manage-selected, body.dark-mode .photo-item.manage-selected, body.dark-mode .photo-item-set.manage-selected, body.dark-mode .note-item.manage-selected { box-shadow: 0 0 0 2px var(--hold-border), 8px 8px 16px var(--shadow-dark-night), -8px -8px 16px var(--shadow-light-night) !important; }
        #cloud-drive-section .list-container { display: flex; flex-direction: column; gap: 15px; padding: 15px; overflow-y: hidden; min-height: 0; }
        #file-list-container { flex-shrink: 1; flex-grow: 1; min-height: 100px; overflow-y: auto; border-radius: 10px; padding: 5px; background:var(--bg-day-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); display: flex; flex-direction: column; }
        body.dark-mode #file-list-container { background:var(--bg-night-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        #file-list-container ul { list-style:none; padding: 5px; }
        #file-list-container li { padding: 8px 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; transition: background .2s; gap: 10px; position: relative; }
        #file-list-container li:hover { background-color: rgba(0,0,0,0.05); } body.dark-mode #file-list-container li:hover { background-color:rgba(255,255,255,0.08); }
        #fileListStatus { flex-grow: 1; text-align: center; color: #a0aec0; display: flex; align-items: center; justify-content: center; min-height: 50px; } body.dark-mode #fileListStatus { color:#889; }
        .file-info { flex-grow: 1; cursor: pointer; min-width: 0; }
        .file-name { display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 16px; }
                .file-meta { 
            font-size: 12px; 
            font-weight: 300; 
            color: #9A86A4; 
            flex-shrink: 0; /* [新增] 防止此元素在flex布局中被过度压缩 */
            margin-left: 10px; /* [新增] 与文件名保持一点间距 */
            white-space: nowrap; /* [新增] 确保大小和日期不换行 */
        }
        .delete-btn { background:transparent; border:none; cursor:pointer; padding:0; flex-shrink:0; width:28px; height:28px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:background .2s,color .2s; color:#bbb; font-size:22px; font-weight:bold; line-height:1; }
        .delete-btn:hover { background:#f0f0f0; color:#e53e3e; } body.dark-mode .delete-btn { color:#889; } body.dark-mode .delete-btn:hover { background:rgba(255,255,255,0.1); color:#fc8181; }

        /* ===== [END] MEMORY MODAL STYLES ===== */
        
        /* ===== [START] WANDER VIEW 4.0 STYLES (Architecture) ===== */
        @keyframes breathing-glow {
            0% { box-shadow: 0 0 8px 1px var(--handle-color); }
            50% { box-shadow: 0 0 16px 4px var(--handle-color); }
            100% { box-shadow: 0 0 8px 1px var(--handle-color); }
        }
        #wanderViewOverlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 6000; background: var(--bg-day-element); color: var(--text-day); display: none; flex-direction: column; opacity: 0; transition: opacity 0.4s ease; }
        body.dark-mode #wanderViewOverlay { background: var(--bg-night-element); color: var(--text-night); }
        #wanderViewOverlay.active { display: flex; opacity: 1; }
        .wander-header { display: flex; justify-content: flex-end; padding: 5px; flex-shrink: 0; position: absolute; top: 0; right: 0; z-index: 10001; }
        .wander-header .close-btn { font-size: 24px; font-weight: bold; width: 36px; height: 36px; cursor: pointer; border: none; background: transparent; color: inherit; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background .2s ease; }
        .wander-header .close-btn:hover { background: rgba(0,0,0,0.05); } body.dark-mode .wander-header .close-btn:hover { background: rgba(255,255,255,0.08); }
        .wander-main-content { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 10px 20px; overflow: hidden; min-height: 0; transition: transform 0.4s ease; }
        .wander-photo-container { position: relative; width: 100%; max-width: 500px; aspect-ratio: 0.85; display: flex; align-items: center; justify-content: center; transition: all 0.4s ease; margin: auto 0;
            background: white; box-shadow: 0 10px 25px rgba(0,0,0,0.1); border-radius: 4px; padding: 15px 15px 80px 15px;
        }
        #wander-img { cursor: pointer; width:100%; height:100%; object-fit: cover; }
        .wander-info-container { position: absolute; bottom: 15px; left: 15px; right: 15px; text-align: center; }
        #wander-title { font-size: 18px; font-weight: 700; margin-bottom: 5px; color: #333; }
        #wander-description { font-size: 14px; color: #777; line-height: 1.5; }
        .wander-photo-container.fullscreen { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; max-width: none; z-index: 10000; padding: 0; background: transparent; box-shadow: none; border-radius: 0; }
        .wander-photo-container.fullscreen::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: var(--blur-bg); background-size: cover; background-position: center; filter: blur(20px); transform: scale(1.1); opacity: 0.8; z-index: -1; }
        .wander-photo-container.fullscreen #wander-img { padding: 0; background: transparent; box-shadow: none; border-radius: 0; width: 100%; height: 100%; object-fit: contain; }
        .wander-photo-container.fullscreen .wander-info-container { display: none; }
        .wander-music-player { position: relative; flex-shrink: 0; width: calc(100% - 20px); max-width: 400px; margin: 0 auto 15px auto; z-index: 15; transition: transform 0.4s ease; }
        .wander-music-player.hidden { display: none; }
        .player-handle-container { padding: 10px 0 5px; cursor: pointer; }
        .player-handle { width: 40px; height: 5px; border-radius: 2.5px; background: #ccc; margin: 0 auto; } body.dark-mode .player-handle { background: #555; }
        .wander-music-player.collapsed { transform: translateY(calc(100% - 30px)); }
        .wander-music-player.collapsed .player-content { box-shadow: none; background: transparent; }
        .wander-music-player.collapsed > *:not(.player-handle-container) { display: none; }
        .player-content { padding: 15px; border-radius: 24px; background: var(--bg-day-element); box-shadow: 8px 8px 16px var(--shadow-dark-day), -8px -8px 16px var(--shadow-light-day); }
        body.dark-mode .player-content { background: var(--bg-night-element); box-shadow: 8px 8px 16px var(--shadow-dark-night), -8px -8px 16px var(--shadow-light-night); }
        .player-controls { display: flex; justify-content: space-between; align-items: center; gap: 5px; margin-top: 10px; }
        .player-btn { width: 44px; height: 44px; border-radius: 50%; border: none; background: var(--bg-day-element); box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day); color: var(--text-day); font-size: 18px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .player-btn svg { width: 1em; height: 1em; fill: currentColor; }
        body.dark-mode .player-btn { background: var(--bg-night-element); box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night); color: var(--text-night); }
        .player-btn:active { box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); }
        body.dark-mode .player-btn:active { box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        .player-btn#play-pause-btn { width: 52px; height: 52px; font-size: 22px; }
        .player-display { margin: 10px 0; height: 1.5em; text-align: center; font-size: 14px; overflow: hidden; display: flex; flex-direction: column; justify-content: center; position: relative; }
        .song-title-display { display: flex; align-items: center; justify-content: center; height: 100%; font-weight: 600; }
        #lyrics-container { position: absolute; width: 100%; height: 1.5em; top: 0; left: 0; overflow: hidden; }
        #lyrics-ul { list-style: none; transition: transform 0.5s ease; padding: 0; margin: 0;}
        #lyrics-ul li { line-height: 1.5em; opacity: 0.5; transition: opacity 0.5s ease; }
        #lyrics-ul li.current-lyric { opacity: 1; font-weight: bold; }
        .player-progress-track { position: relative; height: 16px; margin: 10px 0 0 0; cursor: pointer; --handle-color: var(--handle-color-day); }
        body.dark-mode .player-progress-track { --handle-color: var(--handle-color-night); }
        .player-progress-bar-bg { position: absolute; top: 50%; transform: translateY(-50%); left:0; right: 0; height: 3px; background-color: rgba(128,128,128,0.2); border-radius: 1.5px; }
        #player-progress-bar { position: absolute; top: 50%; transform: translateY(-50%); left:0; height: 3px; background-color: var(--handle-color); border-radius: 1.5px; width: 0; }
        #player-progress-handle { position: absolute; top: 50%; left: 0; width: 14px; height: 14px; transform: translate(-50%, -50%); background-color: var(--handle-color); border-radius: 50%; box-shadow: 0 0 8px 1px var(--handle-color); transition: box-shadow 0.3s ease; }
        #player-progress-handle.playing { animation: breathing-glow 2s ease-in-out infinite; }
        .player-progress-track:hover #player-progress-handle { box-shadow: 0 0 12px 3px var(--handle-color); }
        .player-popover { display: none; position: absolute; bottom: calc(100% + 10px); left: 15px; width: 250px; background: var(--bg-day-element); border-radius: 12px; box-shadow: 0 -5px 20px rgba(0,0,0,0.1); padding: 10px; border: 1px solid rgba(0,0,0,0.05); z-index: 20; }
        .player-popover.active { display: block; }
        body.dark-mode .player-popover { background: var(--bg-night-element); border-color: rgba(255,255,255,0.1); }
        .player-popover .popover-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 0 5px; }
        .player-popover h4 { font-size: 16px; flex-grow: 1; }
        .player-popover .settings-btn { width: 32px; height: 32px; font-size: 20px; flex-shrink: 0; }
        .player-popover ul { list-style: none; max-height: 150px; overflow-y: auto; padding: 0; }
        .player-popover li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; }
        .player-popover li:hover { background: rgba(0,0,0,0.05); } body.dark-mode .player-popover li:hover { background: rgba(255,255,255,0.08); }
        .player-popover li.playing { color: var(--hold-border); font-weight: bold; }
        .player-popover .playlist-item-name { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #musicSettingsModal.modal-overlay { z-index: 15000; }
        #musicSettingsModal .modal-body { gap: 20px; }
        .music-upload-section, .music-playlist-section { border-top: 1px solid rgba(0,0,0,0.1); padding-top: 20px; display: flex; flex-direction: column; gap: 15px; }
        .music-upload-section .confirm-upload-wrapper { display: flex; justify-content: center; padding-top: 5px; }
        body.dark-mode .music-upload-section, body.dark-mode .music-playlist-section { border-color: rgba(255,255,255,0.1); }
        #music-playlist-container { max-height: 200px; overflow-y: auto; list-style: none; padding: 0; margin: 0; }
        #music-playlist-container li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-radius: 6px; }
        #music-playlist-container li:hover { background: rgba(0,0,0,0.05); } body.dark-mode #music-playlist-container li:hover { background: rgba(255,255,255,0.08); }
        #music-playlist-container li.playing { color: var(--hold-border); font-weight: bold; }
        #music-playlist-container .song-name { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; }
        #music-playlist-container .delete-song-btn { width: 28px; height: 28px; color: #aaa; } #music-playlist-container .delete-song-btn:hover { color: #f56565; background: rgba(229, 62, 62, 0.1); }
        .music-loader{width:1.2em;height:1.2em;border:2px solid rgba(128,128,128,0.3);border-top-color:var(--hold-border);border-radius:50%;animation:spin 1s linear infinite;margin:0 auto}
        @keyframes spin{to{transform:rotate(360deg)}}
        /* ===== [END] WANDER VIEW STYLES ===== */
        
        /* ===== [START] HELP MODAL UPDATE STYLES ===== */
        .segmented-control.four-segments .slider-indicator { width: calc(25% - 4px); }
        #help-tab-0:checked ~ .segmented-control .slider-indicator { transform: translateX(0%); }
        #help-tab-1:checked ~ .segmented-control .slider-indicator { transform: translateX(100%); }
        #help-tab-2:checked ~ .segmented-control .slider-indicator { transform: translateX(200%); }
        #help-tab-3:checked ~ .segmented-control .slider-indicator { transform: translateX(300%); }

        #help-tab-0:checked ~ .help-content-wrapper > #help-page-0,
        #help-tab-1:checked ~ .help-content-wrapper > #help-page-1,
        #help-tab-2:checked ~ .help-content-wrapper > #help-page-2,
        #help-tab-3:checked ~ .help-content-wrapper > #help-page-3 { display: block; }
        
        details { border: 1px solid rgba(128,128,128,0.2); border-radius: 8px; margin-bottom: 12px; }
        summary { cursor: pointer; padding: 12px 15px; font-weight: bold; font-size: 1.1em; list-style: none; }
        summary::-webkit-details-marker { display: none; }
        summary::before { content: '▶'; margin-right: 8px; display: inline-block; transition: transform 0.2s; }
        details[open] > summary::before { transform: rotate(90deg); }
        .details-content { padding: 0 15px 15px 15px; border-top: 1px solid rgba(128,128,128,0.2); }
        .details-content p, .details-content ul, .details-content div { margin-top: 10px; }
        .details-content ul { padding-left: 20px; }
        .details-content .sub-note { font-size: 0.9em; color: #889; }

        .update-header-info {
            padding: 10px 15px;
            background-color: rgba(128,128,128,0.1);
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 14px;
        }
        .update-header-info p { margin: 5px 0; color: inherit; }
        .update-log-entry {
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(128,128,128,0.2);
        }
        .update-log-entry:last-of-type { border-bottom: none; }
        .update-log-entry h4 { font-size: 1.2em; margin: 0 0 10px 0; }
        .update-date { font-size: 0.8em; font-weight: normal; color: #889; }
        .update-log-entry ul { list-style: none; padding-left: 5px; }
        .update-log-entry li { margin-bottom: 8px; display: flex; align-items: flex-start; }
        .tag {
            flex-shrink: 0;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 10px;
            color: white;
        }
        .tag.new { background-color: #769fcd; } /* Morandi Blue */
        .tag.fix { background-color: #93b5b3; } /* Morandi Green */
        .tag.opt { background-color: #d1a787; } /* Morandi Orange/Brown */
        .tag.release { background-color: #b091a2; }
         .update-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            color: #888; /* 修改点：加深日间模式的文字颜色 */
            padding: 8px 0 15px 0;
            background: transparent;
            border-top: none;
            margin: 0;
            pointer-events: none;
            /* 核心修改：添加文字阴影以增强可读性 */
            text-shadow: 0 0 5px rgba(255, 255, 255, 1), 0 0 10px rgba(255, 255, 255, 0.8);
        }
        body.dark-mode .update-footer {
             color: #a0aec0; /* 修改点：为夜间模式设置一个合适的亮色 */
             /* 核心修改：为夜间模式添加更强的黑色阴影 */
             text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 0 10px rgba(0, 0, 0, 0.4);
        }



        body.dark-mode .update-footer { background: var(--bg-night-element); }

        .fab-drawer-item#helpBtn { position: relative; }
        .fab-drawer-item.has-update::after {
            content: '';
            position: absolute;
            top: 6px;
            right: 6px;
            width: 8px;
            height: 8px;
            background-color: #e53e3e;
            border-radius: 50%;
            border: 1px solid white;
            box-shadow: 0 0 5px #e53e3e;
        }
        /* ===== [END] HELP MODAL UPDATE STYLES ===== */

        /* ... 你现有的其他 CSS ... */
        .fab-drawer-item.has-update::after {
            /* ... */
        }
        /* ===== [END] HELP MODAL UPDATE STYLES ===== */


        /* =============================================================== */
        /* ============ [新增] iOS 提示模态框的微调样式 ============ */
        /* =============================================================== */
        #iosWarningModal .modal-body p {
            line-height: 1.6;
            margin-bottom: 12px;
        }
        #iosWarningModal .modal-body strong {
            color: var(--hold-border);
            font-weight: 600;
        }
        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */


        /* ===== [START] FROSTED GLASS THEME ===== */
        body.theme-glass .modal-overlay,
        /* ... */


        /* ===== [START] FROSTED GLASS THEME ===== */
        body.theme-glass .modal-overlay,
        body.theme-glass #memoryPhotoViewerOverlay {
            background: transparent;
        }
        body.theme-glass .nav-btn,
        body.theme-glass .title-card,
        body.theme-glass .fab-main,
        body.theme-glass .fab-drawer-item,
        body.theme-glass .modal-content,
        body.theme-glass .category-pill,
        body.theme-glass .player-content,
        body.theme-glass .player-popover,
        body.theme-glass #memoryModal .hub-btn,
        body.theme-glass .phone-partition-item, /* ★★★ 新增此行 ★★★ */
        body.theme-glass #memoryModal .folder-item,
        body.theme-glass #memoryModal .note-item,
        body.e-glass #memoryModal .album-item,
        body.theme-glass #memoryModal .fab,
        body.theme-glass #memoryModal .editor-btn,
        body.theme-glass #memoryModal #note-editor-view,
        body.theme-glass .management-controls,
        body.theme-glass #returnConfirmationToast {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
        }
        body.theme-glass.dark-mode .nav-btn,
        body.theme-glass.dark-mode .title-card,
        body.theme-glass.dark-mode .fab-main,
        body.theme-glass.dark-mode .fab-drawer-item,
        body.theme-glass.dark-mode .modal-content,
        body.theme-glass.dark-mode .category-pill,
        body.theme-glass.dark-mode .player-content,
        body.theme-glass.dark-mode .player-popover,
        body.theme-glass.dark-mode #memoryModal .hub-btn,
        body.theme-glass.dark-mode #memoryModal .folder-item,
        body.theme-glass.dark-mode #memoryModal .note-item,
        body.theme-glass.dark-mode #memoryModal .album-item,
        body.theme-glass.dark-mode #memoryModal .fab,
        body.theme-glass.dark-mode #memoryModal .editor-btn,
        body.theme-glass.dark-mode #memoryModal #note-editor-view,
        body.theme-glass.dark-mode .management-controls,
        body.theme-glass.dark-mode #returnConfirmationToast {
            background: rgba(20, 20, 20, 0.25);
            border-color: rgba(255, 255, 255, 0.1);
        }

        body.theme-glass .modal-input,
        body.theme-glass .modal-select,
        body.theme-glass .modal-textarea,
        body.theme-glass .segmented-control,
        body.theme-glass .toggle-section,
        body.theme-glass #file-list-container,
        body.theme-glass .color-input-wrapper {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: none;
        }
        body.theme-glass.dark-mode .modal-input,
        body.theme-glass.dark-mode .modal-select,
        body.theme-glass.dark-mode .modal-textarea,
        body.theme-glass.dark-mode .segmented-control,
        body.theme-glass.dark-mode .toggle-section,
        body.theme-glass.dark-mode #file-list-container,
        body.theme-glass.dark-mode .color-input-wrapper {
            background: rgba(10, 10, 10, 0.2);
            border-color: rgba(255, 255, 255, 0.1);
        }

        body.theme-glass .modal-button {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        body.theme-glass.dark-mode .modal-button {
             background: rgba(30, 30, 30, 0.4);
        }

                body.theme-glass .nav-btn:active,
        body.theme-glass .modal-button:active,
        body.theme-glass .fab-main:active,
        body.theme-glass .fab-drawer-item:active {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transform: translateY(1px);
        }

        body.theme-glass .segmented-control .slider-indicator {
            background: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.6);
        }
        body.theme-glass.dark-mode .segmented-control .slider-indicator {
             background: rgba(200, 200, 200, 0.25);
             border-color: rgba(255, 255, 255, 0.15);
        }
        /* [V3 最终修正] 强制修正颜色选择器布局，杜绝溢出 */
        .color-input-wrapper {
            display: flex;
            align-items: center;
            /* 使用一个非常小的间距 */
            gap: 6px;
            /* 容器的内边距也相应减小 */
            padding: 5px 8px;
        }

        /* 为颜色选择器本身设置固定尺寸，且不允许收缩 */
        .color-input-wrapper input[type="color"] {
            width: 40px; /* 固定宽度 */
            height: 28px; /* 固定高度 */
            flex-shrink: 0; /* 核心：禁止此元素收缩 */
            border: none;
            padding: 0;
            background: none;
        }

        /* 为十六进制输入框设置一个固定的、紧凑的尺寸 */
        .color-input-wrapper .hex-display.modal-input {
            flex: 0 0 auto; /* 核心：禁止增长和收缩，宽度由width属性决定 */
            width: 85px; /* 核心：设置一个足以容纳7个字符和少量边距的固定宽度 */

            /* 重置所有可能导致问题的样式 */
            box-shadow: none !important;
            background: transparent !important;
            border: none !important;
            outline: none !important;
            padding: 0 5px; /* 给予文字左右5px的呼吸空间 */
            margin: 0;
            text-align: center; /* 文本居中 */

            /* 确保文本颜色在不同模式下正确显示 */
            color: var(--text-day);
        }


        body.dark-mode .color-input-wrapper .hex-display.modal-input {
            color: var(--text-night);
        }

        /* ===== [END] FROSTED GLASS THEME ===== */
        /* [新增] 为“已确认”的十六进制代码添加变淡的样式 */
        .hex-display.modal-input.confirmed-color {
            color: #a0aec0; /* 一个比默认文字更淡的灰色 */
            opacity: 0.8; /* 稍微降低不透明度 */
            transition: color 0.3s ease, opacity 0.3s ease; /* 添加平滑过渡效果 */
        }
        body.dark-mode .hex-display.modal-input.confirmed-color {
            color: #718096; /* 夜间模式下对应的淡灰色 */
        }

        /* ===== [START] FLOATING JELLYFISH BALL STYLES (MODIFIED) ===== */
        .jelly-ball-wrapper { /* MODIFICATION: New wrapper for custom CSS support */
            position: fixed;
            z-index: 2005;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease, transform 0.3s ease, left 0.2s ease-out, top 0.2s ease-out;
            pointer-events: none; /* MODIFICATION: Wrapper is non-interactive */
        }
        .jelly-ball-wrapper .jelly-ball-glow { /* MODIFICATION: New glow element */
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            animation: jelly-glow 2.5s infinite ease-in-out;
            filter: drop-shadow(0 0 2px rgba(91, 153, 226, 0.7));
        }

        @keyframes jelly-glow {
            0% { filter: drop-shadow(0 0 2px var(--hold-border, rgba(91, 153, 226, 0.7))); }
            50% { filter: drop-shadow(0 0 8px var(--hold-border, rgba(91, 153, 226, 1))); }
            100% { filter: drop-shadow(0 0 2px var(--hold-border, rgba(91, 153, 226, 0.7))); }
        }
        #floating-jellyfish-ball {
            position: relative; /* MODIFICATION: Changed from fixed */
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: grab;
            user-select: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: transform 0.3s ease; /* MODIFICATION: Removed other transitions */
            pointer-events: auto; /* MODIFICATION: Ball itself is interactive */
        }
        body.dark-mode #floating-jellyfish-ball {
            background: rgba(30, 30, 30, 0.6);
            border-color: rgba(255, 255, 255, 0.15);
        }
        .jelly-ball-wrapper.dragging { /* MODIFICATION: Dragging class on wrapper */
            transition: none;
        }
        #floating-jellyfish-ball.dragging {
            cursor: grabbing;
            transform: scale(1.1);
        }
        .jelly-ball-wrapper.idle { /* MODIFICATION: Idle class on wrapper */
            opacity: 0.5;
        }
        .jelly-ball-wrapper.idle.snap-right {
            transform: translateX(66.67%); /* MODIFICATION: Hide 2/3 of the ball */
        }
        .jelly-ball-wrapper.idle.snap-left {
            transform: translateX(-66.67%); /* MODIFICATION: Hide 2/3 of the ball */
        }
        .jelly-menu {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .jelly-menu-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 38px;
            height: 38px;
            margin: -19px 0 0 -19px;
            background: inherit;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            box-shadow: inherit;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
        }
        #floating-jellyfish-ball.menu-open .jelly-menu-btn {
            transform: var(--transform-end);
            opacity: 1;
            pointer-events: auto;
        }
        .jelly-menu-btn.hovered {
            transform: var(--transform-end) scale(1.15) !important;
            filter: brightness(1.1);
        }
        /* ===== [END] FLOATING JELLYFISH BALL STYLES ===== */

        /* ===== [START] FLOATING PROJECT WINDOW STYLES ===== */
        .floating-project-window {
            position: fixed;
            z-index: 2010;
            width: 350px;
            height: 500px;
            background: var(--bg-day-element);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* resize: both;  */ /* Using custom resizer */
            min-width: 250px;
            min-height: 300px;
            transition: opacity 0.3s ease, transform 0.3s ease;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            opacity: 0;
        }
        .floating-project-window.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        body.dark-mode .floating-project-window {
            background: var(--bg-night-element);
        }
        body.theme-glass .floating-project-window {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
        }
        body.theme-glass.dark-mode .floating-project-window {
            background: rgba(20, 20, 20, 0.25);
            border-color: rgba(255, 255, 255, 0.1);
        }
        .fpw-header {
            flex-shrink: 0;
            padding: 8px 12px;
            background: rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        body.dark-mode .fpw-header { background: rgba(255,255,255,0.05); }
        .fpw-header:active { cursor: grabbing; }
        .fpw-title {
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .fpw-controls { display: flex; align-items: center; gap: 4px; }
        .fpw-controls button {
            background: transparent;
            border: none;
            color: inherit;
            font-size: 18px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.2s;
            line-height: 28px;
        }
        .fpw-controls button:hover { background: rgba(0,0,0,0.1); }
        .fpw-content {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }
        .fpw-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .fpw-resizer {
            position: absolute;
            width: 20px;
            height: 20px;
            right: 0;
            bottom: 0;
            cursor: se-resize;
            z-index: 10;
        }
        
                .fpw-hide-handle {
            position: fixed;
            z-index: 2009;
            padding: 10px 8px;
            background: var(--bg-day-element);
            color: var(--text-day);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            cursor: pointer;
            transition: opacity 0.3s ease, top 0.3s ease; /* 修改点：增加了 top 属性的过渡效果 */
            font-size: 12px;
            font-weight: 600;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
        }

        .fpw-hide-handle.visible {
            opacity: 1;
            pointer-events: auto;
        }
        body.dark-mode .fpw-hide-handle { background: var(--bg-night-element); color: var(--text-night); }
        /* ===== [END] FLOATING PROJECT WINDOW STYLES ===== */

        /* ===== [START] CSS HELP MODAL STYLES ===== */
        #jelly-css-help-modal .modal-content { max-width: 600px; }
        #jelly-css-help-modal .modal-body { gap: 10px; }
        .css-help-section { padding: 12px 15px; border-radius: 10px; background: rgba(0,0,0,0.03); }
        body.dark-mode .css-help-section { background: rgba(255,255,255,0.03); }
        .css-help-section h3 { font-size: 1.25em; margin-bottom: 10px; color: var(--hold-border); text-align: center; border-bottom: 1px solid rgba(128,128,128,0.2); padding-bottom: 8px;}
        .css-help-section h4 { font-size: 1.1em; margin-top: 15px; margin-bottom: 5px; }
        .css-help-section p, .css-help-section li { line-height: 1.6; font-size: 0.95em; }
        .css-help-text-block { background-color: rgba(128,128,128,0.1); padding: 12px; border-radius: 8px; margin-top: 5px; font-family: monospace; white-space: pre-wrap; word-break: break-all; font-size: 13px; position:relative;}
        .css-help-text-block .copy-btn { position: absolute; top: 8px; right: 8px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: inherit; padding: 4px 8px; border-radius: 5px; font-size: 12px; cursor: pointer; transition: background 0.2s; }
        .css-help-text-block .copy-btn:hover { background: rgba(255,255,255,0.4); }

/* 你可以把这段 CSS 放在 <style> 标签的末尾 */
#iosPwaWarningModal .modal-header {
    justify-content: center; /* 让标题居中 */
}
#iosPwaWarningModal .important-note {
    border-left-color: #e53e3e; /* 强化警告区域的边框颜色 */
    background-color: rgba(229, 62, 62, 0.1);
}

        /* ===== [END] CSS HELP MODAL STYLES ===== */

/* =============================================================== */
/* ============= [新增] 拖拽排序功能专属样式 V1.0 ============= */
/* =============================================================== */

/* 当拖拽发生时，给 body 添加此类，以防止意外的文本选择 */
body.dragging-active {
    user-select: none;
    -webkit-user-select: none;
    cursor: grabbing !important;
}

/* 正在被拖拽的原始按钮的样式，让它“占位”但视觉上弱化 */
.nav-btn.dragging,
.category-pill.dragging {
    opacity: 0.4;
    animation: none !important; /* 拖拽时停止抖动动画 */
    transform: none !important;
}

/* 跟随手指移动的半透明虚影的样式 */
.drag-ghost {
    position: fixed; /* 使用 fixed 定位，使其可以在全屏自由移动 */
    pointer-events: none; /* 让鼠标事件可以穿透虚影，检测到下方的元素 */
    z-index: 9999;
    opacity: 0.8;
    transform: scale(1.08); /* 拖拽时微微放大，有被“拿起”的感觉 */
    transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

/* 当一个按钮成为有效的放置目标时的样式 */
.nav-btn.drag-over,
.category-pill.drag-over {
    transform: scale(1.05) !important; /* 目标位置微微放大 */
    animation: none !important; /* 悬停时也停止抖动 */
    box-shadow: 0 0 18px 4px var(--hold-border, #63b3ed) !important; /* 关键的蓝色光晕特效 */
    transition: all 0.2s ease-in-out;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 非阻塞式顶部提示框样式 ============ */
/* =============================================================== */
.top-toast {
    position: fixed;
    top: 0;
    left: 50%;
    transform: translate(-50%, -150%); /* 初始位置在屏幕外 */
    padding: 12px 20px;
    background: var(--bg-day-element); /* 适配主题背景 */
    color: #6c757d; /* 设置为清晰的灰色字体 */
    border-radius: 0 0 12px 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), inset 0 -1px 0 rgba(0,0,0,0.05); /* 适配主题的阴影 */
    z-index: 9999;
    font-size: 15px;
    font-weight: 600;
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
    pointer-events: none; /* 不会阻挡鼠标点击 */
    text-align: center;
    max-width: 90%;
}
/* 新增：夜间模式适配 */
body.dark-mode .top-toast {
    background: var(--bg-night-element);
    color: #a0aec0; /* 夜间模式使用更亮的灰色 */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}
/* 新增：磨砂玻璃主题适配 */
body.theme-glass .top-toast {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-top: none;
    color: #343a40;
}
body.theme-glass.dark-mode .top-toast {
    background: rgba(30, 30, 30, 0.4);
    border-color: rgba(255, 255, 255, 0.15);
    color: #e9ecef;
}

.top-toast.show {
    transform: translate(-50%, 0); /* 移动到屏幕内 */
    opacity: 1;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ============== [修正] 手机模式专属样式 V3 ================= */
/* =============================================================== */

/* 默认状态下，滑动容器是完全不存在的 */
.main-wrapper {
    display: none;
}

/* 仅当手机模式开启时，应用以下所有样式 */
body.mobile-mode {
    /* 1. 强制 body 停止原有的 flex 布局，并禁止滚动 */
    display: block !important;
    overflow: hidden !important;
}

body.mobile-mode .main-wrapper {
    /* 2. 显示滑动容器并使其铺满整个屏幕 */
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

/* 3. 原始的主页元素在手机模式下需要被隐藏，以避免冲突 */
body.mobile-mode > .title-card,
body.mobile-mode > .category-nav-container,
body.mobile-mode > .nav-container {
    display: none !important;
}

body.mobile-mode .page-slider {
    display: flex;
    width: 200%;
    height: 100%;
    transform: translateX(0); /* 默认展示锁屏 */
    transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
}

body.mobile-mode .page-slider.show-home-screen {
    transform: translateX(-50%); /* 滑动到主屏幕 */
}

/* [修改] 默认隐藏右下角按钮，并添加过渡动画 */
body.mobile-mode .fab-container {
    opacity: 0;
    transform: scale(0.8);
    pointer-events: none;
    transition: opacity 0.3s ease, transform 0.3s ease;
}

/* [修改] 当 body 具有 .mobile-home-screen-active 类时，显示按钮 */
body.mobile-mode.mobile-home-screen-active .fab-container {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}

body.mobile-mode .lock-screen-page,
body.mobile-mode .home-screen-page {
    width: 50%;
    height: 100%;
    flex-shrink: 0;
    overflow: hidden; /* 页面本身不滚动，这是正确的 */
    padding: 4vh 0 2vh 0; /* 修改：移除左右内边距，给底部留一点空间 */
    display: flex;
    flex-direction: column;
    align-items: center; /* [核心修改] 新增此行，使其内部元素水平居中 */
    justify-content: center; /* [核心修改] 新增此行，使其内部元素垂直居中 */
}


/* ===== [新增] 手机模式下，主屏幕内部元素的布局控制 ===== */

/* 手机模式下，标题卡片的自适应宽度和间距 (新版本) */
body.mobile-mode .home-screen-page > .title-card {
    width: 90%;          /* 关键：设定一个相对于父容器的固定百分比宽度 */
    max-width: 450px;      /* 可选：在非常宽的屏幕上（如平板）限制最大宽度 */
    margin-left: auto;   /* 关键：让浏览器自动计算左边距 */
    margin-right: auto;  /* 关键：让浏览器自动计算右边距 */
    flex-shrink: 0;      
}

/* 如果分类导航也需要修改，可以采用类似的方法 */
body.mobile-mode .home-screen-page > .category-nav-container {
    flex-shrink: 0;
    /* 保持原样或根据需要调整，目前分类导航占满宽度左右滑动是比较常见的体验 */
    width: 100%; 
    padding-left: 20px;
    padding-right: 20px;
}


/* 2. 可滚动元素 (按钮区域) 填满所有剩余空间并开启内部滚动 */
body.mobile-mode .home-screen-page > .scrollable-nav-wrapper {
    flex-grow: 1;         /* 关键：占据所有剩余的垂直空间 */
    overflow-y: auto;     /* 关键：当内容超出时，只在这个容器内显示垂直滚动条 */
    min-height: 0;        /* 关键：Flex布局中的重要技巧，防止内容撑开容器 */
    width: 100%;          /* 确保占满容器宽度 */
    padding-left: 10px;   /* 将水平内边距应用到子元素上 */
    padding-right: 10px;
    padding-bottom: 80px; /* 为底部留出额外空间，避免按钮紧贴屏幕边缘 */
}



.lock-screen-page {
    padding-top: 2vh;
    padding-bottom: 2vh;
    overflow: hidden; /* 确保页面本身不滚动 */
    /* [核心修改] 父容器只负责垂直布局和水平居中其子元素 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
.lockscreen-grid {
    /* [核心修改] 模仿 title-card 的布局模式 */
    width: calc(100% - 40px); /* 关键：自身宽度为父容器宽度减去两侧边距 */
    max-width: 500px;
    /* [移除] margin: 0 auto; 和 flex-grow: 1; 由JS动态控制高度 */
    position: relative; 
    min-height: 0;
    --widget-gap: 15px;
}


.home-screen-page .title-card,
.home-screen-page .category-nav-container,
.home-screen-page .nav-container {
    transition: transform 0.4s ease-out, opacity 0.3s ease-out;
}

body.mobile-mode .page-slider:not(.show-home-screen) .home-screen-page > * {
    transform: translateX(100px);
    opacity: 0;
}
/* =============================================================== */
/* ========================= [修正结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ============= [重构] 锁屏组件及设置相关样式 V2 ============ */
/* =============================================================== */

/* 组件基础样式 */
.widget {
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-day);
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    padding: 8px;
    box-sizing: border-box;
    text-align: center;
    overflow: hidden;
    /* [核心修复] 允许flex容器收缩至小于其内容尺寸，防止iframe撑开布局 */
    min-height: 0; 
}

body.dark-mode .widget {
    background: rgba(20, 20, 20, 0.25);
    border-color: rgba(255, 255, 255, 0.1);
    color: var(--text-night);
}

/* 新的组件尺寸系统 */
.widget-size-2x2 { grid-column: span 2; grid-row: span 2; }
.widget-size-4x2 { grid-column: span 4; grid-row: span 2; }
/* 1x1 是默认，无需特殊样式 */

/* 设置界面专属 */
#fpw-lockscreen-settings .settings-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 8px;
    height: 100%;
    padding: 10px;
    background: rgba(128,128,128,0.05);
    border-radius: 12px;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.1);
}
#fpw-lockscreen-settings .settings-grid-cell {
    border: 1px dashed rgba(128,128,128,0.3);
    border-radius: 12px;
    transition: all 0.2s ease;
    display: flex; /* 用于定位内部元素 */
    position: relative;
    background-size: cover;
    background-position: center;
}
#fpw-lockscreen-settings .settings-grid-cell.drag-over {
    border-style: solid;
    border-color: var(--hold-border);
    background-color: rgba(91, 153, 226, 0.1);
    transform: scale(1.05);
}
#fpw-lockscreen-settings .widget-placeholder {
    position: absolute; /* 绝对定位，覆盖在格子之上 */
    border: 1px solid var(--hold-border);
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    padding: 5px;
    color: inherit;
    pointer-events: none; /* 自身不响应鼠标事件 */
}
#fpw-lockscreen-settings .widget-placeholder-delete {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 20px;
    height: 20px;
    background-color: #f56565;
    color: white;
    border: 1px solid white;
    border-radius: 50%;
    font-size: 14px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    cursor: pointer;
    z-index: 10;
    pointer-events: all; /* 删除按钮需要响应鼠标事件 */
    transition: transform 0.2s;
}
#fpw-lockscreen-settings .widget-placeholder-delete:hover {
    transform: scale(1.1);
}

/* 组件添加区 */
.component-palette {
    padding: 15px 10px;
    border-top: 1px solid rgba(128,128,128,0.2);
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.component-palette-title {
    font-size: 14px;
    font-weight: 600;
    color: #889;
    text-align: center;
}
.component-palette-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
}
.palette-item {
    padding: 10px;
    border: 1px dashed rgba(128,128,128,0.4);
    border-radius: 10px;
    text-align: center;
    cursor: grab;
    transition: all 0.2s ease;
    font-size: 13px;
    background: rgba(128,128,128,0.05);
}
.palette-item:hover {
    border-color: var(--hold-border);
    background: rgba(91, 153, 226, 0.1);
}
.palette-item:active {
    cursor: grabbing;
    transform: scale(0.95);
}

/* 拖拽虚影 */
.widget-ghost {
    position: fixed;
    z-index: 9999;
    pointer-events: none;
    opacity: 0.75;
    transition: opacity 0.2s, transform 0.2s;
    background: var(--bg-day-element);
    border: 2px solid var(--hold-border);
    backdrop-filter: blur(8px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    border-radius: 16px; /* 匹配真实组件 */
}
body.dark-mode .widget-ghost {
    background: var(--bg-night-element);
}


/* 组件选择弹窗 (上下文菜单) */
.component-selection-popup {
    position: fixed; /* 使用 fixed 定位，确保在最上层 */
    z-index: 9999;
    background: var(--bg-day-element);
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    opacity: 0;
    transform: scale(0.95);
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none;
}
.component-selection-popup.show {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}
body.dark-mode .component-selection-popup {
    background: var(--bg-night-element);
}
body.theme-glass .component-selection-popup {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}
body.theme-glass.dark-mode .component-selection-popup {
    background: rgba(30, 30, 30, 0.4);
    border-color: rgba(255, 255, 255, 0.15);
}
.component-popup-title {
    font-size: 13px;
    font-weight: 600;
    text-align: center;
    padding: 4px 8px;
    color: #889;
    border-bottom: 1px solid rgba(128,128,128,0.2);
    margin-bottom: 4px;
}
.component-popup-button {
    width: 100%;
    padding: 10px 20px;
    border: none;
    background: transparent;
    border-radius: 8px;
    text-align: left;
    font-size: 15px;
    font-weight: 500;
    color: inherit;
    cursor: pointer;
    transition: background-color 0.2s;
}
.component-popup-button:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .component-popup-button:hover {
    background-color: rgba(255,255,255,0.08);
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] V2 组件功能实现样式 ================== */
/* =============================================================== */

/* HTML 组件内的 iframe 样式 */
.widget-html-iframe {
    width: 100%;
    height: 100%;
    border: none;
    border-radius: 10px; /* 继承父元素圆角 */
    background-color: transparent;
}

/* 快捷方式组件 (小组件) */
.widget-shortcut {
    width: 100%;
    height: 100%;
    border-radius: 50%; /* 关键：圆形按钮 */
    font-size: 11px;
    padding: 4px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}
.widget-shortcut:hover {
    transform: scale(1.05);
}
.widget-shortcut:active {
    transform: scale(0.95);
    box-shadow: inset 2px 2px 4px rgba(0,0,0,0.15), inset -2px -2px 4px rgba(255,255,255,0.7);
}
body.dark-mode .widget-shortcut:active {
    box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -2px -2px 4px rgba(255,255,255,0.1);
}

/* --- 备忘录小组件样式 --- */
.widget-memo {
    /* [V2 修复] 改为 Flex 布局以精确控制子元素 */
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: flex-start;
    padding: 12px;
    text-align: left;
    color: var(--widget-text-color);
    background-color: var(--widget-background-color);
}

.widget-memo .widget-memo-title {
    /* [V2 修复] 确保标题不会被压缩 */
    flex-shrink: 0; 
    font-weight: 700;
    font-size: 1em;
    margin-bottom: 6px; /* 稍微增加与内容的间距 */
    width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.widget-memo .widget-memo-content {
    /* [V2 修复] 让内容区域填满剩余空间并应用截断 */
    flex-grow: 1; 
    min-height: 0; /* 允许 flex item 收缩 */
    font-weight: 400; /* [优化] 调整字重以提高可读性 */
    font-size: 0.9em;
    opacity: 0.85;
    width: 100%;
    line-height: 1.5;
    
    /* 核心截断逻辑 */
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    /* line-clamp 将由 JS 动态设置 */
}



/* 图片组件样式 */
.widget-image {
    padding: 0; /* 图片组件不需要内边距 */
    overflow: hidden; /* 确保图片不溢出圆角 */
}
.widget-image img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 关键：自动裁剪并填充 */
}

/* 组件设置窗口内，已有组件的样式 */
.settings-widget-item {
    position: absolute;
    border: 1px dashed var(--hold-border);
    transition: all 0.2s ease;
}
.settings-widget-item:hover {
    background: rgba(91, 153, 226, 0.1);
}
.settings-widget-delete-btn {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 20px;
    height: 20px;
    background-color: #f56565;
    color: white;
    border: 1px solid white;
    border-radius: 50%;
    font-size: 14px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    cursor: pointer;
    z-index: 10;
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.2s ease;
}
.settings-widget-item:hover .settings-widget-delete-btn {
    opacity: 1;
    transform: scale(1);
}

/* 通用选择器浮动窗口样式 */
.picker-window-container {
    position: fixed;
    z-index: 2025; /* 比设置窗口高一级 */
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

.picker-list {
    max-height: 300px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.picker-item {
    padding: 12px 15px;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    background-color: rgba(0,0,0,0.02);
}
.picker-item:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .picker-item:hover {
    background-color: rgba(255,255,255,0.08);
}
/* 图片选择器网格 */
.picker-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    max-height: 300px;
    overflow-y: auto;
}
.picker-grid-item {
    aspect-ratio: 1 / 1;
    border-radius: 8px;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.2s;
}
.picker-grid-item:hover {
    transform: scale(1.05);
}
.picker-grid-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
/* HTML 编辑器 */
.html-editor-textarea {
    width: 100%;
    min-height: 150px;
    resize: vertical;
}

/* =============================================================== */
/* ============= [新增] V3 备忘录悬浮窗样式 ================= */
/* =============================================================== */
.memo-popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(5px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3000;
    opacity: 0;
    transition: opacity .3s ease;
}
.memo-popup-overlay.show {
    opacity: 1;
}
.memo-popup-content {
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    background: var(--bg-day-element);
    color: var(--text-day);
    border-radius: 16px;
    box-shadow: 12px 12px 24px var(--shadow-dark-day), -12px -12px 24px var(--shadow-light-day);
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    transform: scale(0.95);
    transition: transform .3s ease;
}
.memo-popup-overlay.show .memo-popup-content {
    transform: scale(1);
}
body.dark-mode .memo-popup-content {
    background: var(--bg-night-element);
    color: var(--text-night);
    box-shadow: 12px 12px 24px var(--shadow-dark-night), -12px -12px 24px var(--shadow-light-night);
}
.memo-popup-title {
    font-size: 22px;
    font-weight: 700;
    border-bottom: 1px solid rgba(128,128,128,0.2);
    padding-bottom: 10px;
}
.memo-popup-body {
    font-size: 16px;
    line-height: 1.7;
    white-space: pre-wrap; /* 保留换行和空格 */
    overflow-y: auto;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 锁屏设置 V3 交互样式 ================ */
/* =============================================================== */
/* 整体添加器布局 */
.component-adder {
    padding: 15px 10px;
    border-top: 1px solid rgba(128,128,128,0.2);
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.component-adder label {
    font-size: 14px;
    font-weight: 600;
    color: #889;
    padding-left: 5px;
}

/* 尺寸选择器 */
.size-selector {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    padding: 10px;
    border-radius: 12px;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}
body.dark-mode .size-selector {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}
.roller-container {
    display: flex;
    align-items: center;
    gap: 10px;
}
.roller-btn {
    width: 32px;
    height: 32px;
    border: none;
    border-radius: 50%;
    background: var(--bg-day-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-day),-4px -4px 8px var(--shadow-light-day);
    color: var(--text-day);
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
}
body.dark-mode .roller-btn {
    background: var(--bg-night-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night);
    color: var(--text-night);
}
.roller-btn:active {
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}
body.dark-mode .roller-btn:active {
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}
.roller-display {
    font-size: 24px;
    font-weight: 700;
    min-width: 25px;
    text-align: center;
}
.size-selector > span {
    font-size: 20px;
    font-weight: 500;
    color: #aaa;
}

/* 类型选择器&确认按钮 */
.type-selector {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
#confirm-widget-btn {
    margin-top: 5px;
}

/* 新组件预览区 */
#new-widget-preview-area {
    min-height: 60px;
    border: 2px dashed rgba(128,128,128,0.3);
    border-radius: 12px;
    padding: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: border-color 0.3s;
}
#new-widget-preview-area.has-widget {
    border-style: solid;
    border-color: transparent;
}
.widget-preview-item {
    padding: 10px; /* 统一内边距 */
    border-radius: 16px; /* 增加圆角弧度，使其更像组件本身 */
    text-align: center;
    cursor: grab;
    font-size: 14px;
    font-weight: 600;
    background: var(--bg-day-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day);
    transition: all 0.2s ease;
    /* 核心修改：让其成为 flex 子项以便居中和控制尺寸 */
    display: flex;
    align-items: center;
    justify-content: center;
    /* 核心修改：设定固定的正方形尺寸 */
    width: 80px;
    height: 80px;
    flex-shrink: 0; /* 防止被 flex 容器压缩 */
    word-break: break-word; /* 防止文字溢出 */
}

body.dark-mode .widget-preview-item {
    background: var(--bg-night-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night);
}
.widget-preview-item:active {
    cursor: grabbing;
    transform: scale(0.95);
}

/* [新增] 胶囊形状样式 */
.widget.widget-shape-capsule {
    border-radius: 9999px;
}

/* [修复] 补充缺失的圆形样式 */
.widget.widget-shape-circle {
    border-radius: 50%;
}

/* 针对快捷方式组件的额外圆形样式优化 */
.widget-shortcut.widget-shape-square {
    border-radius: 16px; /* 让方形快捷按钮也保持统一的方正圆弧 */
}
/* [新增] 预览项形状样式 */
.widget-preview-item.shape-circle {
    border-radius: 50%;
    /* 强制预览块为正方形，以显示完美的圆形 */
    width: 80px; 
    height: 80px;
    padding: 10px; /* 调整内边距以适应大小 */
    flex-shrink: 0; /* 防止被压缩 */
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 锁屏设置 V4 模拟器样式 ================ */
/* =============================================================== */
/* [V8 修正] 模拟手机屏幕容器 */
.simulated-phone-screen {
    flex-shrink: 0;
    height: 40vh; /* 稍微增加高度 */
    max-height: 300px;
    width: auto;
    margin: 0 auto 15px auto;
    aspect-ratio: 9 / 18; /* 调整宽高比使其更宽 */
    background: rgba(0,0,0,0.1);
    border-radius: 18px; /* 轻微减小圆角以匹配更窄的边框 */
    border: 3px solid #333; /* [核心修改] 边框变窄 */
    box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
    padding: 8px; /* 减小内边距 */
    display: flex;
}
body.dark-mode .simulated-phone-screen {
    border-color: #555;
    background: rgba(255,255,255,0.05);
}
/* [V7 修正] 调整设置网格以适应新容器 (叠加策略) */
#lockscreen-settings-modal .settings-grid {
    position: relative; /* 关键：为绝对定位的子元素提供定位上下文 */
    padding: 0;
    box-shadow: none;
    background: transparent;
    width: 100%;
    height: 100%;
    /* 网格定义保持不变 */
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(8, 1fr);
}

/* [V7 修正] 重新定义 widget-placeholder (叠加策略) */
#lockscreen-settings-modal .widget-placeholder {
    /* `grid-area` 属性将由 JS 动态设置 */
    z-index: 5; /* 确保在虚线格子之上 */
    padding: 4px;
    font-size: 8px;
    overflow: hidden;
    text-align: center;
    word-break: break-all;
    background-size: cover;
    background-position: center;
    display: flex; /* 修正：确保内容居中和备忘录布局 */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    line-height: 1.3;
    position: relative; /* 为删除按钮提供定位上下文 */
    /* 已有样式继承自全局 .widget-placeholder */
    position: absolute; /* 绝对定位，覆盖在格子之上 */
    border: 1px solid var(--hold-border);
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    border-radius: 8px; /* [核心修改] 将组件预览也改成直角风格 */
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    color: inherit;
    pointer-events: none; /* 自身不响应鼠标事件 */
}
/* 迷你备忘录预览样式 */
.settings-widget-preview-memo-title {
    font-weight: bold;
    font-size: 9px;
    width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 2px;
}
.settings-widget-preview-memo-content {
    font-size: 7px;
    opacity: 0.8;
    display: -webkit-box;
    -webkit-line-clamp: 3; /* 限制显示行数 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
#lockscreen-settings-modal .widget-size-4x2 .settings-widget-preview-memo-content {
    -webkit-line-clamp: 5; /* 大尺寸显示更多行 */
}

/* 调整弹窗高度以适应模拟器 */
#lockscreen-settings-modal .modal-content {
    height: 85vh !important;
}

/* ========================================================================= */
/* ============== [V5 新增] 锁屏组件添加器紧凑布局样式 =============== */
/* ========================================================================= */
.adder-controls-row {
    display: flex;
    flex-wrap: nowrap; /* 强制不换行 */
    gap: 12px;
    align-items: flex-end; /* 底部对齐，使整体更整洁 */
}

.adder-control-group {
    display: flex;
    flex-direction: column;
    gap: 6px; /* 减小标签和控件之间的间距 */
}

.adder-control-group label {
    font-size: 13px; /* 缩小标签字体 */
    font-weight: 500;
    color: #889;
    padding-left: 2px;
}

/* 精确调整尺寸选择器内部 */
.adder-controls-row .size-selector {
    padding: 6px 8px; /* 减小内边距 */
    gap: 8px;
}
.adder-controls-row .roller-container {
    gap: 6px;
}
.adder-controls-row .roller-btn {
    width: 26px; /* 缩小按钮 */
    height: 26px;
    font-size: 18px; /* 减小按钮内字体 */
}
.adder-controls-row .roller-display {
    font-size: 20px; /* 减小数字字体 */
    min-width: 20px;
}
.adder-controls-row .size-selector > span {
    font-size: 16px;
}

/* 精确调整类型选择器（下拉框） */
.adder-controls-row .modal-select {
    padding: 6px 10px; /* 减小内边距以匹配高度 */
    font-size: 14px;
    height: 40px; /* 固定高度以对齐 */
    flex-grow: 1; /* 让其填充剩余空间 */
    min-width: 110px; /* 设置最小宽度防止被过度压缩 */
}
/* ========================================================================= */
/* ============================== [新增结束] =============================== */
/* ========================================================================= */

/* =============================================================== */
/* ============= [V6 新增] 模拟器网格与拖拽交互样式 ============ */
/* =============================================================== */
/* 调整设置网格容器，增加格子间距 */
#lockscreen-settings-modal .settings-grid {
    gap: 4px; /* 轻微减小间距以适应更宽的屏幕 */
}

/* [V8 修正] 可视化的虚线网格单元 (井字形) */
.settings-grid-cell {
    border: 1px dashed rgba(128,128,128,0.3);
    border-radius: 0; /* [核心修改] 去掉圆角，变为直角 */
    transition: all 0.2s ease;
    display: flex; 
    position: relative;
    background-size: cover;
    background-position: center;
}

/* 当拖拽物悬停在有效格子上时的样式 */
.settings-grid-cell.drag-over {
    border-style: solid;
    border-color: var(--hold-border);
    background-color: rgba(91, 153, 226, 0.1);
    transform: scale(1.02); /* 轻微缩放 */
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [V5 新增] 模拟器删除按钮优化样式 ============ */
/* =============================================================== */
/* 组件容器，用于定位和 hover 效果 */
.widget-container-wrapper {
    position: relative;
    /* grid-area 将由 JS 设置 */
}

/* 删除按钮的包裹层，用于居中和捕获点击 */
.widget-delete-wrapper {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.3);
    opacity: 0;
    pointer-events: none; /* 默认不可见不可点 */
    transition: opacity 0.2s ease;
}

/* 仅当包裹层被 hover 时，显示删除按钮 */
.widget-container-wrapper:hover .widget-delete-wrapper {
    opacity: 1;
    pointer-events: auto; /* hover 时可点击 */
}

/* 居中且更大的删除按钮本体 */
.widget-delete-btn-centered {
    width: 28px;
    height: 28px;
    background-color: rgba(245, 101, 101, 0.8);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    font-size: 20px;
    font-weight: bold;
    line-height: 26px; /* 垂直居中叉号 */
    text-align: center;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: transform 0.2s, background-color 0.2s;
}

.widget-delete-btn-centered:hover {
    transform: scale(1.1);
    background-color: #f56565;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [V7 新增] 居中加载指示器样式 ============= */
/* =============================================================== */
.loading-indicator-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999; /* 确保在最顶层 */
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
}

.loading-indicator-overlay.show {
    opacity: 1;
}

.loading-indicator-box {
    background-color: var(--content-bg);
    padding: 25px 40px;
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    text-align: center;
    transform: scale(0.95);
    transition: transform 0.2s ease-in-out;
}

.loading-indicator-overlay.show .loading-indicator-box {
    transform: scale(1);
}

.loading-indicator-text {
    font-size: 16px;
    color: var(--text-color);
    margin-bottom: 20px;
}

.loading-indicator-cancel-btn {
    background-color: #e53e3e;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.loading-indicator-cancel-btn:hover {
    background-color: #c53030;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* [新增] 锁屏HTML组件容器精准约束样式 */
.html-widget-container {
    position: relative; /* 为绝对定位的子元素创建定位上下文 */
}

.html-widget-container > .widget {
    position: absolute; /* 将widget脱离文档流，使其不再影响父容器的高度计算 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
/* =============================================================== */
/* ============= [新增] 锁屏组件背景选择器样式 ============= */
/* =============================================================== */
.widget-bg-picker-popup {
    position: absolute; /* 相对于父级容器定位 */
    z-index: 1; /* 确保在同一个容器内，但在其他内容之上 */
    background: var(--bg-day-element);
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
    padding: 10px;
    display: flex;
    align-items: center;
    gap: 8px;
    opacity: 0;
    transform: translateY(10px) scale(0.95);
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none;
    width: 220px; /* 固定宽度，保持紧凑 */
    margin-top: 8px; /* 与上方面板的间距 */
}
.widget-bg-picker-popup.show {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
}
body.dark-mode .widget-bg-picker-popup {
    background: var(--bg-night-element);
}
body.theme-glass .widget-bg-picker-popup {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}
body.theme-glass.dark-mode .widget-bg-picker-popup {
    background: rgba(30, 30, 30, 0.4);
    border-color: rgba(255, 255, 255, 0.15);
}

.widget-bg-picker-popup input[type="color"] {
    -webkit-appearance: none;
    width: 32px;
    height: 32px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background-color: transparent; /* 移除默认背景，让伪元素生效 */
    padding: 0;
    flex-shrink: 0;
}

.widget-bg-picker-popup input[type="color"]::-webkit-color-swatch {
    border-radius: 6px;
    border: 1px solid rgba(128,128,128,0.2);
}

.widget-bg-picker-popup .bg-picker-button {
    flex-grow: 1;
    padding: 8px;
    border: none;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 500;
    color: inherit;
    cursor: pointer;
    background-color: rgba(0,0,0,0.05);
    transition: background-color 0.2s;
}

.widget-bg-picker-popup .bg-picker-button:hover {
    background-color: rgba(0,0,0,0.1);
}
body.dark-mode .widget-bg-picker-popup .bg-picker-button {
    background-color: rgba(255,255,255,0.08);
}
body.dark-mode .widget-bg-picker-popup .bg-picker-button:hover {
    background-color: rgba(255,255,255,0.15);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* =================== [V2 BUG修复] 弹窗层级修正 =================== */
/* =============================================================== */
#jelly-css-help-modal.modal-overlay {
    z-index: 1003; /* 确保高于悬浮球设置弹窗(1002) */
}
/* =============================================================== */
/* ========================= [修复结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ============= [新增] 备忘录编辑器 v2.0 样式 ============= */
/* =============================================================== */
#memoryModal #note-editor-view {
    padding-bottom: 0; /* 为工具栏留出空间 */
}
#memoryModal .editor-content {
    padding-bottom: 10px;
}
#memoryModal #note-content-editor {
    /* [修改] 移除 flex-grow，让其高度由内容决定，由父容器 .editor-content 滚动 */
    resize: none;
    line-height: 1.7;
    font-size: 16px;
    padding: 10px;
    -webkit-user-select: text; /* 允许在iOS上选择文本 */
    user-select: text;
    /* [修改] 移除此处的滚动，交由父容器处理 */
}


#memoryModal #note-content-editor:focus {
    outline: none;
}
#memoryModal #note-content-editor ul {
    list-style: none;
    padding-left: 0;
}
/* 通用待办清单样式 (编辑器 & 小组件) */
#memoryModal #note-content-editor li,
.widget-memo .widget-memo-content li {
    display: flex;
    align-items: flex-start;
    margin-bottom: 8px;
}
#memoryModal #note-content-editor li::before,
.widget-memo .widget-memo-content li::before {
    content: '○';
    font-size: 1.2em;
    margin-right: 10px;
    cursor: pointer;
    color: #889;
    font-weight: bold;
    display: inline-block;
    line-height: 1.5;
}
#memoryModal #note-content-editor li.completed::before,
.widget-memo .widget-memo-content li.completed::before {
    content: '●';
    color: var(--hold-border);
}
#memoryModal #note-content-editor li.completed .todo-text,
.widget-memo .widget-memo-content li.completed .todo-text {
    text-decoration: line-through;
    opacity: 0.6;
}
/* [V3 修复] 允许待办事项的文本内容换行 */
.todo-text {
    flex: 1; /* 让文本容器占据所有剩余空间 */
    min-width: 0; /* 关键：允许 flex item 收缩并换行其内容 */
    word-break: break-word; /* 确保长单词或URL也能正确换行 */
}


.memo-toolbar {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 10px 25px; /* 优化：增加左右内边距，让工具按钮与边缘保持距离 */
    background: var(--bg-day-element);
    box-shadow: 0 -4px 12px rgba(0,0,0,0.05);
    border-top: 1px solid rgba(0,0,0,0.08);

    /* --- 核心修改 --- */
    width: calc(100% + 20px); /* 让宽度等于父容器宽度 + 两侧各10px的内边距 */
    margin: 0 -10px -10px -10px; /* 上右下左外边距，抵消父容器所有方向的内边距 */
    border-radius: 0 0 16px 16px; /* 美化：让工具栏的下圆角匹配弹窗的圆角 */
    box-sizing: border-box; /* 确保 padding 包含在 width 计算内 */
}

body.dark-mode .memo-toolbar {
    background: var(--bg-night-element);
    box-shadow: 0 -4px 12px rgba(0,0,0,0.2);
    border-color: rgba(255,255,255,0.1);
}
.toolbar-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 20px;
    font-weight: bold;
    color: inherit;
    opacity: 0.7;
    transition: opacity 0.2s, transform 0.2s;
    padding: 5px;
}
.toolbar-btn:hover {
    opacity: 1;
}
.toolbar-btn:active {
    transform: scale(0.9);
}
.toolbar-btn.strikethrough {
    text-decoration: line-through;
}
.toolbar-separator {
    width: 1px;
    height: 20px;
    background-color: rgba(128,128,128,0.3);
}
.toolbar-btn-code-copy {
    margin-left: auto; /* 靠右对齐 */
    font-size: 16px;
    font-weight: normal;
    background-color: rgba(128,128,128,0.1);
    padding: 4px 10px;
    border-radius: 6px;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备忘录代码块 v1.0 样式 ================ */
/* =============================================================== */
.memo-code-block {
    position: relative;
    background-color: rgba(128,128,128,0.1);
    border: 1px solid rgba(128,128,128,0.15);
    border-radius: 8px;
    padding: 12px 15px;
    margin: 10px 0;
    font-family: monospace;
    white-space: pre-wrap;
    word-break: break-all;
    font-size: 0.9em;
}
.code-block-copy-btn {
    position: absolute;
    top: 6px;
    right: 6px;
    background: rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.15);
    color: inherit;
    padding: 2px 6px;
    border-radius: 5px;
    font-size: 12px;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s, background-color 0.2s;
}
.memo-code-block:hover .code-block-copy-btn {
    opacity: 1;
}
.code-block-copy-btn:hover {
    background-color: rgba(0,0,0,0.2);
}
body.dark-mode .memo-code-block {
    background-color: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.1);
}
body.dark-mode .code-block-copy-btn {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.2);
}
body.dark-mode .code-block-copy-btn:hover {
    background-color: rgba(255,255,255,0.2);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备忘录工具栏激活状态 ================ */
/* =============================================================== */
.toolbar-btn.active {
    font-weight: 900; /* 使用更粗的字重表示激活 */
    opacity: 1;
    transform: scale(1.1);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 悬浮球设置预览区样式 ================= */
/* =============================================================== */
#jelly-css-preview-container {
    flex-shrink: 0;
    width: 80px;
    height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-day-element);
    border-radius: 12px;
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
    position: relative;
    overflow: hidden; /* 隐藏超出边界的辉光效果 */
    transform-style: preserve-3d; /* 提升渲染层级 */
}
body.dark-mode #jelly-css-preview-container {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}

/* 关键：重置预览球的位置，使其在容器内居中 */
#jelly-css-preview-container .jelly-ball-wrapper {
    position: relative;
    transform: scale(0.9); /* 稍微缩小以适应容器 */
    pointer-events: none; /* 确保预览球不可交互 */
}

/* [V2 BUG修复] 确保在主题设置弹窗关闭后，帮助弹窗依然可见 */
#jelly-css-help-modal.modal-overlay {
    z-index: 1003;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备忘录工具栏磨砂玻璃主题适配 ============= */
/* =============================================================== */

/* 日间模式下的磨砂玻璃工具栏 */
body.theme-glass .memo-toolbar {
    background: rgba(255, 255, 255, 0.15); /* 半透明背景 */
    backdrop-filter: blur(10px);          /* 核心：应用模糊效果 */
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid rgba(255, 255, 255, 0.25); /* 半透明亮色边框 */
    box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);    /* 更柔和的顶部阴影 */
    /* 关键：让工具栏的圆角匹配父容器的底部圆角 */
    border-radius: 0 0 16px 16px;
}

/* 夜间模式下的磨砂玻璃工具栏 */
body.theme-glass.dark-mode .memo-toolbar {
    background: rgba(20, 20, 20, 0.3); /* 更深的半透明背景 */
    border-top-color: rgba(255, 255, 255, 0.15); /* 夜间模式的半透明亮色边框 */
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);     /* 夜间模式下更深的阴影 */
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ================= [新增] 手机收藏馆专属样式 ================== */
/* =============================================================== */

/* 新增：泡泡漂浮动画 (保持不变) */
@keyframes float-bubble {
    0% { transform: translateY(0px) scale(1); }
    50% { transform: translateY(-8px) scale(1.02); }
    100% { transform: translateY(0px) scale(1); }
}

#phoneCollectionModal .modal-content {
    max-width: 800px;
    height: calc(100vh - 40px);
    padding: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}
#phoneCollectionModal .page-content {
    flex-grow: 1; 
    display: grid; /* [核心修改] 使用 Grid 布局替代 Flex */
    grid-template-rows: auto 1fr; /* [核心修改] 定义一个高度自适应的头部行，和一个占满剩余空间的滚动内容行 */
    min-height: 0; 
    overflow: hidden; /* 保持不变，确保整个页面内容不溢出 */
}

#phoneCollectionModal .page-header-container {
    flex-shrink: 0; 
}

#phoneCollectionModal .list-container {
    /* 垂直内边距保持，水平内边距交由布局自动处理 */
    padding: 35px 0;
    display: flex; /* ★ 核心修改：使用 Flexbox 布局 */
    flex-wrap: wrap; /* ★ 核心修改：允许泡泡换行 */
    justify-content: space-evenly; /* ★ 核心修改：实现所有水平间距（包括两端）相等 */
    row-gap: 40px; /* ★ 核心修改：设置一个充足的行间距，以适应泡泡的错落效果 */
    align-content: flex-start;
    overflow-y: auto;
    min-height: 0;
}

/* 核心修改：将分区项目改为圆形泡泡 */
.phone-partition-item {
    width: 100px; 
    height: 100px; 
    flex-shrink: 0; 
    position: relative;
    padding: 8px;
    border-radius: 50%; /* 关键：变为圆形 */
    box-shadow: 6px 6px 12px var(--shadow-dark-day), -6px -6px 12px var(--shadow-light-day);
    background: var(--bg-day-element);
    color: var(--text-day);
    cursor: pointer;
    transition: box-shadow 0.3s ease, transform 0.2s ease; /* 重加 transform 过渡，用于点击反馈 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    gap: 0;
    user-select: none; 
    -webkit-tap-highlight-color: transparent;

    animation: float-bubble 6s ease-in-out infinite;
}

/* ★ 新增：错落有致的布局效果 ★ */
.phone-partition-item:nth-child(odd) {
    transform: translateY(-20px); /* 奇数泡泡向上移动 */
}
.phone-partition-item:nth-child(even) {
    transform: translateY(20px); /* 偶数泡泡向下移动 */
}


.phone-partition-item:active {
    box-shadow: inset 3px 3px 6px var(--shadow-dark-day), inset -3px -3px 6px var(--shadow-light-day);
    animation-play-state: paused; 
    transform: scale(0.97) !important; /* 强制应用缩小效果，同时覆盖错落位移 */
}
body.dark-mode .phone-partition-item {
    box-shadow: 6px 6px 12px var(--shadow-dark-night), -6px -6px 12px var(--shadow-light-night);
    background: var(--bg-night-element);
    color: var(--text-night);
}
body.dark-mode .phone-partition-item:active {
    box-shadow: inset 3px 3px 6px var(--shadow-dark-night), inset -3px -3px 6px var(--shadow-light-night);
}
.phone-partition-icon {
    display: none;
}
.phone-partition-name {
    font-size: 0.9rem;
    font-weight: 600;
    line-height: 1.4;
    padding: 0 5px; 
}

/* ★ 新增：修复磨砂玻璃主题下的圆角问题 ★ */
body.theme-glass .phone-partition-item {
    border-radius: 50%;
}


/* ----- 以下为详情页样式，保持不变 ----- */
#phone-detail-content {
    gap: 18px;
    padding-bottom: 30px;
}
.detail-info-group {
    padding: 15px;
    border-radius: 12px;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}
body.dark-mode .detail-info-group {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}
.detail-info-group label {
    font-size: 14px;
    font-weight: 600;
    color: #889;
    display: block;
    margin-bottom: 8px;
}
.detail-info-value {
    font-size: 16px;
    word-wrap: break-word;
}
.detail-info-value.copyable {
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background 0.2s;
    padding: 5px 8px;
    margin: -5px -8px; 
    border-radius: 8px;
}
.detail-info-value.copyable:hover {
    background: rgba(0,0,0,0.05);
}
body.dark-mode .detail-info-value.copyable:hover {
    background: rgba(255,255,255,0.08);
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ================= [新增] 手机收藏馆按钮样式 ================= */
/* =============================================================== */
#showNoticeBell {
    display: none; /* 保持默认隐藏，由 JS 控制显示 */
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 16px; /* 缩小字体 */
    font-weight: bold;
    color: #b0b0b0; /* 使用更柔和的灰色 */
    padding: 0 5px; /* 调整内边距 */
    line-height: 1;
    vertical-align: middle; /* 确保与标题垂直对齐 */
    transition: color 0.2s ease;
}
#showNoticeBell:hover {
    color: var(--hold-border); /* 悬停时使用主题高亮色 */
}
body.dark-mode #showNoticeBell {
    color: #666; /* 夜间模式下更暗的灰色 */
}
/* =============================================================== */
/* =============== [新增] 手机收藏馆移动端适配 =============== */
/* =============================================================== */
@media (max-width: 600px) {
    #phoneCollectionModal .list-container {
        padding: 25px 15px; /* 减小左右内边距 */
        gap: 15px; /* 减小泡泡间距 */
    }
    .phone-partition-item {
        width: 85px; /* 减小泡泡尺寸 */
        height: 85px;
    }
    .phone-partition-item .phone-partition-name {
        font-size: 0.8rem; /* 略微减小字体 */
    }
    /* 减小错落效果的幅度 */
    .phone-partition-item:nth-child(odd) {
        transform: translateY(-15px);
    }
    .phone-partition-item:nth-child(even) {
        transform: translateY(15px);
    }
}

/* =============================================================== */
/* ================== [新增] Giscus 主题适配样式 ================= */
/* =============================================================== */

/* 1. 将评论区模态框强制设为全屏 */
#phoneCommentsModal .modal-content {
    width: 100%;
    height: 100%;
    max-width: none;
    max-height: none;
    border-radius: 0;
    border: none;
}

/* 2. 确保 Giscus 的容器正确填充 */
#phoneCommentsModal .modal-body {
    padding: 0;
    flex-grow: 1;
    display: flex;
}

/* 3. ★★★ 终极修复：为 Giscus 组件本身重置外边距和宽度 ★★★ */
#phoneCommentsModal .giscus {
    width: 100% !important;     /* 覆盖通用规则的 calc(100% - 6px) */
    height: 100%;
    margin-left: 0 !important;  /* 覆盖通用规则的 margin-left: 3px */
    margin-right: 0 !important; /* 覆盖通用规则的 margin-right: 3px */
}

/* 4. 保留背景透明适配 */
.giscus-frame {
    background-color: transparent !important;
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备忘录代码块 v1.0 样式 ================ */
/* =============================================================== */
.memo-code-block {
    position: relative;
    background-color: rgba(128,128,128,0.1);
    border: 1px solid rgba(128,128,128,0.15);
    border-radius: 8px;
    padding: 12px 15px;
    margin: 10px 0;
    font-family: monospace;
    font-size: 0.9em;
    /* [修改] 移除 white-space 和 word-break，交由 pre 标签处理 */
}

/* [新增] 针对 pre 标签的样式，实现自动换行 */
.memo-code-block pre {
    margin: 0; /* 移除 pre 标签的默认外边距 */
    white-space: pre-wrap; /* 保留空白符序列，但正常地进行换行 */
    word-break: break-all; /* 允许在长单词或 URL 内部中断换行，防止溢出 */
}

.code-block-copy-btn {
    position: absolute;
    top: 6px;
    right: 6px;
    background: rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.15);
    color: inherit;
    padding: 2px 6px;
    border-radius: 5px;
    font-size: 12px;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s, background-color 0.2s;
}
.memo-code-block:hover .code-block-copy-btn {
    opacity: 1;
}
.code-block-copy-btn:hover {
    background-color: rgba(0,0,0,0.2);
}
body.dark-mode .memo-code-block {
    background-color: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.1);
}
body.dark-mode .code-block-copy-btn {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.2);
}
body.dark-mode .code-block-copy-btn:hover {
    background-color: rgba(255,255,255,0.2);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] Giscus 反馈数据展示样式 ============= */
/* =============================================================== */
.giscus-feedback-container {
    margin-top: 20px;
    padding: 12px 15px;
    border-radius: 12px;
    background: rgba(0,0,0,0.03);
    min-height: 48px; /* 给加载状态一个固定高度 */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #889;
    transition: background 0.3s;
}
body.dark-mode .giscus-feedback-container {
    background: rgba(255,255,255,0.04);
}
.giscus-feedback-container.loaded {
    justify-content: space-between; /* 加载成功后两端对齐 */
}
.giscus-reactions, .giscus-comments {
    display: flex;
    align-items: center;
    gap: 8px;
}
.reaction-item {
    display: flex;
    align-items: center;
    gap: 4px;
    background: var(--bg-day-element);
    padding: 3px 8px;
    border-radius: 10px;
    box-shadow: 2px 2px 4px var(--shadow-dark-day), -2px -2px 4px var(--shadow-light-day);
    font-size: 13px;
    font-weight: 500;
}
body.dark-mode .reaction-item {
    background: var(--bg-night-element);
    box-shadow: 2px 2px 4px var(--shadow-dark-night), -2px -2px 4px var(--shadow-light-night);
}
.giscus-comments a {
    text-decoration: none;
    color: var(--hold-border);
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 4px;
}
.giscus-comments a:hover {
    text-decoration: underline;
}
/* =============================================================== */
/* ============== [新增] 手机收藏馆筛选功能样式 =============== */
/* =============================================================== */
.filter-section { margin-bottom: 20px; border-bottom: 1px solid rgba(128, 128, 128, 0.1); padding-bottom: 15px; }
.filter-section:last-of-type { border-bottom: none; margin-bottom: 0px; }
.filter-group-title { font-size: 14px; font-weight: 600; color: rgb(136, 136, 153); margin-bottom: 12px; }
#selected-filters-container { padding: 10px; background: rgba(128, 128, 128, 0.05); border-radius: 10px; min-height: 40px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
.selected-filter-tag { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 16px; font-size: 13px; font-weight: 600; color: white; background-color: var(--hold-border); }
.selected-filter-tag .remove-tag-btn { font-family: sans-serif; font-weight: bold; font-size: 14px; cursor: pointer; line-height: 1; opacity: 0.7; transition: opacity 0.2s ease 0s; }
.selected-filter-tag .remove-tag-btn:hover { opacity: 1; }
.filter-options-grid { display: flex; flex-wrap: wrap; gap: 10px; }
.filter-tag-option { padding: 8px 16px; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; background: var(--bg-day-element); color: var(--text-day); box-shadow: var(--shadow-dark-day) 4px 4px 8px, var(--shadow-light-day) -4px -4px 8px; transition: all 0.2s ease 0s; }
body.dark-mode .filter-tag-option { background: var(--bg-night-element); color: var(--text-night); box-shadow: var(--shadow-dark-night) 4px 4px 8px, var(--shadow-light-night) -4px -4px 8px; }
.filter-tag-option:active { box-shadow: var(--shadow-dark-day) 4px 4px 8px inset, var(--shadow-light-day) -4px -4px 8px inset; }
body.dark-mode .filter-tag-option:active { box-shadow: var(--shadow-dark-night) 4px 4px 8px inset, var(--shadow-light-night) -4px -4px 8px inset; }
.filter-tag-option.selected { opacity: 0.5; pointer-events: none; }
.filter-tag-option[data-group="user"][data-value="owned"] { color: #d69e2e; font-weight: bold; }
.filter-tag-option[data-group="user"][data-value="wishlist"] { color: #C53030; font-weight: bold; }
.filter-tag-option[data-group="user"][data-value="not_owned"] { color: #718096; }


/* [新增] 相册自定义背景样式 */
#memoryModal .album-item.has-custom-bg {
    color: white; /* 强制文字颜色为白色以保证可见性 */
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px; /* 调整内边距，让文字居中 */
}

#memoryModal .album-item.has-custom-bg .folder-name {
    /* 为文字添加边缘阴影，增强在各种背景下的可读性 */
    text-shadow: 0px 0px 4px rgba(0, 0, 0, 0.8), 0px 0px 8px rgba(0, 0, 0, 0.6);
    font-size: 1.1em;
    text-align: center;
}

/* 当有自定义背景时，隐藏图标，并重置信息样式 */
#memoryModal .album-item.has-custom-bg .folder-icon,
#memoryModal .album-item.has-custom-bg .manage-checkbox {
    display: none;
}

#memoryModal .album-item.has-custom-bg .album-info {
    position: absolute;
    bottom: 8px;
    left: 12px;
    font-size: 12px;
    font-weight: bold;
    color: white;
    text-shadow: 0 0 3px rgba(0, 0, 0, 0.7);
    background-color: rgba(0,0,0,0.2);
    padding: 2px 6px;
    border-radius: 4px;
}

/* ===== [新增] 相册排序拖拽把手样式 ===== */
.album-item .sort-handle {
    display: none; /* 默认隐藏 */
    position: absolute;
    top: 8px;
    right: 8px;
    font-size: 24px;   /* 增大图标尺寸 */
    font-weight: bold;
    color: #b0b0b0; /* 淡灰色 */
    cursor: grab;
    padding: 5px;
    z-index: 10;
    transition: color 0.2s, transform 0.2s;
    -webkit-user-select: none; /* 防止拖拽时选中文字 */
    user-select: none;
    line-height: 1; /* 确保垂直居中 */
}

body.dark-mode .album-item .sort-handle {
    color: #777; /* 夜间模式下稍亮的灰色 */
}

/* 管理模式下显示把手 */
.album-item.manage-mode .sort-handle {
    display: block;
}

.album-item .sort-handle:hover {
    color: var(--hold-border); /* 悬停时高亮 */
    transform: scale(1.1);
}

.album-item .sort-handle:active {
    cursor: grabbing;
}

/* =============================================================== */
/* =================== [新增] 功能优化专属样式 =================== */
/* =============================================================== */

/* 1. 更新公告标签的红点 */
.segmented-control label[for="help-tab-2"] {
    position: relative; /* 为红点的绝对定位提供基准 */
}
#update-log-indicator {
    display: none; /* 默认隐藏 */
    position: absolute;
    top: 6px;
    right: 8px;
    width: 8px;
    height: 8px;
    background-color: #e53e3e;
    border-radius: 50%;
    border: 1px solid white;
    box-shadow: 0 0 5px #e53e3e;
}
#update-log-indicator.show {
    display: block; /* 用于JS控制显示 */
}

/* 2. 美化新用户引导弹窗的内容 */
#welcome-modal-content p {
    line-height: 1.7;
    margin-bottom: 12px;
}
#welcome-modal-content ul {
    list-style: none;
    padding-left: 10px;
    margin-bottom: 15px;
}
#welcome-modal-content li {
    margin-bottom: 8px;
    color: #4a5568;
}
body.dark-mode #welcome-modal-content li {
    color: #a0aec0;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备份提醒设置弹窗专属样式 V3 ============ */
/* =============================================================== */
.time-input-row {
    display: flex;
    align-items: center;
    gap: 8px; /* 减小间距，让布局更紧凑 */
    margin-bottom: 10px; /* 每行之间增加一点垂直间距 */
}
.time-input-row .modal-input {
    flex-grow: 1; /* 核心：让输入框占据所有剩余空间 */
    flex-shrink: 1; /* 允许输入框在空间不足时收缩 */
    min-width: 100px; /* 保证输入框的最小可操作宽度 */
}
.time-action-btn {
    flex-shrink: 0; /* 核心：禁止按钮收缩 */
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 50%;
    background: var(--bg-day-element);
    box-shadow: 2px 2px 4px var(--shadow-dark-day),-2px -2px 4px var(--shadow-light-day);
    color: var(--text-day);
    font-size: 22px;
    font-weight: bold;
    cursor: pointer;
    transition: all .2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}
body.dark-mode .time-action-btn {
    background: var(--bg-night-element);
    box-shadow: 2px 2px 4px var(--shadow-dark-night),-2px -2px 4px var(--shadow-light-night);
    color: var(--text-night);
}
.time-action-btn:active {
    box-shadow: inset 2px 2px 4px var(--shadow-dark-day), inset -2px -2px 4px var(--shadow-light-day);
}
body.dark-mode .time-action-btn:active {
     box-shadow: inset 2px 2px 4px var(--shadow-dark-night), inset -2px -2px 4px var(--shadow-light-night);
}
.time-action-btn.add {
    color: var(--hold-border);
}
.time-action-btn.remove {
    color: #f56565;
}


#backupProjectList .project-checkbox-item {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    padding: 5px;
    border-radius: 6px;
    transition: background-color 0.2s;
}
#backupProjectList .project-checkbox-item:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode #backupProjectList .project-checkbox-item:hover {
    background-color: rgba(255,255,255,0.08);
}

#backupProjectList .project-checkbox-item input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
        /* ===== [修改] 相册照片下载按钮样式 V3 (最终版) ===== */
        #download-photo-btn {
            position: absolute;
            right: 15px; /* 向右移动 */
            bottom: 8px; /* 向下移动 */
            z-index: 20;
            background: transparent; /* 移除背景 */
            border: none;
            color: white;
            font-size: 17px; /* 稍微增大图标尺寸 */
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.7; /* 初始透明度 */
            display: none; /* 默认隐藏，由JS控制显示 */
            padding: 10px; /* 增加点击热区 */
            text-decoration: none;
            -webkit-tap-highlight-color: transparent;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5); /* 为图标增加轻微阴影，增强可读性 */
        }
        #download-photo-btn:hover {
            opacity: 1; /* 悬停时完全显示 */
            transform: scale(1.15); /* 悬停时放大效果更明显 */
        }
        /* ===== [修改结束] ===== */

/* =============================================================== */
/* =============== [新增] 手机收藏馆状态功能样式 =============== */
/* =============================================================== */

/* 状态按钮的弹出菜单容器 */
#phoneStatusMenu {
    position: absolute;
    top: 100%; /* 定位在状态按钮的正下方 */
    left: 50%;
    transform: translateX(-50%) translateY(10px) scale(0.9); /* 初始状态，轻微下移和缩小 */
    display: flex;
    gap: 15px; /* 按钮之间的间距 */
    padding: 8px 12px;
    background: var(--bg-day-element);
    border-radius: 20px; /* 胶囊形状 */
    box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day);
    z-index: 10;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease, transform 0.2s ease;
}
body.dark-mode #phoneStatusMenu {
    background: var(--bg-night-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night);
}

/* 弹出菜单显示时的样式 */
#phoneStatusMenu.show {
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) translateY(5px) scale(1);
}

/* 弹出菜单中的小按钮 */
.status-option-btn {
    width: 36px;
    height: 36px;
    border: none;
    background: transparent;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    transition: transform 0.2s, background-color 0.2s;
}
.status-option-btn:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .status-option-btn:hover {
    background-color: rgba(255,255,255,0.1);
}
.status-option-btn:active {
    transform: scale(0.9);
}

/* 按钮图标颜色 */
.status-option-btn .owned-icon {
    color: #ffc107; /* 黄色 */
}
.status-option-btn .wishlist-icon {
    color: #ff85a2; /* 粉色 */
}

/* "已拥有" 状态的呼吸辉光效果 */
@keyframes breathing-glow {
    0% { box-shadow: 0 0 5px 0px var(--status-color), inset 0 0 3px 0px var(--status-color); }
    50% { box-shadow: 0 0 15px 3px var(--status-color), inset 0 0 5px 1px var(--status-color); }
    100% { box-shadow: 0 0 5px 0px var(--status-color), inset 0 0 3px 0px var(--status-color); }
}

.phone-partition-item.status-owned {
    background: var(--status-color); /* 将背景设为状态颜色 */
    color: black; /* 将文字颜色设为黑色 */
    text-shadow: 0 1px 3px rgba(255,255,255,0.3); /* 为文字添加轻微阴影以增强可读性 */
    animation: float-bubble 6s ease-in-out infinite, breathing-glow 2.5s ease-in-out infinite;
}


/* "愿望单" 状态的实线边框效果 (修正版) */
.phone-partition-item.status-wishlist {
    outline: 2.5px solid var(--status-color);
    outline-offset: 2px; /* 让边框与泡泡之间有一点空隙，更好看 */
}
/* ★★★ 新增：修复磨砂玻璃主题下“已拥有”状态的背景色问题 ★★★ */
body.theme-glass .phone-partition-item.status-owned,
body.theme-glass.dark-mode .phone-partition-item.status-owned {
    background: var(--status-color);
    /* 移除磨砂玻璃主题添加的透明边框，避免颜色冲突 */
    border: none;
}
/* =============================================================== */
/* ============= [新增] 多版本恢复选择器样式 ================ */
/* =============================================================== */
#recovery-versions-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-height: 45vh;
    overflow-y: auto;
    padding: 5px;
    margin: 10px 0;
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15px, black 90%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15px, black 90%, transparent 100%);
}

.recovery-version-item {
    border: 1px solid rgba(128,128,128,0.2);
    border-radius: 10px;
    transition: background-color 0.2s, border-color 0.2s;
    position: relative;
}

.recovery-version-item:has(input:checked) {
    background-color: rgba(91, 153, 226, 0.1);
    border-color: var(--hold-border);
    box-shadow: 0 0 8px rgba(91, 153, 226, 0.3);
}

.recovery-version-item label {
    display: block;
    padding: 12px 18px;
    cursor: pointer;
    line-height: 1.6;
}

.recovery-version-item input[type="radio"] {
    position: absolute;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
}

.version-meta {
    font-size: 14px;
    margin-bottom: 8px;
    font-weight: 600;
}
.version-meta span {
    font-size: 12px;
    font-weight: normal;
    color: #889;
    margin-left: 8px;
}
body.dark-mode .version-meta span {
    color: #a0aec0;
}

.version-summary {
    font-size: 13px;
    color: #5a6778;
    display: flex;
    flex-wrap: wrap;
    gap: 5px 15px; /* 行间距 和 列间距 */
}
body.dark-mode .version-summary {
    color: #c0c6cc;
}

#confirmRecoveryBtn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    color: #9db2c2 !important;
    box-shadow: none !important;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* ===== [新增] 相册重命名图标样式 ===== */
#memoryModal .album-item .rename-icon {
    display: none; /* 默认隐藏 */
    position: absolute;
    bottom: 8px;
    right: 12px;
    font-size: 20px;
    font-weight: normal;
    color: #a0aec0; /* 一个柔和的颜色 */
    cursor: pointer;
    padding: 5px;
    z-index: 10;
    transition: color 0.2s, transform 0.2s;
    -webkit-user-select: none;
    user-select: none;
    line-height: 1;
}

body.dark-mode #memoryModal .album-item .rename-icon {
    color: #718096;
}

/* 管理模式下显示 */
#memoryModal .album-item.manage-mode .rename-icon {
    display: block;
}

#memoryModal .album-item .rename-icon:hover {
    color: var(--hold-border);
    transform: scale(1.2);
}

/* 当有自定义背景时，使图标更清晰 */
#memoryModal .album-item.has-custom-bg .rename-icon {
    color: white;
    opacity: 0.7;
    text-shadow: 0 0 3px rgba(0,0,0,0.7);
}
#memoryModal .album-item.has-custom-bg .rename-icon:hover {
    opacity: 1;
}
/* ===== [新增] 长图查看器缩放样式 ===== */
#memoryPhotoViewerOverlay #viewer-img-container {
    cursor: zoom-in; /* 默认显示放大光标 */
}
#viewer-img-container.zoomed-long {
    align-items: flex-start; /* 切换为顶部对齐 */
    overflow-y: auto;        /* 允许垂直滚动 */
    cursor: default;         /* 容器本身恢复默认光标 */
}
#viewer-img-container.zoomed-long #viewer-img {
    max-height: none;        /* 移除最大高度限制 */
    width: 100%;             /* 宽度占满容器 */
    cursor: zoom-out;        /* 图片上显示缩小光标 */
}
/* =============================================================== */
/* ============= [新增] 备忘录文件夹管理图标样式 =============== */
/* =============================================================== */

/* 1. 重命名图标样式 (复用相册样式) */
#memoryModal .folder-item .rename-icon {
    display: none; /* 默认隐藏 */
    position: absolute;
    bottom: 8px;
    right: 12px;
    font-size: 20px;
    font-weight: normal;
    color: #a0aec0;
    cursor: pointer;
    padding: 5px;
    z-index: 10;
    transition: color 0.2s, transform 0.2s;
    -webkit-user-select: none;
    user-select: none;
    line-height: 1;
}

body.dark-mode #memoryModal .folder-item .rename-icon {
    color: #718096;
}

/* 管理模式下显示重命名图标 */
#memoryModal .folder-item.manage-mode .rename-icon {
    display: block;
}

#memoryModal .folder-item .rename-icon:hover {
    color: var(--hold-border);
    transform: scale(1.2);
}

/* 2. 排序拖拽把手样式 (复用相册样式) */
.folder-item .sort-handle.memo-sort-handle {
    display: none; /* 默认隐藏 */
    position: absolute;
    top: 8px;
    right: 8px;
    font-size: 24px;
    font-weight: bold;
    color: #b0b0b0;
    cursor: grab;
    padding: 5px;
    z-index: 10;
    transition: color 0.2s, transform 0.2s;
    -webkit-user-select: none;
    user-select: none;
    line-height: 1;
}

body.dark-mode .folder-item .sort-handle.memo-sort-handle {
    color: #777;
}

/* 管理模式下显示排序把手 */
.folder-item.manage-mode .sort-handle.memo-sort-handle {
    display: block;
}

.folder-item .sort-handle.memo-sort-handle:hover {
    color: var(--hold-border);
    transform: scale(1.1);
}

.folder-item .sort-handle.memo-sort-handle:active {
    cursor: grabbing;
}
/* =============================================================== */
/* ============= [新增] Codeberg 设置模态框专属样式 ============== */
/* =============================================================== */
#codebergSettingsModal .modal-body label {
    font-size: 14px;
    color: #5a6778;
    font-weight: 600;
    margin-bottom: 8px;
}
body.dark-mode #codebergSettingsModal .modal-body label {
    color: #c0c6cc;
}

.codeberg-account-display {
    padding: 12px 18px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
    transition: all .3s ease;
}
body.dark-mode .codeberg-account-display {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}

.codeberg-account-display.inactive {
    color: #e53e3e;
}
.codeberg-account-display.active {
    color: var(--hold-border);
}


.codeberg-account-list-container {
    padding: 10px;
    min-height: 100px;
    max-height: 200px;
    overflow-y: auto;
    border-radius: 12px;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
    display: flex;
    flex-direction: column;
}
body.dark-mode .codeberg-account-list-container {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}

.codeberg-empty-list {
    margin: auto;
    color: #889;
    font-size: 15px;
}

.codeberg-account-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-radius: 8px;
    transition: background-color .2s;
}
.codeberg-account-item:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .codeberg-account-item:hover {
    background-color: rgba(255,255,255,0.08);
}

.codeberg-account-item span {
    flex-grow: 1;
    font-size: 16px;
    font-weight: 500;
}

.codeberg-account-item .account-actions {
    display: flex;
    gap: 8px;
}

.codeberg-account-item .account-actions button {
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 600;
}
/* 主题蓝色按钮的特殊样式 */
.codeberg-auth-button {
    color: white !important;
    background: var(--hold-border) !important;
    box-shadow: 0 4px 12px rgba(91, 153, 226, 0.4);
}
.codeberg-auth-button:active {
    background: #4a8ad4 !important;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.2) !important;
}

.codeberg-guidance-section {
    text-align: center;
    font-size: 13px;
    color: #889;
    line-height: 1.6;
    border-top: 1px solid rgba(128,128,128,0.2);
    padding-top: 20px;
    margin-top: 5px;
}
.codeberg-guidance-section a {
    color: var(--hold-border);
    font-weight: 600;
    text-decoration: none;
}
.codeberg-guidance-section a:hover {
    text-decoration: underline;
}

/* 磨砂玻璃主题适配 */
body.theme-glass .codeberg-account-display,
body.theme-glass .codeberg-account-list-container {
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow: none;
}
body.theme-glass.dark-mode .codeberg-account-display,
body.theme-glass.dark-mode .codeberg-account-list-container {
    background: rgba(10, 10, 10, 0.2);
    border-color: rgba(255, 255, 255, 0.1);
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

    </style>

 <style id="custom-jelly-ball-styles"></style>

    <!-- [新增] 用于全局字体的样式标签 -->
    <style id="global-font-style"></style>
    <!-- 手机模式滑动容器 -->
    <div class="main-wrapper" id="mainWrapper">
        <div class="page-slider" id="pageSlider">
            <!-- 锁屏页面 -->
            <div class="lock-screen-page" id="lockScreenPage">
                <div class="lockscreen-grid" id="lockscreenGrid">
                    <!-- JS 动态填充 -->
                </div>
            </div>
            <!-- 主屏幕页面 (JS会将下面的内容移入此div) -->
            <div class="home-screen-page" id="homeScreenPage">
                <!-- JS 动态填充 -->
            </div>
        </div>
    </div>

    <!-- [核心修复] 将主页内容移出 mobile-wrapper，作为 body 的直接子元素 -->
    <div class="page-overlay" id="pageOverlay"></div>
    <div class="title-card" id="titleCard">
        <h1 class="editable-title" id="title">Jellyfish Island</h1>
        <div class="editable-subtitle" id="subtitle">长按🌞打开工具栏 | By淡季水母</div>
    </div>

    <div class="category-nav-container" id="categoryNavContainer">
        <div class="category-nav" id="categoryNav"></div>
    </div>

    <!-- [新增] 可滚动的包裹容器 (结构调整) -->
    <div class="scrollable-nav-wrapper">
        <div class="nav-container" id="navContainer">
            <p id="loading-status" style="text-align: center; color: #889;">正在从云端加载配置...</p>
        </div>
    </div>

    <!-- 注意：悬浮按钮和模态框需要放在滑动容器之外，以保证它们在所有页面上都能正常显示和交互 -->
    <div class="fab-container" id="fabContainer">
        <div class="fab-drawer" id="fabDrawer">
            <button class="fab-drawer-item" id="helpBtn" title="使用指南">📧</button>
            <button class="fab-drawer-item" id="dataSyncBtn" title="数据同步">☁️<span id="sync-status-indicator" title="云同步状态"></span></button>
            <button class="fab-drawer-item" id="addNavBtn" title="管理项目">📱</button>
            <button class="fab-drawer-item" id="colorBtn" title="主题设置">🎨</button>
            <button class="fab-drawer-item" id="phoneCollectionBtn" title="手机收藏馆">💬</button>
            <button class="fab-drawer-item" id="memoryBtn" title="记忆">📷</button>
        </div>
        <button class="fab-main theme-toggle" id="themeBtn" title="切换主题">🌞</button>
    </div>

    <!-- ===== [结构修改] 手机收藏馆模态框 v2 ===== -->
    <!-- 列表主窗口 -->
    <div class="modal-overlay" id="phoneCollectionModal">
        <div class="modal-content">
            <div class="page-content">
                <div class="page-header-container">
                    <div class="modal-header" style="padding: 12px 15px;">
                        <div class="modal-title-group" style="gap: 8px; align-items: center;">
                            <span>手机收藏馆</span>
                            <button id="showNoticeBell" title="查看社区须知">ⓘ</button>
                        </div>
                        <button class="close-btn" data-modal-id="phoneCollectionModal">&times;</button>
                    </div>
                    <!-- ★★★ 修改：将搜索框和筛选按钮放在一个 flex 容器中 ★★★ -->
                    <div id="phone-search-filter-bar" style="padding: 0 15px 15px 15px; display: flex; align-items: center; gap: 10px;">
                        <input type="search" id="phoneSearchInput" class="modal-input" placeholder="按名称或作者ID搜索..." style="flex-grow: 1; min-width: 0;">
                        <button id="phoneFilterBtn" class="modal-button" style="flex-shrink: 0; padding: 10px 15px;">筛选</button>
                    </div>
                </div>
                <div id="phone-list-container" class="list-container">
                    <!-- JS动态填充手机分区 -->
                </div>
            </div>
        </div>
    </div>

    <!-- ★★★ 新增：筛选功能的模态框 ★★★ -->
    <div id="phoneFilterModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 80vh;">
            <div class="modal-header">
                <div class="modal-title-group">筛选器</div>
                <button class="close-btn" data-modal-id="phoneFilterModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- 1. 已选中的筛选标签 -->
                <div id="selected-filters-container" class="filter-section" style="border-bottom:none; padding-bottom: 5px; margin-bottom: 5px;">
                    <!-- JS 将在此处填充 -->
                </div>
                <!-- 2. 可选的筛选条件 -->
                <div class="filter-section">
                    <h4 class="filter-group-title">手机状态</h4>
                    <div id="filter-options-status" class="filter-options-grid">
                        <!-- JS 将在此处填充 -->
                    </div>
                </div>
                <div class="filter-section">
                    <h4 class="filter-group-title">售卖类型</h4>
                    <div id="filter-options-price" class="filter-options-grid">
                        <!-- JS 将在此处填充 -->
                    </div>
                </div>
                <div class="filter-section">
                    <h4 class="filter-group-title">我的状态</h4>
                    <div id="filter-options-user" class="filter-options-grid">
                        <!-- JS 将在此处填充 -->
                    </div>
                </div>
            </div>
            <!-- 3. 底部按钮 -->
            <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 15px; flex-grow: 0; flex-shrink: 0; border-top: 1px solid rgba(128,128,128,0.2);">
                <button id="clear-filters-btn" class="modal-button" style="color: #889;">清除</button>
                <button id="apply-filters-btn" class="modal-button" style="flex-grow: 1; margin-left: 10px; color: var(--hold-border);">确认</button>
            </div>
        </div>
    </div>

    <!-- 详情悬浮窗 -->
    <div class="modal-overlay" id="phoneDetailModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <!-- ★★★ 修改点：将标题和状态按钮包裹起来，并新增弹出菜单 ★★★ -->
                <div id="phone-detail-title-group" class="modal-title-group" style="gap: 12px; align-items: center; position: relative;">
                    <span id="phone-detail-title">手机详情</span>
                    <span id="phoneStatusBtn" style="cursor: pointer; font-size: 24px;" title="设置状态">◌</span>
                    <!-- [新增] 状态选择弹出菜单 -->
                    <div id="phoneStatusMenu">
                        <button class="status-option-btn" data-status="owned" title="已拥有">
                            <span class="status-icon owned-icon">★</span>
                        </button>
                        <button class="status-option-btn" data-status="wishlist" title="加入愿望单">
                            <span class="status-icon wishlist-icon">♥</span>
                        </button>
                         <button class="status-option-btn" data-status="none" title="未拥有">
                            <span class="status-icon" style="font-size: 20px;">∅</span>
                        </button>
                    </div>
                </div>
                <button class="close-btn" data-modal-id="phoneDetailModal">&times;</button>
            </div>
            <div class="modal-body" id="phone-detail-content">
                <!-- JS动态填充手机信息 -->
            </div>
        </div>
    </div>
    
    <!-- [新增] 评论区模态框 -->
    <div class="modal-overlay" id="phoneCommentsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div id="phone-comments-title" class="modal-title-group">安利区</div>
                <button class="close-btn" data-modal-id="phoneCommentsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Giscus 评论组件将在这里加载 -->
                <div class="giscus"></div>
                <!-- ⚠️ script 标签已被移除，将由 JavaScript 动态创建 -->
            </div>
        </div>
    </div>
    <!-- ===== [修改结束] ===== -->
    
    <!-- Modals -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group"><span>使用指南</span></div>
                <button class="close-btn" data-modal-id="helpModal">&times;</button>
            </div>
            <div class="modal-body">
                <input type="radio" id="help-tab-0" name="help-tab" value="setup" checked hidden>
                <input type="radio" id="help-tab-1" name="help-tab" value="features" hidden>
                <input type="radio" id="help-tab-2" name="help-tab" value="updates" hidden>
                <input type="radio" id="help-tab-3" name="help-tab" value="disclaimer" hidden>

                <div class="segmented-control four-segments">
                    <label for="help-tab-0">首次配置</label>
                    <label for="help-tab-1">功能介绍</label>
                    <label for="help-tab-2">更新公告<span id="update-log-indicator"></span></label>
                    <label for="help-tab-3">免责声明</label>
                    <div class="slider-indicator"></div>
                </div>
                <div class="help-content-wrapper">
                    <div id="help-page-0" class="help-page-content">
                        <h3>从零开始 (必需)</h3><p>此流程仅需您创建一个安全的“钥匙”(PAT)和一个云端“私人数据仓库”，让本应用可以为您安全地存储和同步所有数据。</p><ol><li><strong>访问创建页面</strong>：<a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener noreferrer">点击此链接直接进入 GitHub Token 创建页面</a>。</li><li><strong>填写基本信息</strong>：备注(Note)填写 <code>JellyfishIslandToken</code>，有效期(Expiration)选择 <code>No expiration</code> (永不过期)。</li><li><strong>分配权限 (关键)</strong>：只需 <strong>勾选 <code>repo</code></strong> 这一项。</li><li><strong>生成并复制</strong>：滑动到页面最底部，点击 <strong><code>Generate token</code></strong> 按钮。<strong>【⚠️极其重要⚠️】</strong> GitHub 只会显示这一次完整的 Token。请 <strong>立即点击复制按钮</strong> 将其保存到安全的地方，下一步会马上用到。它应该以 <code>ghp_</code> 开头。</li></ol>
                        <h4>步骤 2：创建私人数据仓库</h4><p>此步骤将创建一个独立的、完全私密的仓库，专门用来存放您的所有配置和文件。</p><ol><li><strong>访问创建页面</strong>：<a href="https://github.com/new" target="_blank" rel="noopener noreferrer">点击此链接直接进入 GitHub 仓库创建页面</a>。</li><li><strong>填写仓库信息</strong>：<ul><li><strong>Repository name (仓库名称)</strong>：起一个清晰的名字，例如 <code>My-Jellyfish-Data</code>。</li><li><strong>关键：选择 <code>Private</code> (私有)</strong>。这是您的私人数据，必须设为私有。</li><li><strong>勾选 <code>Add a README file</code></strong>：确保仓库被成功初始化。</li></ul></li><li><strong>点击 <code>Create repository</code></strong> 按钮完成创建。</li></ol>
                        <h4>步骤 3：在 Jellyfish Island
 内完成最终配置</h4><p>现在，我们将“钥匙”和“数据仓库”信息告诉本应用。</p><ol><li><strong>打开配置面板</strong>：长按右下角的 🌞/🌜 按钮展开菜单 → 点击 <strong>☁️ (数据同步)</strong>。</li><li><strong>填入信息</strong>：<ul><li><strong>仓库</strong>：填写您在 <strong>步骤2</strong> 创建的**私人数据仓库**地址，格式为 <code>你的GitHub用户名/My-Jellyfish-Data</code>。</li><li><strong>Personal Access Token</strong>：粘贴您在 <strong>步骤1</strong> 创建并复制好的完整 Token。</li></ul></li><li><strong>保存并同步</strong>：点击 <strong><code>保存配置</code></strong> 按钮。</li></ol><p><strong>恭喜！</strong> 您的 Jellyfish Island 现已与云端完全同步，可以开始使用了！</p>
                    </div>
              
<div id="help-page-1" class="help-page-content">
    <details>
        <summary>核心操作</summary>
        <div class="details-content">
            <p><strong>编辑标题/副标题</strong>: 直接点击页面上的主标题或副标题即可修改。</p>
            <p><strong>切换主题</strong>: <strong>单击 (短按)</strong> 右下角的 🌞/🌜 按钮。</p>
            <p><strong>打开功能菜单</strong>: <strong>长按</strong> 右下角的 🌞/🌜 按钮。</p>
            <p><strong>访问链接与返回</strong>: 对于外部链接，默认在应用内全屏打开。您可以从屏幕**左侧中间区域向右滑动**来关闭当前页面并返回中心。您也可以在添加链接时选择“在新标签页中打开”，这样链接会直接通过系统浏览器打开。</p>
            <div class="important-note">
                <p><strong>关于“在新标签页中打开”选项的说明：</strong><br>此选项主要用于解决部分与应用内浏览器不兼容的网站。启用此选项后，链接将通过系统默认浏览器打开。请注意，部分设备在该模式下可能无法隐藏底部工具栏，这是一个已知的系统限制，请您根据需求自行选择。</p>
            </div>
        </div>
    </details>
    <details>
        <summary>☁️ 数据同步</summary>
        <div class="details-content">
            <p><strong>配置同步</strong>: 此功能用于设置您的私有GitHub仓库信息，是整个应用数据同步的核心。配置完成后，所有更改都将自动保存至云端。</p>
            <div class="important-note"><p><strong>新增智能迁移</strong>：该功能现在可以自动识别并修复旧版本（无分类功能）的配置文件，将其无缝升级为最新格式。</p></div>
            <p><strong>云同步状态指示灯</strong>：☁️ 图标上的小圆点会实时显示同步状态：</p>
            <ul><li><strong>🟢 绿点</strong>: <code>已同步</code> - 所有本地更改都已成功保存到云端。</li><li><strong>🟡 黄点 (闪烁)</strong>: <code>同步中</code> - 正在与云端进行数据交换。</li><li><strong>🔴 红点</strong>: <code>同步失败</code> - 发生错误，请点击图标查看失败原因。</li></ul>
            <p><strong>手动同步与修复</strong>: 在“数据同步”弹窗内，提供了一个手动同步按钮。此功能会强制从云端获取最新的配置文件，并与应用内置的最新模板进行对比。如果您的配置文件因版本更新而缺少了某些新功能的设置项，此功能会自动为您补全，确保应用正常运行。</p>
        </div>
    </details>
    <details>
        <summary>📱 项目管理</summary>
        <div class="details-content">
            <p><strong>分类导航</strong>: 您可以左右滑动顶部的分类导航栏来切换不同的项目分类。此导航栏可在“管理项目”中通过“分页展示”开关控制其显示或隐藏。</p>
            <p><strong>添加/编辑项目</strong>: 在"管理项目"弹窗中进行操作。进入“按钮管理模式”（在“管理项目”弹窗内点击）后，点击已存在的按钮即可进入编辑模式。</p>
            <p><strong>删除分类</strong>: 在“管理项目”弹窗中，选择一个分类后，即可看到“删除当前分类”按钮。您可以选择：</p>
            <ul>
                <li><strong>仅删除分类</strong>: 项目将被保留并移至“全部”分类下。</li>
                <li><strong>删除分类和所有项目</strong>: 永久删除该分类及其包含的所有项目（需二次确认）。</li>
            </ul>
        </div>
    </details>
    <details>
        <summary>🎨 主题与个性化</summary>
        <div class="details-content">
            <p><strong>主题风格</strong>：您现在可以在“全拟态”和“磨砂玻璃”两种视觉风格之间切换。选择“磨砂玻璃”后，界面元素将变为半透明质感，此时配色功能将关闭，但您仍可上传自定义背景图以搭配新风格。</p>
            <p><strong>实时调色</strong>：在“全拟态”风格下，可实时调整日间/夜间模式的背景渐变色，以及标题卡片的背景图片。</p>
            <p><strong>色彩预设</strong>：在“全拟态”风格下，您可以保存、应用、更新或删除自己喜欢的配色方案，还可以开启“随机主题”功能，在每次启动时随机应用一个已保存的预设。</p>
            <div class="important-note" style="margin-top: 15px;">
                <h4>🪼 悬浮窗与悬浮球</h4>
                <p>通过 <code>主题设置 → 网页内悬浮球</code>，您可以在应用内网页中开启一个便捷的悬浮助手。</p>
                <p><strong>悬浮球操作</strong>:</p>
                <ul>
                    <li><strong>拖动</strong>: 按住并拖动可移动位置，松手后自动贴边。</li>
                    <li><strong>闲置隐藏</strong>: 静置3秒后会自动半透明隐藏，减少干扰。</li>
                    <li><strong>功能菜单</strong>: <strong>长按</strong>悬浮球会弹出环形功能菜单，滑动到目标功能上松手即可触发。</li>
                </ul>
                <p><strong>“快速切换”悬浮窗</strong>:</p>
                <p>这是悬浮球菜单中的一个强大功能（🔗），它允许您将任何项目在独立的悬浮窗口中打开。</p>
                <ul>
                    <li><strong>移动</strong>: 按住窗口顶部的标题栏进行拖动。</li>
                    <li><strong>隐藏/关闭</strong>: 点击标题栏上的 <strong>－</strong> 可将其最小化至侧边栏，点击 <strong>×</strong> 可彻底关闭。</li>
                    <li><strong>调整大小</strong>: 拖动窗口右下角可以等比例缩放窗口大小。</li>
                </ul>
            </div>
            <div class="important-note" style="margin-top: 15px;">
                <h4>📱 锁屏组件</h4>
                <p>通过 <code>主题设置 → 手机模式</code>，您可以开启一个模拟手机桌面的锁屏界面。在这里，您可以自由添加和布局多种实用小组件。</p>
                <ul>
                    <li><strong>自由布局</strong>: 在设置界面，通过拖拽即可将组件放置在锁屏网格的任意位置。</li>
                    <li><strong>多种尺寸与形状</strong>: 支持创建不同尺寸（如2x2, 4x2）和形状（方形、圆形）的组件。</li>
                    <li><strong>丰富组件类型</strong>:
                        <ul>
                            <li><strong>快捷方式</strong>: 将任意项目（链接或上传的应用）固定到锁屏，实现一键直达。</li>
                            <li><strong>备忘录</strong>: 直接在锁屏上预览指定备忘录的内容，或实时查看和完成待办事项。</li>
                            <li><strong>图片</strong>: 从“记忆相册”中选择一张图片作为锁屏背景或装饰。</li>
                            <li><strong>HTML</strong>: 支持嵌入自定义HTML代码，实现天气、时钟等高度个性化功能。</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </details>
    <!-- ★★★ 新增：手机收藏馆介绍 ★★★ -->
    <details>
        <summary>💬 手机收藏馆</summary>
        <div class="details-content">
            <p>一个社区驱动的手机分区展示与交流中心。</p>
            <ul>
                <li><strong>集中展示</strong>：汇集了来自社区作者的各类手机分区，方便你快速浏览和发现。</li>
                <li><strong>快速直达</strong>：提供作者ID、获取方式等基础信息，并支持作者小红书ID一键复制。</li>
                <li><strong>友好安利区</strong>：每个分区都拥有独立的评论区，你可以在这里分享使用体验、进行友好交流。</li>
                <li><strong>个性化置顶</strong>：可以将你最喜欢的手机分区置顶显示，打造专属的收藏列表。</li>
            </ul>
        </div>
    </details>
    <details>
        <summary>📷 记忆功能</summary>
        <div class="details-content">
            <p>一个集成了备忘录、相册和文件云盘的私人空间，所有数据都安全地存储在您的GitHub私有仓库中。</p>
            <ul>
                <li><strong>备忘录</strong>: 支持文件夹分类管理。编辑器提供待办清单、多种文字格式和可一键复制的代码块功能，满足不同的记录需求。</li>
                <li><strong>相册</strong>: 支持创建多个相册，批量上传照片，并可进入沉浸式的“漫游模式”浏览，支持配合背景音乐播放。</li>
                <li><strong>文件夹</strong>: 一个轻量级的文件云盘，支持按项目分类上传、下载和管理各类文件。</li>
            </ul>
        </div>
    </details>

    <div class="warning"><p><strong>危险操作</strong>：在 <code>数据同步</code> (☁️) 弹窗的最下方有“清空所有数据”按钮。此操作会 <strong>永久删除</strong> 您 GitHub 数据仓库中所有相关数据。<strong>此操作不可逆，请极度谨慎</strong>。</p></div>
</div>
<div id="help-page-2" class="help-page-content">
    <div class="update-header-info">
        <p><strong>小红书ID:</strong> 淡季水母</p>
        <p><strong>QQ交流群:</strong> 563191005</p>
    </div>
        <!-- ★ 在这里新增下面的代码块 ★ -->
<div class="update-log-entry">
    <h4>v5.9.5 <span class="update-date">- 2025.10.19</span></h4>
    <ul>
        <li><span class="tag new">新功能</span> 新增备份提醒功能，支持定时或在关闭项目时弹出提醒，有效防止数据丢失。</li>
        <li><span class="tag new">新功能</span> 手机收藏馆新增“我的状态”功能，可将手机标记为“已拥有”或“愿望单”，并附有专属动态效果。</li>
        <li><span class="tag new">新功能</span> 手机收藏馆新增高级筛选功能，支持按手机状态、售价和“我的状态”进行多条件组合筛选。</li>
        <li><span class="tag new">新功能</span> 在相册的全屏看图模式下，现已支持直接下载当前照片。</li>
    </ul>
</div>
<div class="update-log-entry">
    <h4>v5.9.0 <span class="update-date">- 2025.10.17</span></h4>
    <ul>
        <li><span class="tag release">里程碑</span> 应用正式更名为“水母岛 (Jellyfish Island)”。</li>
        <li><span class="tag opt">优化</span> 重构了新用户引导流程。首次打开应用时，将弹出友好的配置向导，取代了原有的技术性错误提示，帮助用户更顺畅地完成初始设置。</li>
        <li><span class="tag new">新功能</span> “更新公告”标签页新增红点提示，与主菜单的更新提醒同步，让版本变更一目了然。</li>
        <li><span class="tag fix">修复</span> 解决了因逻辑中断导致全局字体设置功能按钮无法点击的问题。</li>
    </ul>
</div>
    <div class="update-log-entry">
        <h4>v5.8.0 <span class="update-date">- 2025.10.16</span></h4>
        <ul>
            <li><span class="tag new">新功能</span> 【数据保险箱】当云端数据意外清空时，进入“数据同步”弹窗点击“手动同步与修复”，系统会自动检测并引导您从上一个历史版本一键恢复所有数据。</li>
            <li><span class="tag new">新功能</span> 新增上传中断保护，在上传文件或照片时关闭页面会触发挽留提示。</li>
            <li><span class="tag new">新功能</span> 在“记忆-文件夹”中上传文件时，增加了“✖”按钮以随时终止上传任务。</li>
            <li><span class="tag fix">修复</span> 修复了在特定情况下，“记忆-相册”批量上传照片时可能中断或失败的问题。</li>
            <li><span class="tag opt">优化</span> 优化了项目内所有弹窗的字体渲染，增强了可读性。</li>
            <li><span class="tag opt">优化</span> 提升了文件上传进度条的计算精度。</li>
        </ul>
    </div>
        <!-- ★ 在这里新增下面的代码块 ★ -->
    <div class="update-log-entry">
        <h4>v5.7.6 <span class="update-date">- 2025.10.16</span></h4>
        <ul>
            <li><span class="tag new">新功能</span> 新增全局字体更换功能，支持在主题设置中应用在线字体及管理预设。</li>
            <li><span class="tag new">新功能</span> 新增为相册设置自定义背景（封面）的功能。</li>
            <li><span class="tag new">新功能</span> 新增相册排序功能，在管理模式下可以拖拽调整相册顺序。</li>
            <li><span class="tag opt">优化</span> 优化了项目编辑逻辑，修改项目后其按钮将保持在原位，不再移动到末尾。</li>
            <li><span class="tag opt">优化</span> 美化了“手机收藏馆”的界面，采用更具动感的泡泡布局以提升视觉体验。</li>
            <li><span class="tag opt">优化</span> 优化了相册的上传流程，批量上传照片和编辑信息的交互更为简洁。</li>
            <li><span class="tag fix">修复</span> 修复了备忘录内容无法垂直滚动以及代码块内长文本溢出的问题。</li>
            <li><span class="tag fix">修复</span> 修复了在主题设置中，所选的主题风格（如“磨砂玻璃”）无法被正确保存的问题。</li>
            <li><span class="tag fix">修复</span> 修复了在管理模式下长按拖拽排序时，项目按钮位置可能无法正确互换的问题。</li>
        </ul>
    </div>

    <div class="update-log-entry">
        <h4>v5.5.0 <span class="update-date">- 2025.10.14</span></h4>
        <ul>
            <li><span class="tag new">新功能</span> 新增悬浮球CSS预设管理功能。</li>
            <li><span class="tag opt">优化</span> 简化了主题颜色预设的管理界面，操作更直观。</li>
        </ul>
    </div>
    
    <!-- 下方是原始的 v5.4.0 代码 -->
    <div class="update-log-entry">
        <h4>v5.4.0 <span class="update-date">- 2025.10.13</span></h4>
        <ul>
            <!-- ★ 修改点：移除加粗标题，润色文案 -->
            <li><span class="tag opt">优化</span> 全拟态主题的颜色设置体验得到优化，颜色值现已支持直接在输入框中修改，整体布局也更为直观。</li>
            <li><span class="tag new">新功能</span> 新增“手机收藏馆”功能，一个社区驱动的手机分区收藏与交流中心，方便发现与分享。</li>
        </ul>
    </div>
     <div class="update-log-entry">
        <h4>v5.3.0 <span class="update-date">- 2025.10.11</span></h4>
        <ul>
            <!-- ★ 修改点：移除加粗标题，润色文案 -->
            <li><span class="tag new">新功能</span> 新增“锁屏组件”功能，支持在手机模式下高度自定义布局与多种组件类型。（详见“功能介绍”）</li>
            <li><span class="tag new">新功能</span> 备忘录功能得到增强，新增待办事项（清单）、多种文字格式及一键复制代码块功能。</li>
            <li><span class="tag fix">修复</span> 解决了悬浮球在部分内嵌网页中无法显示的问题。</li>
            <li><span class="tag fix">修复</span> 修复了在悬浮球设置中，自定义CSS输入框无法实时预览样式的问题。</li>
        </ul>
    </div>
    <!-- ... (这里是你文件里原有的其他更新日志，保持不变) ... -->
    <div class="update-log-entry">
        <h4>v4.1.0 <span class="update-date">- 2025.10.04</span></h4>
        <ul>
            <li><span class="tag fix">修复</span> 解决了上传的HTML项目在部分情况下无法正常打开的问题。</li>
            <li><span class="tag new">新功能</span> 新增悬浮球CSS自定义向导与模板，方便用户快速美化悬浮球。（详见“主题设置”）</li>
            <li><span class="tag new">新功能</span> 在“按钮管理模式”下，支持通过长按并拖拽的方式，对项目按钮进行直观排序。</li>
            <li><span class="tag fix">修复</span> 修复了记忆功能的“文件夹”模块中，项目选择器无法正确加载和选择项目的问题。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v3.9.0 <span class="update-date">- 2025.10.03</span></h4>
        <ul>
            <li><span class="tag new">新功能</span> 新增网页内悬浮球与多项目悬浮窗功能，提升多任务操作体验。（详见“功能介绍”）</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v3.7.0 <span class="update-date">- 2025.10.02</span></h4>
        <ul>
            <li><span class="tag opt">优化</span> 对相册的底层加载逻辑进行了重构，引入懒加载技术，彻底解决了开启、浏览和管理相册时的各种卡顿、图片错乱和重复显示问题。</li>
            <li><span class="tag fix">修复</span> 彻底修复了文件在某些情况下无法下载的问题。</li>
            <li><span class="tag fix">修复</span> 修复了从内嵌网页跳转后，可能导致数据导出功能异常的Bug。</li>
            <li><span class="tag fix">修复</span> 修复了可能导致音乐无法正常加载播放和退出漫游后仍在后台播放的Bug。</li>
            <li><span class="tag fix">修复</span> 解决了因加载逻辑问题导致的相册照片无法显示的问题。</li>
            <li><span class="tag fix">修复</span> 修正了分页逻辑，现在关闭分页模式后，所有分类下的所有按钮都会被正确显示。</li>
            <li><span class="tag fix">修复</span> 修复了在漫游模式下照片无法左右滑动切换的问题。</li>
            <li><span class="tag opt">优化</span> 全拟态夜间模式下的立体阴影颜色调整为更深邃的黑色，增强了视觉层次感。</li>
            <li><span class="tag opt">优化</span> 移除了磨砂玻璃风格下按钮和悬浮窗的多余蓝调，使其色彩表现更纯净、更通透。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v3.6.0 <span class="update-date">- 2025.10.01</span></h4>
        <ul>
            <li><span class="tag fix">重要修复</span> 彻底解决了旧版无分类的 `config.json` 文件无法在新版应用中显示按钮的问题。</li>
            <li><span class="tag new">新功能</span> “手动同步与修复” 现已集成**智能数据迁移**功能，可自动将旧版配置文件无缝升级为最新、最兼容的格式。</li>
            <li><span class="tag opt">优化</span> 应用在首次加载云端数据时，也会自动执行数据迁移检查，确保老用户平滑过渡。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v3.5.0 <span class="update-date">- 2025.10.01</span></h4>
        <ul>
            <li><span class="tag new">功能</span> 新增按钮分类功能，可创建自定义分类管理项目。</li>
            <li><span class="tag new">功能</span> 新增 “在新标签页中打开” 选项，用于兼容特殊外部链接。</li>
            <li><span class="tag new">功能</span> 新增 “磨砂半透明” 主题，提供全新视觉风格。</li>
            <li><span class="tag fix">修复</span> 解决了上传的本地HTML项目无法在应用内正确打开的问题。</li>
            <li><span class="tag fix">修复</span> 修复了在部分页面左上角返回按钮无法点击的Bug。</li>
            <li><span class="tag opt">优化</span> 优化了应用内的错误与状态提示信息。</li>
            <li><span class="tag opt">优化</span> 访问GitHub相关链接时，增加开启VPN的友好提示弹窗。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v2.0.0 <span class="update-date">- 2025.09.30</span></h4>
        <ul>
            <li><span class="tag new">功能</span> 极大简化了添加网址与上传文件项目的方式。</li>
            <li><span class="tag new">功能</span> 新增文件云盘功能，支持按分类上传和下载文件。</li>
            <li><span class="tag new">功能</span> 新增 “记忆” 功能模块，集成备忘录与相册。</li>
            <li><span class="tag new">功能</span> 相册内置 “漫游模式”，提供沉浸式看图体验。</li>
            <li><span class="tag new">功能</span> 支持自定义上传全局背景图片和标题卡片背景图片。</li>
            <li><span class="tag fix">优化</span> 优化iOS端全屏显示，左侧右滑返回时增加确认弹窗以防误触。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v1.0.0 <span class="update-date">- 2025.09.24</span></h4>
        <ul>
            <li><span class="tag release">正式发布</span> JellyfishCenter 导航正式上线。</li>
            <li><span class="tag new">功能</span> 新增日间/夜间模式一键切换。</li>
            <li><span class="tag new">功能</span> 新增自定义图标与卡片主题色功能。</li>
        </ul>
    </div>
    
    <footer class="update-footer">
        当前版本: v5.9.5
    </footer>
</div>
                    <div id="help-page-3" class="help-page-content">
                        <h3>免责声明与使用条款</h3><h4>1. 服务条款</h4><p>本应用 (Jellyfish Island) 按“现状”提供，不附带任何明示或暗示的保证。开发者不保证应用的持续可用性、功能完整性或无错误。所有因使用本应用导致的直接或间接风险与责任，均由用户自行承担。</p><h4>2. 数据安全</h4><p>用户需自行负责其GitHub个人访问令牌 (PAT) 的安全保管。任何因PAT泄露导致的数据丢失、篡改或账户安全问题，开发者概不负责。强烈建议为本应用创建独立的、具有最小必要权限 (<code>repo</code>) 的PAT。</p><h4>3. 知识产权与版权责任</h4><div class="important-note"><p>本应用可能被用于托管或链接至第三方项目。用户必须对所上传或链接的内容负全部法律责任，并确保拥有展示、使用和分发该内容的合法权利。<strong>用户必须尊重所有原创作者的知识产权，不得侵犯他人版权。</strong></p></div><h4>4. 使用与分发限制</h4><div class="warning"><p>本项目 (Jellyfish Island) 及其源代码仅供个人非商业性使用。严禁以下行为：</p><ul><li>对本项目的源代码进行任何形式的二次修改、再分发或公开发布（即“二传二改”）。</li><li>公开或私下分享通过本应用“上传项目”功能生成的任何网页链接或文件。此行为可能构成对原创内容的未授权分发。</li></ul></div><p>继续使用本应用，即表示您已阅读、理解并同意上述所有条款。</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="syncErrorModal"><div class="modal-content"><div class="modal-header"><div class="modal-title-group"><span>⚠️ 同步失败</span></div><button class="close-btn" data-modal-id="syncErrorModal">&times;</button></div><div class="modal-body"><p>无法连接到云端。请检查您的网络连接或GitHub配置。</p><p><strong>失败原因:</strong></p><div id="sync-error-message"></div></div></div></div>
<div class="modal-overlay" id="addNavModal"><div class="modal-content"><div class="modal-header"><div class="modal-title-group"><span id="addNavModalTitle">管理项目</span></div><div class="header-toggle-group"><span>连续添加</span><label class="toggle-switch"><input type="checkbox" id="stayOpenToggle"><span class="slider"></span></label></div><button class="close-btn" data-modal-id="addNavModal">&times;</button></div><div class="modal-body">
    <button id="enterManageModeBtn" class="modal-button" style="color:#5a6778;">进入按钮管理模式</button>
    
    <!-- 分页展示开关 -->
    <div class="toggle-section" style="margin-top: 10px;">
        <span>分页展示</span>
        <label class="toggle-switch"><input type="checkbox" id="paginationToggle"><span class="slider"></span></label>
    </div>

    <!-- [新增] 备份提醒入口 -->
    <div class="toggle-section" style="margin-top: 10px; flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
        <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
            <span>备份提醒</span>
            <label class="toggle-switch"><input type="checkbox" id="backupReminderToggle"><span class="slider"></span></label>
        </div>
        <div id="backupSettingsEntry" style="width: 100%; display: none;">
                <button id="openBackupSettingsBtn" class="modal-button" style="width: 100%; margin-top: 10px;">备份提醒设置</button>
        </div>
    </div>
    <!-- [新增结束] -->
    
    <div class="segmented-control two-segments"><input type="radio" id="type-link" name="nav-type" value="link" checked hidden><label for="type-link">外部链接</label><input type="radio" id="type-upload" name="nav-type" value="upload" hidden><label for="type-upload">上传项目</label><div class="slider-indicator"></div></div><div class="form-section"><label for="newButtonCategoryInput">分类名称</label><input type="text" id="newButtonCategoryInput" class="modal-input" placeholder="选择或创建分类" list="category-datalist"><datalist id="category-datalist"></datalist></div><div id="category-management-section" style="display: none;"><button id="deleteCategoryBtn" class="modal-button" style="color:#e53e3e;">删除当前分类</button></div><div class="form-section"><label for="newButtonNameInput">按钮名称</label><input type="text" id="newButtonNameInput" class="modal-input" placeholder="例如: 我的博客"></div><div id="link-section"><div class="form-section"><label for="newButtonUrlInput">网址链接</label><input type="text" id="newButtonUrlInput" class="modal-input" placeholder="https://example.com"></div><div class="toggle-section" style="margin-top: 10px;"><span>在新标签页中打开</span><label class="toggle-switch"><input type="checkbox" id="openExternallyToggle"><span class="slider"></span></label></div></div><div id="upload-section" class="form-section" style="display: none;"><label>选择项目的主HTML文件</label><div class="file-select-wrapper"><input type="file" id="projectHtmlPicker" accept=".html,.htm" style="display: none;"><button id="filePickerBtn" class="modal-button">选择文件</button><span id="file-picker-status" class="status-text">未选择任何文件</span></div><div class="important-note" style="font-size: 13px; padding: 8px 12px; margin-top: 5px;"><p>上传的项目无法编辑链接，如需更新请删除后重新上传。</p></div></div><button id="createNavBtn" class="modal-button">加入新项目</button><div class="status-text" id="upload-status"></div></div></div></div>
    <div class="modal-overlay" id="settingsModal"><div class="modal-content"><div class="modal-header"><div class="modal-title-group"><span>数据同步</span></div><button class="close-btn" data-modal-id="settingsModal">&times;</button></div><div class="modal-body"><div class="form-section"><label for="githubRepoInput">仓库 (格式: 用户名/仓库名)</label><input type="text" id="githubRepoInput" class="modal-input" placeholder="例如: my-username/JellyfishPhones"></div><div class="form-section"><label for="githubTokenInput">Personal Access Token</label><input type="password" id="githubTokenInput" class="modal-input" placeholder="ghp_xxxxxxxxxx"></div><button id="saveSettingsBtn" class="modal-button">保存配置</button><button id="manualSyncBtn" class="modal-button" style="color:#5a6778; margin-top: 10px;">手动同步与修复</button><div class="nuke-section"><button id="nukeDataBtn" class="modal-button">清空所有云端及本地数据</button></div></div></div></div>
    <div class="modal-overlay" id="colorPaletteModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group"><span>主题设置</span></div>
                <button class="close-btn" data-modal-id="colorPaletteModal">&times;</button>
            </div>
                        <div class="modal-body">

                <!-- [新增] 手机模式开关 -->
                                <div class="toggle-section" style="flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                    <span style="font-weight: 600; width: 100%;">手机模式</span>
                    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
                        <span>启用手机主题</span>
                        <label class="toggle-switch"><input type="checkbox" id="mobileModeToggle"><span class="slider"></span></label>
                    </div>
                    <!-- [新增] 锁屏设置入口 -->
                    <div id="lockscreenSettingsEntry" style="width: 100%; display: none;">
                         <button id="openLockscreenSettingsBtn" class="modal-button" style="width: 100%; margin-top: 10px;">锁屏组件设置</button>
                    </div>
                </div>
                <!-- [新增结束] -->
                
                <div class="toggle-section" id="jelly-ball-main-control" style="flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                    <span style="font-weight: 600; width: 100%;">网页内悬浮球</span>
                    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
                        <span>启用悬浮球</span>
                        <label class="toggle-switch"><input type="checkbox" id="jellyBallToggle"><span class="slider"></span></label>
                    </div>
                    <!-- [新增] 悬浮球设置入口 -->
                    <div id="jellyBallSettingsEntry" style="width: 100%; display: none;">
                         <button id="openJellyBallSettingsBtn" class="modal-button" style="width: 100%; margin-top: 10px;">悬浮球设置</button>
                    </div>
                </div>

                <div class="theme-style-selector">
                    <label style="font-weight: 600;">主题风格</label>
                    <div class="segmented-control two-segments">
                        <input type="radio" id="theme-style-neumorphism" name="theme-style" value="neumorphism" checked hidden>
                        <label for="theme-style-neumorphism">全拟态</label>
                        <input type="radio" id="theme-style-glass" name="theme-style" value="glass" hidden>
                        <label for="theme-style-glass">磨砂玻璃</label>
                        <div class="slider-indicator"></div>
                    </div>
                </div>
                <div id="pneumorphism-settings">
                    <div class="color-picker-grid">
                        <div class="color-picker-group"><label>日间模式 - 左上</label><div class="color-input-wrapper"><input type="color" id="dayColor1Picker"><input type="text" class="modal-input hex-display" id="dayColor1HexInput" maxlength="7"></div></div>
                        <div class="color-picker-group"><label>日间模式 - 右下</label><div class="color-input-wrapper"><input type="color" id="dayColor2Picker"><input type="text" class="modal-input hex-display" id="dayColor2HexInput" maxlength="7"></div></div>
                        <div class="color-picker-group"><label>夜间模式 - 左上</label><div class="color-input-wrapper"><input type="color" id="nightColor1Picker"><input type="text" class="modal-input hex-display" id="nightColor1HexInput" maxlength="7"></div></div>
                        <div class="color-picker-group"><label>夜间模式 - 右下</label><div class="color-input-wrapper"><input type="color" id="nightColor2Picker"><input type="text" class="modal-input hex-display" id="nightColor2HexInput" maxlength="7"></div></div>
                    </div>
                    <div class="preview-container"><div class="preview-box" id="dayPreview" data-label="Day"></div><div class="preview-box" id="nightPreview" data-label="Night"></div></div>
                    <div class="preset-manager" style="margin-bottom: 15px;">
                        <div class="preset-row">
                            <select id="presetSelector" class="modal-select" style="flex-grow: 1;"></select>
                            <button id="addColorPresetBtn" title="添加新预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">+</button>
                            <button id="updateColorPresetBtn" title="更新当前预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">↻</button>
                            <button id="deleteColorPresetBtn" title="删除当前预设" class="modal-button delete" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">🗑</button>
                        </div>
                    </div>
                    <div class="toggle-section"><span>每次启动时随机应用预设</span><label class="toggle-switch"><input type="checkbox" id="randomPaletteToggle"><span class="slider"></span></label></div>
                </div>
                <div class="background-image-manager">
                    <div class="background-image-row">
                        <input type="file" id="dayBgImagePicker" accept="image/*" hidden>
                        <button id="uploadDayBgBtn" class="modal-button">导入日间背景</button>
                        <span id="dayBgStatus" class="status"></span>
                        <button id="clearDayBgBtn" class="modal-button delete">清除</button>
                    </div>
                    <div class="background-image-row">
                        <input type="file" id="nightBgImagePicker" accept="image/*" hidden>
                        <button id="uploadNightBgBtn" class="modal-button">导入夜间背景</button>
                        <span id="nightBgStatus" class="status"></span>
                        <button id="clearNightBgBtn" class="modal-button delete">清除</button>
                    </div>
                    <div class="background-image-row">
                        <input type="file" id="dayTitleCardBgImagePicker" accept="image/*" hidden>
                        <button id="uploadDayTitleCardBgBtn" class="modal-button">导入日间卡片</button>
                        <span id="dayTitleCardBgStatus" class="status"></span>
                        <button id="clearDayTitleCardBgBtn" class="modal-button delete">清除</button>
                    </div>
                    <div class="background-image-row">
                        <input type="file" id="nightTitleCardBgImagePicker" accept="image/*" hidden>
                        <button id="uploadNightTitleCardBgBtn" class="modal-button">导入夜间卡片</button>
                        <span id="nightTitleCardBgStatus" class="status"></span>
                        <button id="clearNightTitleCardBgBtn" class="modal-button delete">清除</button>
                    </div>
                </div>

                <!-- [新增] 全局字体管理区域 -->
                <div class="preset-manager font-manager" style="border-top: 1px solid rgba(0,0,0,0.1); padding-top: 20px; margin-top:20px;">
                    <label style="font-weight: 600; font-size: 1em; margin-bottom: 10px; display: block; text-align: left;">全局字体设置</label>
                    
                    <!-- [优化] 一行式操作布局 -->
                    <div class="preset-row">
                        <input type="text" id="fontUrlInput" class="modal-input" placeholder="输入字体文件链接 (.woff2, .ttf)" style="flex-grow: 1;">
                        <button id="applyFontBtn" class="modal-button" style="width: auto; padding: 12px 15px; flex-shrink: 0; font-size: 14px;">应用</button>
                        <button id="clearFontBtn" class="modal-button" style="width: auto; padding: 12px 15px; flex-shrink: 0; font-size: 14px; color:#889;">恢复</button>
                    </div>
                    
                    <div class="preset-row" style="margin-top: 15px;">
                        <select id="fontPresetSelector" class="modal-select" style="flex-grow: 1;"></select>
                        <button id="addFontPresetBtn" title="添加新预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">+</button>
                        <button id="updateFontPresetBtn" title="修改预设名" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">✎</button>
                        <button id="deleteFontPresetBtn" title="删除当前预设" class="modal-button delete" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">🗑</button>
                    </div>
                </div>
                <!-- [新增结束] -->

            </div>
        </div>
    </div>
    
    <!-- ===== [START] CSS HELP MODAL ===== -->
    <div class="modal-overlay" id="jelly-css-help-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group"><span>💡 悬浮球 CSS 自定义向导</span></div>
                <button class="close-btn" data-modal-id="jelly-css-help-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="css-help-section">
                    <h3>欢迎使用！</h3>
                    <p>本向导能帮助你轻松创建漂亮的自定义悬浮球CSS主题，即使你完全不懂代码也没关系。</p>
                    <p>只需按照以下步骤操作，就能让AI成为你的专属设计师。</p>
                </div>
                <div class="css-help-section">
    <h4>方案 A：自定义双环辉光悬浮球</h4>
    <p style="margin-bottom: 12px; font-size: 0.9em; color: #889;">此方案保留悬浮球默认的“内圈球体 + 外圈辉光”结构，适合进行颜色和风格的深度定制。</p>
    
    <h5 style="margin-top: 15px; margin-bottom: 5px;">AI 提示词模板 (方案 A)</h5>
    <div class="css-help-text-block" id="css-prompt-template-A">
        <button class="copy-btn">复制</button>
请为我创建一个双环辉光悬浮球的CSS主题。要求如下：<br><br>
1. <strong>整体风格描述</strong>: [例如：宇宙星云、魔法水晶、金属核心]<br>
2. <strong>内圈球体样式 (<code>#floating-jellyfish-ball</code>)</strong>:<br>
&nbsp;&nbsp;&nbsp;• 背景: [例如：深蓝色带有亮片，或紫色到蓝色的渐变]<br>
&nbsp;&nbsp;&nbsp;• 内部图标(🪼)颜色: [例如：白色]<br>
&nbsp;&nbsp;&nbsp;• 边框: [例如：1像素银色边框]<br>
3. <strong>外圈辉光样式 (<code>.jelly-ball-wrapper</code>)</strong>:<br>
&nbsp;&nbsp;&nbsp;• 辉光颜色: [例如：亮紫色]<br><br>
请为以上要求生成CSS代码。外圈辉光颜色通过修改 <code>--hold-border</code> 变量实现。
    </div>

    <h5 style="margin-top: 15px; margin-bottom: 5px;">示例：宇宙星云</h5>
    <div class="css-help-text-block" id="css-prompt-example-A">
        <button class="copy-btn">复制</button>
请为我创建一个双环辉光悬浮球的CSS主题。要求如下：<br><br>
1. <strong>整体风格描述</strong>: 宇宙星云，深邃的太空感。<br>
2. <strong>内圈球体样式 (<code>#floating-jellyfish-ball</code>)</strong>:<br>
&nbsp;&nbsp;&nbsp;• 背景: 深邃的星空背景，可以使用深蓝到黑色的渐变。<br>
&nbsp;&nbsp;&nbsp;• 内部图标(🪼)颜色: 明亮的白色，像一颗恒星。<br>
&nbsp;&nbsp;&nbsp;• 边框: 不需要边框。<br>
3. <strong>外圈辉光样式 (<code>.jelly-ball-wrapper</code>)</strong>:<br>
&nbsp;&nbsp;&nbsp;• 辉光颜色: 梦幻的紫色 (<code>#8a2be2</code>)。<br><br>
请为以上要求生成CSS代码。外圈辉光颜色通过修改 <code>--hold-border</code> 变量实现。
    </div>
</div>

<div class="css-help-section" style="margin-top: 20px;">
    <h4>方案 B：替换为自定义图标</h4>
    <p style="margin-bottom: 12px; font-size: 0.9em; color: #889;">此方案会完全隐藏默认的球体和辉光，将其替换为您指定的任意图片，适合追求极致个性化的用户。</p>
    
    <h5 style="margin-top: 15px; margin-bottom: 5px;">AI 提示词模板 (方案 B)</h5>
    <div class="css-help-text-block" id="css-prompt-template-B">
        <button class="copy-btn">复制</button>
请为我生成一段CSS代码，将悬浮球替换为自定义图片。要求如下：<br><br>
1. <strong>图片地址</strong>: [请在此处粘贴一个公开的图片URL，建议使用透明背景的.png格式图片]<br>
2. <strong>可选样式</strong>:<br>
&nbsp;&nbsp;&nbsp;• 边框: [例如：不需要边框，或 2像素金色边框]<br>
&nbsp;&nbsp;&nbsp;• 鼠标悬停效果: [例如：放大1.1倍]<br><br>
代码需要做到:<br>
&nbsp;&nbsp;&nbsp;- 隐藏原来的内外圈辉光和图标。<br>
&nbsp;&nbsp;&nbsp;- 将背景设置为我提供的图片地址。
    </div>

    <h5 style="margin-top: 15px; margin-bottom: 5px;">示例：精灵球</h5>
    <div class="css-help-text-block" id="css-prompt-example-B">
        <button class="copy-btn">复制</button>
请为我生成一段CSS代码，将悬浮球替换为自定义图片。要求如下：<br><br>
1. <strong>图片地址</strong>: <code>https://www.freeiconspng.com/uploads/pok-mon-go-pokeball-png-10.png</code><br>
2. <strong>可选样式</strong>:<br>
&nbsp;&nbsp;&nbsp;• 边框: 不需要边框。<br>
&nbsp;&nbsp;&nbsp;• 鼠标悬停效果: 旋转15度。<br><br>
代码需要做到:<br>
&nbsp;&nbsp;&nbsp;- 隐藏原来的内外圈辉光和图标。<br>
&nbsp;&nbsp;&nbsp;- 将背景设置为我提供的图片地址。
    </div>
</div>
                </div>

            </div>
        </div>
    </div>
    <!-- ===== [END] CSS HELP MODAL ===== -->

    <!-- ... 你现有的其他 modal ... -->
    <div class="modal-overlay" id="jelly-css-help-modal">
        <!-- ... CSS 帮助模态框的内容 ... -->
    </div>
    <!-- ===== [END] CSS HELP MODAL ===== -->

    <!-- =============================================================== -->
    <!-- ================ [新增] iOS 用户首次访问提示模态框 ================ -->
    <!-- =============================================================== -->
    <div class="modal-overlay" id="iosWarningModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>⚠️ iOS 用户重要提示</span></div>
            </div>
            <div class="modal-body">
                <p>尊敬的 iOS 用户，由于系统对 Web 应用沙箱（Sandbox）环境的严格限制，当您将本应用“添加到主屏幕”后，每次从后台彻底关闭应用（上划清除）都可能导致 iframe 内的项目数据被清除。</p>
                <div class="important-note">
                    <p><strong>强烈建议您在使用依赖数据保存的项目前，先进行少量操作测试，确保数据能够正常导入、导出和保存，避免重要数据意外丢失。</strong></p>
                </div>
                <p style="margin-top: 15px;">为最大程度保障数据安全，建议：</p>
                <ol style="margin-left: 20px; line-height: 1.7;">
                    <li><strong>使用“文件版”上传项目</strong>：对于您拥有源代码的项目，通过“管理项目”中的“上传项目”功能进行上传。</li>
                    <li><strong>使用浏览器打开</strong>：对于外部网站链接，在添加或编辑时，开启“在新标签页中打开”开关。项目将通过Safari等系统浏览器打开，数据由浏览器自身管理，更稳定。</li>
                </ol>
                <button id="iosWarningConfirmBtn" class="modal-button" style="margin-top: 15px;">我已了解风险</button>
            </div>
        </div>
    </div>

    <!-- ===== [START] MEMORY MODAL ===== -->
    <div class="modal-overlay" id="memoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group">
                    <span id="memory-modal-title">记忆</span>
                    <span id="memory-sync-status" style="font-size: 12px; font-weight: normal; margin-left: 8px;"></span>
                </div>
                <button class="close-btn" data-modal-id="memoryModal">&times;</button>
            </div>
            <div class="app-container" id="memoryAppContainer">
                <!-- HUB / 入口页面 -->
                <div id="hub-view" class="page active">
                    <div id="hub-view-content">
                        <button data-action="goto-memo" class="hub-btn">备忘录</button>
                        <button data-action="goto-album" class="hub-btn">相册</button>
                        <button data-action="goto-cloud" class="hub-btn">文件夹</button>
                    </div>
                </div>
                <!-- MEMO / 备忘录部分 -->
                <div id="memo-section" class="page">
                    <div id="folder-view" class="page active">
                        <div class="page-header">
                            <button data-action="back-to-hub" class="header-btn back-btn">&#10094;</button>
                            <h1 class="title">我的备忘录</h1>
                            <button data-action="toggle-memo-manage" class="header-btn manage-btn">管理</button>
                        </div>
                        <div id="folder-list-container" class="list-container"></div>
                        <button data-action="add-memo-folder" class="fab">+</button>
                        <div id="memo-management-controls" class="management-controls">
                             <button data-action="select-all-memo" class="modal-button">全选</button>
                             <button data-action="delete-selected-memo" class="modal-button" style="color:#f56565;">删除选中</button>
                        </div>
                    </div>
                    <div id="notes-view" class="page">
                        <div class="page-header">
                            <button data-action="back-to-memo-folders" class="header-btn back-btn">&#10094;</button>
                            <h1 id="notes-view-title" class="title">文件夹</h1>
                            <div class="header-controls">
                                <button data-action="toggle-note-manage" class="header-btn manage-btn">管理</button>
                            </div>
                        </div>
                        <div id="notes-list-container" class="list-container"></div>
                        <button data-action="add-note" class="fab">+</button>
                        <div id="note-management-controls" class="management-controls">
                             <button data-action="select-all-notes" class="modal-button">全选</button>
                             <button data-action="move-selected-notes" class="modal-button">移动选中</button>
                             <button data-action="delete-selected-notes" class="modal-button" style="color:#f56565;">删除选中</button>
                        </div>
                    </div>
                    <div id="note-editor-view" class="page">
                        <div class="editor-header">
                            <button data-action="cancel-note" class="editor-btn">取消</button>
                            <div>
                                <button data-action="delete-note" class="editor-btn" style="display: none;">删除</button>
                                <button data-action="save-note" class="editor-btn">完成</button>
                            </div>
                        </div>
                        <div class="editor-content">
                            <input type="text" id="note-title-input" placeholder="标题">
                            <div id="note-content-editor" contenteditable="true" placeholder="在这里输入内容..."></div>
                        </div>
                        <div class="memo-toolbar">
                            <button class="toolbar-btn" data-command="todo" title="待办清单">✓</button>
                            <div class="toolbar-separator"></div>
                            <button class="toolbar-btn" data-command="bold" title="加粗">B</button>
                            <button class="toolbar-btn" data-command="italic" title="斜体" style="font-style: italic;">I</button>
                            <button class="toolbar-btn" data-command="underline" title="下划线" style="text-decoration: underline;">U</button>
                            <button class="toolbar-btn strikethrough" data-command="strikeThrough" title="删除线">S</button>
                            <button class="toolbar-btn" data-command="createCodeBlock" title="代码块" style="margin-left: auto;">&lt;/&gt;</button>
                        </div>
                    </div>
                </div>
                <!-- ALBUM / 相册部分 -->
                <div id="album-section" class="page">
                    <div id="album-folder-view" class="page active">
                        <div class="page-header">
                            <button data-action="back-to-hub" class="header-btn back-btn">&#10094;</button>
                            <h1 class="title">我的相册</h1>
                            <div class="header-controls">
                                <button data-action="wander-global" class="header-btn wander-btn">💫</button>
                                <button data-action="toggle-album-manage" class="header-btn manage-btn">管理</button>
                            </div>
                        </div>
                        <div id="album-list-container" class="list-container"></div>
                        <button data-action="add-album-folder" class="fab">+</button>
                        <div id="album-management-controls" class="management-controls">
                             <button data-action="select-all-album" class="modal-button">全选</button>
                             <button data-action="delete-selected-album" class="modal-button" style="color:#f56565;">删除选中</button>
                        </div>
                    </div>
                    <div id="photo-grid-view" class="page">
                         <div class="page-header">
                            <button data-action="back-to-album-folders" class="header-btn back-btn">&#10094;</button>
                            <h1 id="photo-grid-title" class="title">相册</h1>
                            <div class="header-controls">
                                <button data-action="wander-local" class="header-btn wander-btn">💫</button>
                                <button data-action="toggle-photo-manage" class="header-btn manage-btn">管理</button>
                            </div>
                        </div>
                        <div id="photo-list-container" class="list-container"></div>
                        <label for="photo-uploader" data-action="add-photo" class="fab">+</label>
                        <input type="file" id="photo-uploader" multiple accept="image/*" style="display: none;">
                        <div id="photo-management-controls" class="management-controls">
                             <button data-action="select-all-photos" class="modal-button">全选</button>
                             <button data-action="move-selected-photos" class="modal-button">移动选中</button>
                             <button data-action="delete-selected-photos" class="modal-button" style="color:#f56565;">删除选中</button>
                        </div>
                    </div>
                </div>
                <!-- CLOUD DRIVE / 文件夹 -->
                <div id="cloud-drive-section" class="page">
                    <div class="page-header">
                        <button data-action="back-to-hub" class="header-btn back-btn">&#10094;</button>
                        <h1 class="title">文件夹</h1>
                        <!-- ============ [新增] Codeberg 设置入口 ============ -->
                        <div class="header-controls">
                            <button id="codebergSettingsBtn" class="header-btn" title="Codeberg 大文件存储设置" style="font-size: 22px;">&#9881;</button>
                        </div>
                        <!-- ============ [新增结束] ============ -->
                    </div>
                    <div class="list-container">
                        <select id="categorySelector" class="modal-select"></select>
                        <select id="projectSelector" class="modal-select hidden"></select>
                        <div class="file-upload-section">
                            <input type="file" id="fileUploader"/>
                            <div class="file-select-wrapper">
                                <button id="selectFileBtn" class="modal-button">选择文件</button>
                                <span id="selectedFileName" class="status-text">未选择任何文件</span>
                            </div>
                            <input type="text" id="fileNameInput" class="modal-input" placeholder="可修改文件名（可选）"/>
                            <button id="uploadBtn" class="modal-button">上传文件</button>
                            <div id="progressContainer" class="progress-container">
                                <div class="progress-bar-wrapper">
                                    <div id="uploadProgressBar" class="progress-bar"></div>
                                </div>
                                <button id="upload-cancel-btn" title="终止上传">✖</button>
                            </div>
                        </div>
                        <div id="file-list-container">
                            <ul id="fileList"></ul>
                            <div id="fileListStatus" class="file-list-status">请选择一个分类</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- 文件夹(备忘录/相册)模态框 -->
    <div id="memoryFolderModal" class="modal-overlay">
        <div class="modal-content">
            <div id="folder-modal-title" class="modal-header">新文件夹</div>
            <div class="modal-body"> <input type="text" id="folder-name-input" class="modal-input" placeholder="文件夹名称"> </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button data-action="close-folder-modal" class="modal-button">取消</button>
                <button data-action="save-folder" class="modal-button" style="color:var(--hold-border)">保存</button>
            </div>
        </div>
    </div>
    <!-- 上传照片时编辑信息模态框 -->
    <div id="memoryPhotoDetailsModal" class="modal-overlay">
        <div class="modal-content">
            <div id="photo-details-modal-title" class="modal-header">添加照片信息</div>
            <div class="modal-body">
                <div id="photoset-toggle-container">
                    <label class="header-toggle-group">
                        <input type="checkbox" id="create-photoset-toggle">
                        <span>创建照片集</span>
                    </label>
                </div>
                <img id="upload-thumbnail" src="" alt="upload thumbnail">
                <input type="text" id="photo-title-input" class="modal-input" placeholder="标题 (选填)">
                <textarea id="photo-desc-input" class="modal-textarea" placeholder="描述 (选填)"></textarea>
            </div>
            <div class="modal-footer">
                <button data-action="skip-photo-details" class="modal-button">跳过</button>
                <button data-action="save-photo-details" class="modal-button primary">保存</button>
            </div>
        </div>
    </div>

    <!-- [新增] 移动照片模态框 -->
    <div id="movePhotosModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title-group">移动到...</div>
            </div>
            <div class="modal-body">
                <select id="album-destination-selector" class="modal-select"></select>
            </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button data-action="close-move-modal" class="modal-button">取消</button>
                <button data-action="confirm-move-photos" class="modal-button" style="color:var(--hold-border)">确认移动</button>
            </div>
        </div>
    </div>
    <!-- [新增] 移动备忘录模态框 -->
    <div id="moveNotesModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title-group">移动到...</div>
            </div>
            <div class="modal-body">
                <select id="memo-destination-selector" class="modal-select"></select>
            </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button data-action="close-move-notes-modal" class="modal-button">取消</button>
                <button data-action="confirm-move-notes" class="modal-button" style="color:var(--hold-border)">确认移动</button>
            </div>
        </div>
    </div>
    <!-- ===== [END] MEMORY MODAL ===== -->

    <!-- 全屏照片查看器 -->
    <div id="memoryPhotoViewerOverlay">
        <div class="viewer-header"> 
            <span class="counter" id="viewer-counter"></span>
            <button data-action="close-viewer" class="viewer-btn">✕</button> 
        </div>
        <div class="viewer-content">
            <button data-action="prev-photo" id="prev-photo-btn" class="viewer-btn nav-arrow">&#10094;</button>
            <div id="viewer-img-container"><img id="viewer-img" src="" alt="渲染中..."></div>
            <button data-action="next-photo" id="next-photo-btn" class="viewer-btn nav-arrow">&#10095;</button>
        </div>
        <div class="viewer-footer">
            <h3 id="viewer-title"></h3>
            <p id="viewer-description"></p>
            <p id="viewer-timestamp"></p>
            <!-- [修改] 将下载按钮移动到页脚内部 -->
            <a id="download-photo-btn" title="下载图片">⇩</a>
        </div>
    </div>
    <!-- Wander View -->
    <div id="wanderViewOverlay">
        <div class="wander-header">
           <button class="close-btn" data-action="close-wander-view">&times;</button>
        </div>
        <div class="wander-main-content">
            <div class="wander-photo-container" id="wander-photo-container">
                <img id="wander-img" src="" alt="渲染中...">
                <div class="wander-info-container">
                    <h3 id="wander-title"></h3>
                    <p id="wander-description"></p>
                </div>
            </div>
        </div>
        <div class="wander-music-player" id="wander-music-player">
            <div class="player-handle-container" data-action="toggle-player-collapse"><div class="player-handle"></div></div>
            <div class="player-content">
                <div class="player-display" id="player-display-area"></div>
                <div class="player-progress-track">
                    <div class="player-progress-bar-bg"></div>
                    <div id="player-progress-bar"></div>
                    <div id="player-progress-handle"></div>
                </div>
                <div class="player-controls">
                    <button class="player-btn" id="playlist-btn" title="音乐列表"></button>
                    <button class="player-btn" id="prev-song-btn" title="上一首"></button>
                    <button class="player-btn" id="play-pause-btn" title="播放"></button>
                    <button class="player-btn" id="next-song-btn" title="下一首"></button>
                    <button class="player-btn" id="loop-mode-btn" title="列表循环"></button>
                </div>
            </div>
            <div class="player-popover" id="playlist-popover">
                <div class="popover-header">
                    <h4>播放列表</h4>
                    <button id="open-music-settings-btn" class="player-btn settings-btn"></button>
                </div>
                <ul id="popover-playlist-ul"></ul>
            </div>
        </div>
        <audio id="audio-player"></audio>
    </div>

    <!-- Music Settings Modal -->
    <div class="modal-overlay" id="musicSettingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group"><span>音乐设置</span></div>
                <button class="close-btn" data-modal-id="musicSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="toggle-section">
                    <span>进入漫游时自动播放</span>
                    <label class="toggle-switch"><input type="checkbox" id="autoplay-toggle"><span class="slider"></span></label>
                </div>
                <div class="music-upload-section">
                    <h4>上传新歌曲</h4>
                    <div class="file-select-wrapper">
                        <button id="upload-music-btn" class="modal-button">选择音乐 (.mp3)</button>
                        <span id="upload-music-status" class="status-text"></span>
                    </div>
                     <input type="text" id="music-rename-input" class="modal-input" placeholder="歌曲名称 (自动填充)">
                    <div class="file-select-wrapper">
                        <button id="upload-lrc-btn" class="modal-button">选择歌词 (.lrc)</button>
                        <span id="upload-lrc-status" class="status-text"></span>
                    </div>
                    <div class="confirm-upload-wrapper">
                        <button id="confirm-upload-btn" class="modal-button">确认上传</button>
                    </div>
                    <input type="file" id="music-file-picker" accept=".mp3" hidden>
                    <input type="file" id="lrc-file-picker" accept=".lrc" hidden>
                </div>
                <div class="music-playlist-section">
                    <h4>播放列表管理</h4>
                    <ul id="music-playlist-container"></ul>
                </div>
            </div>
        </div>
    </div>


    <!-- == Iframe Modal & Confirmation Toast == -->
    <div class="iframe-modal-overlay" id="iframeModal">
        <div id="returnConfirmationToast" class="return-toast">
            <span>返回 Jellyfish Island?</span>
            <div>
                <button id="cancelReturnBtn" class="toast-btn toast-btn-cancel">取消</button>
                <button id="confirmReturnBtn" class="toast-btn toast-btn-confirm">确认</button>
            </div>
        </div>
        <div class="iframe-modal-content">
            <iframe id="iframeContent" src="about:blank" frameborder="0" allow="fullscreen" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts allow-downloads"></iframe>
        </div>
        <div id="gestureCaptureZone"></div>
        <div class="swipe-hint" id="swipeHint"><div class="arrow"></div><span>从左侧向右滑动关闭</span></div>
    </div>
    
    <!-- Floating Project Windows Container -->
    <div id="floating-projects-container"></div>
    
       <script>
    // [新增] 字符串哈希函数，用于检测内容变更
    function simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    }


    // [新增] 非阻塞式顶部提示框函数
    function showTopToast(message, duration = 3000) {
        // 防止重复创建
        let existingToast = document.querySelector('.top-toast');
        if (existingToast) {
            existingToast.remove();
        }

        const toast = document.createElement('div');
        toast.className = 'top-toast';
        toast.textContent = message;
        document.body.appendChild(toast);

        // 触发显示动画
        setTimeout(() => {
            toast.classList.add('show');
        }, 50);

        // 在指定时间后触发隐藏动画
        setTimeout(() => {
            toast.classList.remove('show');
            // 在动画结束后从 DOM 中移除元素
            toast.addEventListener('transitionend', () => toast.remove());
        }, duration);
    }


    // [JS - V12.5.0 "Cascade Select"]
    const CURRENT_APP_VERSION = '3.7.0';
    let GITHUB_CONFIG = {}, configSha = null, isManagementMode = false, isEditingButton = false, editingButtonData = null;
    const navContainer = document.getElementById('navContainer'), pageOverlay = document.getElementById('pageOverlay');
    const syncStatusIndicator = document.getElementById('sync-status-indicator');
    const syncErrorModal = document.getElementById('syncErrorModal');
    const iframeModal = document.getElementById('iframeModal'), iframeModalContent = iframeModal.querySelector('.iframe-modal-content'), iframeEl = document.getElementById('iframeContent'), swipeHint = document.getElementById('swipeHint'), returnConfirmationToast = document.getElementById('returnConfirmationToast');
    let activeUploadXHR = null;
let activePhotoUploadXHRs = []; // [新增] 跟踪所有活跃的照片上传请求


window.addEventListener('beforeunload', (event) => {
    // [最终修正] 只检查真正跟踪后台网络请求的变量
    if (activeUploadXHR || activePhotoUploadXHRs.length > 0) {
        event.preventDefault();
        event.returnValue = '有文件正在上传，确定要离开吗？';
    }
});



    const secureFileCache = new Map();
    let currentCategory = '全部';
    let photoObserver;

const getDefaultConfig = () => ({
        title: 'Jellyfish Island',
        subtitle: '长按🌞打开工具栏 | By淡季水母',
        categories: [{ name: '全部', buttons: [] }],
        settings: {
            paginationEnabled: true,
            themeStyle: 'neumorphism', 
            jellyBall: { enabled: false, swipeBack: true, functions: {}, customCSS: '' },
            globalFont: { name: '', url: '' }, 
            fontPresets: [],
            // [新增] 备份提醒设置的默认结构 V2
            backupReminder: {
                enabled: false,
                timeBasedEnabled: false, // 定时提醒的总开关
                times: [], // 存储 "HH:MM" 格式的时间字符串
                message: '是时候该备份你的项目啦！', // 默认提醒文字
                onExit: false, // 关闭项目时提醒
                projects: [] // 需要提醒的项目href列表
            }

        },
        themePresets: [
            {
                name: "原生主题",
                colors: {
                    dayColor1: "#f5f7fa",
                    dayColor2: "#e4eaf5",
                    nightColor1: "#1f2a40",
                    nightColor2: "#16213e"
                }
            }
        ],
        lockscreenWidgets: {}
    });

    let currentConfig = getDefaultConfig();

    
    // ===== [START] FLOATING PROJECT WINDOW MANAGER =====
    const FloatingProjectWindowManager = (() => {
        const container = document.getElementById('floating-projects-container');
        let windows = {};
        const Z_INDEX_BASE = 2010;

        function create(id, title, url) {
            if (windows[id]) {
                const win = windows[id].element;
                win.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                win.style.transform = `${win.style.transform.replace(/scale$[^)]+$/, '')} scale(1.05)`;
                setTimeout(() => win.style.transform = win.style.transform.replace(/scale\([^)]+\)/, 'scale(1)'), 200);
                focus(id);
                return;
            }

            const winEl = document.createElement('div');
            winEl.className = 'floating-project-window';
            winEl.id = `fpw-${id}`;
            winEl.style.zIndex = Z_INDEX_BASE + Object.keys(windows).length;
            winEl.innerHTML = `
                <div class="fpw-header">
                    <span class="fpw-title">${title}</span>
                    <div class="fpw-controls">
                        <button class="fpw-hide" title="隐藏">－</button>
                        <button class="fpw-close" title="关闭">×</button>
                    </div>
                </div>
                <div class="fpw-content">
                    <div class="fpw-resizer"></div>
                    <iframe src="${url}" frameborder="0" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts allow-downloads"></iframe>
                </div>
            `;
            container.appendChild(winEl);

            const handleEl = document.createElement('div');
            handleEl.className = 'fpw-hide-handle';
            handleEl.id = `fpw-handle-${id}`;
            handleEl.textContent = title;
            container.appendChild(handleEl);

            windows[id] = {id, title, url, element: winEl, handle: handleEl };
            
            setTimeout(() => winEl.classList.add('visible'), 50);

            _attachEventListeners(winEl, handleEl, id);
            focus(id);
        }

        function focus(id) {
            let maxZ = Z_INDEX_BASE;
            Object.values(windows).forEach(win => {
                const currentZ = parseInt(win.element.style.zIndex);
                if (currentZ > maxZ) maxZ = currentZ;
            });

            const targetWindow = windows[id].element;
            if (parseInt(targetWindow.style.zIndex) <= maxZ) {
                targetWindow.style.zIndex = maxZ + 1;
            }
        }

// <-- 开始替换为 -->

        function _attachEventListeners(winEl, handleEl, id) {
            const header = winEl.querySelector('.fpw-header');
            const resizer = winEl.querySelector('.fpw-resizer');

            // --- Drag Logic ---
 const startDrag = (e) => {
                // Prevent drag if a button was clicked
                if (e.target.closest('button')) return;
                e.preventDefault();
                focus(id);
                const isTouchEvent = e.type === 'touchstart';
                const startClientX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                const startClientY = isTouchEvent ? e.touches[0].clientY : e.clientY;
                // --- 最终的坐标系修正：使用 getComputedStyle 来获取元素的当前位置 ---
                // getComputedStyle 读取的是渲染后的实际CSS值，与 style.left 的坐标系一致
                const computedStyle = window.getComputedStyle(winEl);
                const initialLeft = parseFloat(computedStyle.left) || 0;
                const initialTop = parseFloat(computedStyle.top) || 0;
                
                // 计算手指按下的点与元素当前位置的差值，作为拖动过程中的固定偏移量
                const offsetX = startClientX - initialLeft;
                const offsetY = startClientY - initialTop;
                const onDragMove = (moveEvent) => {
                    const moveClientX = isTouchEvent ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const moveClientY = isTouchEvent ? moveEvent.touches[0].clientY : moveEvent.clientY;
                    
                    // 新位置 = 当前手指在视口的位置 - 初始的固定偏移量
                    let newX = moveClientX - offsetX;
                    let newY = moveClientY - offsetY;
                    winEl.style.left = `${newX}px`;
                    winEl.style.top = `${newY}px`;
                };
                const onDragEnd = () => {
                    if (isTouchEvent) {
                        document.removeEventListener('touchmove', onDragMove);
                        document.removeEventListener('touchend', onDragEnd);
                    } else {
                        document.removeEventListener('mousemove', onDragMove);
                        document.removeEventListener('mouseup', onDragEnd);
                    }
                };
                if (isTouchEvent) {
                    document.addEventListener('touchmove', onDragMove, { passive: false });
                    document.addEventListener('touchend', onDragEnd);
                } else {
                    document.addEventListener('mousemove', onDragMove);
                    document.addEventListener('mouseup', onDragEnd);
                }
            };
            header.addEventListener('mousedown', startDrag);
            header.addEventListener('touchstart', startDrag, { passive: false });

            // --- Resize Logic ---
            const startResize = (e) => {
                e.preventDefault();
                const isTouchEvent = e.type === 'touchstart';
                let startX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                let startWidth = winEl.offsetWidth;
                let startHeight = winEl.offsetHeight;
                const aspectRatio = startWidth / startHeight;

                const onResizeMove = (moveEvent) => {
                    const moveClientX = isTouchEvent ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const dx = moveClientX - startX;
                    const newWidth = startWidth + dx;
                    if (newWidth >= parseFloat(winEl.style.minWidth || 250)) {
                        winEl.style.width = newWidth + 'px';
                        winEl.style.height = (newWidth / aspectRatio) + 'px';
                    }
                };

                const onResizeEnd = () => {
                     if (isTouchEvent) {
                        document.removeEventListener('touchmove', onResizeMove);
                        document.removeEventListener('touchend', onResizeEnd);
                    } else {
                        document.removeEventListener('mousemove', onResizeMove);
                        document.removeEventListener('mouseup', onResizeEnd);
                    }
                };

                if (isTouchEvent) {
                    document.addEventListener('touchmove', onResizeMove, { passive: false });
                    document.addEventListener('touchend', onResizeEnd);
                } else {
                    document.addEventListener('mousemove', onResizeMove);
                    document.addEventListener('mouseup', onResizeEnd);
                }
            };
            
            resizer.addEventListener('mousedown', startResize);
            resizer.addEventListener('touchstart', startResize, { passive: false });

            // --- Controls & Focus ---
            winEl.querySelector('.fpw-close').addEventListener('click', () => close(id));
            winEl.querySelector('.fpw-hide').addEventListener('click', () => hide(id));
            handleEl.addEventListener('click', () => show(id));
            winEl.addEventListener('mousedown', () => focus(id));
            winEl.addEventListener('touchstart', () => focus(id), { passive: true });
        }

// <-- 结束替换为 -->


                const BASE_TOP_OFFSET = 20; // 第一个标签距离屏幕顶部的距离
        const HANDLE_SPACING = 25;  // 每个标签之间的垂直间距

        /**
         * 重新计算并排列所有可见的隐藏标签位置
         */
        function _restackHandles() {
            const visibleHandles = Array.from(container.querySelectorAll('.fpw-hide-handle.visible'));
            visibleHandles.forEach((handle, index) => {
                handle.style.top = `${BASE_TOP_OFFSET + (index * HANDLE_SPACING)}px`;
            });
        }

        function hide(id) {
            const win = windows[id];
            if (!win) return;
            win.element.classList.remove('visible');
            
            setTimeout(() => {
                win.element.style.display = 'none';
                // 设置固定的基础样式
                win.handle.style.left = '0px';
                win.handle.style.borderRadius = '0 8px 8px 0';
                win.handle.classList.add('visible');
                
                // 调用新的排列函数来确定最终位置
                _restackHandles();
            }, 300);
        }

        function show(id) {
            const win = windows[id];
            if (!win) return;

            // 先隐藏标签，然后重新排列剩下的标签
            win.handle.classList.remove('visible');
            _restackHandles();

            win.element.style.display = 'flex';
            setTimeout(() => {
                win.element.classList.add('visible');
                focus(id);
            }, 50);
        }

        function close(id) {
            const win = windows[id];
            if (!win) return;
            
            // 标记标签为不可见，以便在关闭动画期间，其他标签可以先移动到位
            const wasVisible = win.handle.classList.contains('visible');
            if(wasVisible) {
                win.handle.classList.remove('visible');
            }

            win.element.classList.remove('visible');
            
            setTimeout(() => {
                win.element.remove();
                win.handle.remove();
                delete windows[id];
                
                // 只有当被关闭的窗口之前是隐藏状态时，才需要重新排列
                if (wasVisible) {
                    _restackHandles();
                }
            }, 300);
        }

        function closeAll() {
            for (const id in windows) {
                close(id);
            }
        }

        
        return { create, closeAll };
    })();
    // ===== [END] FLOATING PROJECT WINDOW MANAGER =====

    // ===== [START] FLOATING JELLYFISH BALL LOGIC (MODIFIED) =====
    const FloatingBallManager = (() => {
        let wrapper = null;
        let ball = null;
        let isDragging = false;
        let isLongPressActive = false;
        let startPos = { x: 0, y: 0 };
        let offset = { x: 0, y: 0 };
        let idleTimer = null;
        let longPressTimer = null;
        let activeMenuBtn = null;
        const LONG_PRESS_DURATION = 400; /* MODIFICATION: Shortened long-press time */
        const DRAG_THRESHOLD = 10;
        const ALL_FUNCTIONS = [
            { id: 'album', icon: '🖼️', title: '相册' },
            { id: 'folder', icon: '📁', title: '文件夹' },
            { id: 'return', icon: '🔙', title: '返回' },
            { id: 'memo', icon: '📝', title: '备忘录' },
            { id: 'quick_switch', icon: '🔗', title: '快速切换' }
        ];

        function _create() {
            if (currentConfig.settings.jellyBall?.enabled !== true) return;
            if (document.getElementById('floating-jellyfish-ball')) return;
            
            wrapper = document.createElement('div');
            wrapper.className = 'jelly-ball-wrapper';
            wrapper.innerHTML = `
                <div class="jelly-ball-glow"></div>
                <div id="floating-jellyfish-ball">
                   <span>🪼</span>
                   <div class="jelly-menu"></div>
                </div>
            `;
            document.body.appendChild(wrapper);
            ball = document.getElementById('floating-jellyfish-ball');
            
            _renderMenuButtons();
             
            let startPos = localStorage.getItem('jellyBallPosition');
            if (startPos) {
                startPos = JSON.parse(startPos);
                wrapper.style.top = `${startPos.y}px`;
                wrapper.style.left = `${startPos.x}px`;
            } else {
                wrapper.style.top = '80%';
                wrapper.style.left = '90%';
            }
            
            _addEventListeners();
            _resetIdleTimer();
        }

        function _renderMenuButtons() {
            if (!ball) return;
            const menu = ball.querySelector('.jelly-menu');
            menu.innerHTML = '';
            const enabledFunctions = _getEnabledFunctions();

            enabledFunctions.forEach(func => {
                const btnEl = document.createElement('button');
                btnEl.className = 'jelly-menu-btn';
                btnEl.innerHTML = func.icon;
                btnEl.title = func.title;
                btnEl.dataset.actionId = func.id;
                menu.appendChild(btnEl);
            });
        }
        
        function _destroy() { if (ball) { ball.parentElement.remove(); ball = null; wrapper = null; } clearTimeout(idleTimer); clearTimeout(longPressTimer); document.removeEventListener('mousemove', _onDragMove); document.removeEventListener('touchmove', _onDragMove); document.removeEventListener('mouseup', _onDragEnd); document.removeEventListener('touchend', _onDragEnd); }
        function _addEventListeners() { ball.addEventListener('mousedown', _onDragStart); ball.addEventListener('touchstart', _onDragStart, { passive: false }); document.addEventListener('click', (e) => { if (ball && !ball.contains(e.target)) _closeMenu(); }, true); }

        function _onDragStart(e) {
            if (ball.classList.contains('menu-open') && e.target.closest('.jelly-menu-btn')) return;
            e.preventDefault();
            
            clearTimeout(idleTimer);
            wrapper.classList.remove('idle', 'snap-left', 'snap-right');
            isDragging = false;
            isLongPressActive = false;
            activeMenuBtn = null;
            
            const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            startPos = { x: clientX, y: clientY };
            const rect = wrapper.getBoundingClientRect();
            offset.x = clientX - rect.left;
            offset.y = clientY - rect.top;

            longPressTimer = setTimeout(() => { isLongPressActive = true; _toggleMenu(); longPressTimer = null; }, LONG_PRESS_DURATION);
            
            document.addEventListener('mousemove', _onDragMove);
            document.addEventListener('touchmove', _onDragMove, { passive: false });
            document.addEventListener('mouseup', _onDragEnd);
            document.addEventListener('touchend', _onDragEnd);
        }

        function _onDragMove(e) {
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

            if (isLongPressActive) { _handleMenuInteraction(clientX, clientY); return; }
            const dx = clientX - startPos.x;
            const dy = clientY - startPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (!isDragging && distance > DRAG_THRESHOLD) {
                e.preventDefault();
                isDragging = true;
                if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
                ball.classList.add('dragging');
                wrapper.classList.add('dragging');
                _closeMenu();
            }

            if (isDragging) {
                e.preventDefault();
                let newX = clientX - offset.x;
                let newY = clientY - offset.y;
                const ballSize = wrapper.offsetWidth;
                newX = Math.max(0, Math.min(newX, window.innerWidth - ballSize));
                newY = Math.max(0, Math.min(newY, window.innerHeight - ballSize));
                wrapper.style.left = `${newX}px`;
                wrapper.style.top = `${newY}px`;
            }
        }
        
        function _handleMenuInteraction(clientX, clientY) { const menuBtn=document.elementFromPoint(clientX,clientY)?.closest('.jelly-menu-btn'); if(activeMenuBtn&&activeMenuBtn!==menuBtn){activeMenuBtn.classList.remove('hovered');} if(menuBtn){menuBtn.classList.add('hovered'); activeMenuBtn=menuBtn;}else{activeMenuBtn=null;} }
        
        function _onDragEnd(e) {
            clearTimeout(longPressTimer);
            if (isLongPressActive) { if (activeMenuBtn) { _onMenuClick(activeMenuBtn); } _closeMenu(); } 
            else if (!isDragging) { /* Short click, do nothing for now */ } 
            else { _snapToEdge(); }
            
            ball.classList.remove('dragging');
            wrapper.classList.remove('dragging');
            if (activeMenuBtn) activeMenuBtn.classList.remove('hovered');

            isDragging = isLongPressActive = false; activeMenuBtn = null;
            _resetIdleTimer();

            document.removeEventListener('mousemove', _onDragMove);
            document.removeEventListener('touchmove', _onDragMove);
            document.removeEventListener('mouseup', _onDragEnd);
            document.removeEventListener('touchend', _onDragEnd);
        }
        
        function _snapToEdge() { const rect=wrapper.getBoundingClientRect(); const isRight=rect.left+rect.width/2>window.innerWidth/2; wrapper.style.left=`${isRight?window.innerWidth-rect.width:0}px`; localStorage.setItem('jellyBallPosition',JSON.stringify({x:wrapper.offsetLeft,y:wrapper.offsetTop})); }
        function _resetIdleTimer() { clearTimeout(idleTimer); wrapper.classList.remove('idle','snap-left','snap-right'); idleTimer=setTimeout(()=>{const rect=wrapper.getBoundingClientRect(); wrapper.classList.add((rect.left+rect.width/2)>window.innerWidth/2?'snap-right':'snap-left','idle'); _closeMenu(); },3000); }
        function _toggleMenu() { const isOpen=ball.classList.toggle('menu-open'); const menuBtns=ball.querySelectorAll('.jelly-menu-btn'); if(isOpen){const rect=wrapper.getBoundingClientRect();const n=menuBtns.length,r=65,m=10;let s,e;const c={x:rect.left+rect.width/2,y:rect.top+rect.height/2};if(c.x<r+m){s=-Math.PI/2;e=Math.PI/2;}else if(c.x>window.innerWidth-r-m){s=Math.PI/2;e=3*Math.PI/2;}else if(c.y<r+m){s=0;e=Math.PI;}else if(c.y>window.innerHeight-r-m){s=Math.PI;e=2*Math.PI;}else{s=-Math.PI/2;e=3*Math.PI/2;} const a=n>1?(e-s)/(n-1):0; menuBtns.forEach((b,i)=>{const t=s+i*a;b.style.setProperty('--transform-end',`translate(${Math.cos(t)*r}px, ${Math.sin(t)*r}px)`);});}}
        function _closeMenu(){ if(ball&&ball.classList.contains('menu-open')) ball.classList.remove('menu-open'); }
        
        function _onMenuClick(button){
            if(!button) return;
            const actionId = button.dataset.actionId;
            const memoryModal = document.getElementById('memoryModal');
            
            function openMemoryAndSwitch(viewName) {
                MemoryApp.open();
                memoryModal.style.zIndex = '2015'; // Ensure it's above floating windows
                const closeHandler=()=>{memoryModal.style.zIndex='';memoryModal.querySelector('.close-btn').removeEventListener('click',closeHandler);};
                memoryModal.querySelector('.close-btn').addEventListener('click',closeHandler,{once:true});
                memoryModal.querySelector(`[data-action="goto-${viewName}"]`)?.click();
            }

            switch(actionId) {
                case 'album': openMemoryAndSwitch('album'); break;
                case 'memo': openMemoryAndSwitch('memo'); break;
                case 'folder': openMemoryAndSwitch('cloud'); break;
                case 'return':
                    if (iframeModal.classList.contains('active')) {
                        // ★ 新增：在这里同样触发退出提醒
                        BackupReminderManager.triggerOnExitReminder();
                        closeIframeModal();
                    }
                    break;
                case 'quick_switch': _showQuickSwitchMenu(); break;
            }
            _closeMenu();
        }


        function _showQuickSwitchMenu() {
            let existingMenu = document.getElementById('quick-switch-menu-overlay');
            if(existingMenu) existingMenu.remove();

            const overlay = document.createElement('div');
            overlay.id = 'quick-switch-menu-overlay';
            overlay.className = 'page-overlay show';
            overlay.style.zIndex = '9997';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            
            const menuContainer = document.createElement('div');
            menuContainer.id = 'quick-switch-menu';
            menuContainer.className = 'modal-content';
            menuContainer.style.maxWidth = '320px';
            menuContainer.style.maxHeight = '400px';

            menuContainer.innerHTML = `
                <div class="modal-header" style="padding-bottom: 10px; margin-bottom: 10px;">
                    <div class="modal-title-group">快速切换</div>
                    <button class="close-btn" style="width:30px; height:30px; font-size:20px;">&times;</button>
                </div>
                <div class="modal-body" style="gap: 12px; padding-bottom: 10px;">
                    <select id="qs-category-select" class="modal-select">
                        <option value="">-- 请选择分类 --</option>
                    </select>
                    <select id="qs-project-select" class="modal-select" disabled>
                        <option value="">-- 请选择项目 --</option>
                    </select>
                    <div id="qs-actions" style="display:none; justify-content: space-around; gap: 10px; margin-top: 10px;">
                        <button id="qs-open-float" class="modal-button" style="flex:1;">悬浮窗</button>
                        <button id="qs-open-full" class="modal-button" style="flex:1;">全屏</button>
                    </div>
                </div>
            `;
            
            overlay.appendChild(menuContainer);
            document.body.appendChild(overlay);

            const categorySelect = menuContainer.querySelector('#qs-category-select');
            const projectSelect = menuContainer.querySelector('#qs-project-select');
            const actionsDiv = menuContainer.querySelector('#qs-actions');
            
            currentConfig.categories.forEach(cat => {
                categorySelect.innerHTML += `<option value="${cat.name}">${cat.name}</option>`;
            });

            categorySelect.onchange = () => {
                projectSelect.innerHTML = '<option value="">-- 请选择项目 --</option>';
                projectSelect.disabled = true;
                actionsDiv.style.display = 'none';
                const catName = categorySelect.value;
                if (!catName) return;

                const category = currentConfig.categories.find(c => c.name === catName);
                if (category && category.buttons.length > 0) {
                     category.buttons.forEach(btn => {
                        projectSelect.innerHTML += `<option value="${btn.href}" data-text="${btn.text}">${btn.text}</option>`;
                     });
                     projectSelect.disabled = false;
                }
            };
            
            let selectedProject = null;
            projectSelect.onchange = () => {
                const selectedOption = projectSelect.options[projectSelect.selectedIndex];
                if (projectSelect.value) {
                    selectedProject = { url: selectedOption.value, title: selectedOption.dataset.text };
                    actionsDiv.style.display = 'flex';
                } else {
                    selectedProject = null;
                    actionsDiv.style.display = 'none';
                }
            };
            
            const closeMenu = () => { document.body.removeChild(overlay); };
            overlay.onclick = (e) => { if (e.target === overlay) closeMenu(); };
            menuContainer.querySelector('.close-btn').onclick = closeMenu;
            
            menuContainer.querySelector('#qs-open-float').onclick = () => {
                if(selectedProject) FloatingProjectWindowManager.create(Date.now(), selectedProject.title, selectedProject.url);
                closeMenu();
            };
            menuContainer.querySelector('#qs-open-full').onclick = () => {
                if(selectedProject) openIframeModal(selectedProject.url);
                closeMenu();
            };
        }


        function _getEnabledFunctions() { const settings=currentConfig.settings.jellyBall?.functions||{}; return ALL_FUNCTIONS.filter(func=>settings[func.id]!==false); }

         function initSettings() {
            const toggle = document.getElementById('jellyBallToggle');
            const settingsEntry = document.getElementById('jellyBallSettingsEntry');
            const openSettingsBtn = document.getElementById('openJellyBallSettingsBtn');
            const customStyleTag = document.getElementById('custom-jelly-ball-styles');

            // 确保配置对象存在
            if (!currentConfig.settings.jellyBall) {
                currentConfig.settings.jellyBall = { enabled: false, swipeBack: true, functions: {}, customCSS: '' };
            }
            const settings = currentConfig.settings.jellyBall;
            
             // 动态创建悬浮球设置窗口 (V3, 简洁UI版)
            function openJellyBallSettingsWindow() {
                const modalId = 'jelly-ball-settings-modal';
                
                const modalOverlay = document.createElement('div');
                modalOverlay.id = modalId;
                modalOverlay.className = 'modal-overlay show';
                modalOverlay.style.zIndex = '1002';

                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                
                modalContent.innerHTML = `
                    <div class="modal-header">
                        <div class="modal-title-group"><span>悬浮球设置</span></div>
                        <button class="close-btn">&times;</button>
                    </div>
                    <div class="modal-body" id="jelly-ball-options-container" style="display: flex; flex-direction: column; gap: 15px;">
                        <div class="toggle-section">
                            <span>启用左滑返回 (应用内网页)</span>
                            <label class="toggle-switch"><input type="checkbox" id="jellySwipeBackToggle"><span class="slider"></span></label>
                        </div>
                        <div class="toggle-section">
                            <span>每次启动时随机应用预设</span>
                            <label class="toggle-switch"><input type="checkbox" id="jellyRandomCssToggle"><span class="slider"></span></label>
                        </div>
                        <div class="toggle-section" style="flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                            <label style="font-size: 14px; color: #5a6778; font-weight: 600;">自定义功能</label>
                            <div id="jelly-function-checkboxes" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px 15px; width: 100%;"></div>
                        </div>
                        <div class="toggle-section" style="flex-direction: column; align-items: flex-start; gap: 10px;">
                            <label for="jellyBallCssTextarea" style="font-size: 14px; color: #5a6778; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                <span>自定义CSS</span>
                                <button id="show-jelly-css-help" style="background:none; border:none; font-size: 20px; cursor:pointer; padding:0; line-height: 1;" title="CSS提示词向导">💡</button>
                            </label>
                            <!-- ★ 修改：全新简洁的预设管理UI ★ -->
                            <div class="preset-row" style="width:100%;">
                                <select id="jellyCssPresetSelector" class="modal-select" style="flex-grow: 1;"></select>
                                <button id="addJellyCssPresetBtn" title="添加新预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">+</button>
                                <button id="editJellyCssPresetBtn" title="修改当前预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">✎</button>
                                <button id="deleteJellyCssPresetBtn" title="删除当前预设" class="modal-button delete" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">🗑</button>
                            </div>
                            <div style="display: flex; gap: 15px; width:100%; align-items: center;">
                                <textarea id="jellyBallCssTextarea" class="modal-textarea" rows="5" placeholder="在此粘贴CSS代码，或清空以恢复默认样式" style="flex: 1;"></textarea>
                                <div id="jelly-css-preview-container">
                                    <div class="jelly-ball-wrapper">
                                        <div class="jelly-ball-glow"></div>
                                        <div id="floating-jellyfish-ball"><span>🪼</span></div>
                                    </div>
                                </div>
                            </div>
                            <button id="applyJellyBallCssBtn" class="modal-button" style="width: 100%;">应用并保存样式</button>
                        </div>
                    </div>
                `;
                
                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);

                // UI元素获取
                const closeBtn = modalContent.querySelector('.close-btn');
                const swipeBackToggle = modalContent.querySelector('#jellySwipeBackToggle');
                const randomCssToggle = modalContent.querySelector('#jellyRandomCssToggle');
                const checkboxContainer = modalContent.querySelector('#jelly-function-checkboxes');
                const cssTextarea = modalContent.querySelector('#jellyBallCssTextarea');
                const applyCssBtn = modalContent.querySelector('#applyJellyBallCssBtn');
                const previewWrapper = modalContent.querySelector('#jelly-css-preview-container .jelly-ball-wrapper');
                
                // ★ 修改：获取新的预设UI元素
                const presetSelector = modalContent.querySelector('#jellyCssPresetSelector');
                const addPresetBtn = modalContent.querySelector('#addJellyCssPresetBtn');
                const editPresetBtn = modalContent.querySelector('#editJellyCssPresetBtn');
                const deletePresetBtn = modalContent.querySelector('#deleteJellyCssPresetBtn');
                
                // 初始化
                if (!settings.cssPresets) settings.cssPresets = [];
                
                const closeModal = () => { modalOverlay.classList.remove('show'); modalOverlay.addEventListener('transitionend', () => modalOverlay.remove(), { once: true }); };
                closeBtn.onclick = closeModal;
                modalOverlay.onclick = (e) => { if (e.target === modalOverlay) closeModal(); };

                // 填充UI
                swipeBackToggle.checked = settings.swipeBack !== false;
                randomCssToggle.checked = localStorage.getItem('jellyRandomCssEnabled') === 'true';
                checkboxContainer.innerHTML = '';
                ALL_FUNCTIONS.forEach(func => {
                    const isChecked = settings.functions?.[func.id] !== false;
                    checkboxContainer.innerHTML += `<div style="display:flex;justify-content:space-between;align-items:center;"><label for="jelly_func_${func.id}" style="cursor:pointer;">${func.icon} ${func.title}</label><label class="toggle-switch"><input type="checkbox" id="jelly_func_${func.id}" data-function-id="${func.id}" ${isChecked?'checked':''}><span class="slider"></span></label></div>`;
                });
                cssTextarea.value = settings.customCSS || '';

                function populateCssPresetDropdown() {
                    const currentVal = presetSelector.value;
                    presetSelector.innerHTML = '<option value="">选择或管理预设...</option>';
                    settings.cssPresets.forEach((preset, index) => {
                        presetSelector.innerHTML += `<option value="${index}">${preset.name}</option>`;
                    });
                    if(currentVal) presetSelector.value = currentVal;
                }
                populateCssPresetDropdown();

                function updatePreview() { /* ... (此函数保持不变) ... */ }
                updatePreview(); // 省略了预览函数的代码，因为它无需改动

                // 事件监听 (通用部分)
                cssTextarea.addEventListener('input', updatePreview);
                swipeBackToggle.addEventListener('change', () => { settings.swipeBack = swipeBackToggle.checked; saveGlobalConfig('Update Jellyfish Ball settings'); });
                randomCssToggle.addEventListener('change', () => { localStorage.setItem('jellyRandomCssEnabled', randomCssToggle.checked); });
                checkboxContainer.addEventListener('change', e => { if (e.target.dataset.functionId) { if (!settings.functions) settings.functions = {}; settings.functions[e.target.dataset.functionId] = e.target.checked; _renderMenuButtons(); saveGlobalConfig('Update Jellyfish Ball settings'); } });
                applyCssBtn.addEventListener('click', () => { settings.customCSS = cssTextarea.value; customStyleTag.innerHTML = settings.customCSS; if(ball) { _destroy(); _create(); } saveGlobalConfig('Update Jellyfish Ball CSS'); showTopToast('自定义样式已应用！', 2000); });
                modalContent.querySelector('#show-jelly-css-help').addEventListener('click', () => document.getElementById('jelly-css-help-modal').classList.add('show'));

                // ★ 新增：修改预设的弹窗函数 ★
                function _createModifyPresetModal(preset, index) {
                    const editModal = document.createElement('div');
                    editModal.className = 'modal-overlay show';
                    editModal.style.zIndex = '1003';
                    editModal.innerHTML = `
                        <div class="modal-content" style="max-width: 400px;">
                            <div class="modal-header"><div class="modal-title-group">修改预设</div><button class="close-edit-btn">&times;</button></div>
                            <div class="modal-body" style="gap: 15px;">
                                <input type="text" id="editPresetName" class="modal-input" value="${preset.name}">
                                <textarea id="editPresetCss" class="modal-textarea" rows="8">${preset.css}</textarea>
                                <button id="saveEditBtn" class="modal-button">保存更改</button>
                            </div>
                        </div>`;
                    document.body.appendChild(editModal);
                    const closeEditModal = () => editModal.remove();
                    editModal.querySelector('.close-edit-btn').onclick = closeEditModal;
                    editModal.onclick = (e) => { if(e.target === editModal) closeEditModal(); };

                    editModal.querySelector('#saveEditBtn').onclick = () => {
                        const newName = editModal.querySelector('#editPresetName').value.trim();
                        const newCss = editModal.querySelector('#editPresetCss').value;
                        if (!newName) return alert('预设名称不能为空');
                        if (newName !== preset.name && settings.cssPresets.some(p => p.name === newName)) {
                            return alert('该预设名称已存在');
                        }
                        settings.cssPresets[index] = { name: newName, css: newCss };
                        saveGlobalConfig(`Update Jelly CSS preset: ${newName}`);
                        populateCssPresetDropdown();
                        presetSelector.value = index;
                        cssTextarea.value = newCss;
                        updatePreview();
                        closeEditModal();
                    };
                }

                // ★ 修改：简洁版预设管理事件监听 ★
                addPresetBtn.addEventListener('click', () => {
                    const name = prompt('请输入新预设的名称：');
                    if (!name || name.trim() === '') return;
                    if (settings.cssPresets.some(p => p.name === name.trim())) return alert('预设名称已存在');
                    settings.cssPresets.push({ name: name.trim(), css: cssTextarea.value });
                    saveGlobalConfig(`Save Jelly CSS preset: ${name.trim()}`);
                    populateCssPresetDropdown();
                    presetSelector.value = settings.cssPresets.length - 1;
                });
                
                editPresetBtn.addEventListener('click', () => {
                    const index = presetSelector.value;
                    if (index === '') return alert('请先从下拉框中选择一个要修改的预设');
                    _createModifyPresetModal(settings.cssPresets[index], index);
                });

                deletePresetBtn.addEventListener('click', () => {
                    const index = presetSelector.value;
                    if (index === '') return alert('请先从下拉框中选择一个要删除的预设');
                    const presetName = settings.cssPresets[index].name;
                    if (!confirm(`确定要删除预设 "${presetName}" 吗？`)) return;
                    settings.cssPresets.splice(index, 1);
                    saveGlobalConfig(`Delete Jelly CSS preset: ${presetName}`);
                    populateCssPresetDropdown();
                    cssTextarea.value = settings.customCSS || '';
                    updatePreview();
                });
                
                presetSelector.addEventListener('change', () => {
                    const index = presetSelector.value;
                    if (index === '') {
                        cssTextarea.value = settings.customCSS || '';
                    } else {
                        cssTextarea.value = settings.cssPresets[index].css;
                    }
                    updatePreview();
                });
            }




            // 主开关的UI和逻辑控制
            const updateUIVisibility = () => {
                settingsEntry.style.display = toggle.checked ? 'block' : 'none';
            };
            
            toggle.checked = settings.enabled || false;
            customStyleTag.innerHTML = settings.customCSS || ''; // 初始加载CSS

            toggle.addEventListener('change', () => {
                settings.enabled = toggle.checked;
                updateUIVisibility();
                if (settings.enabled) _create(); else _destroy();
                saveGlobalConfig('Toggle Jellyfish Ball');
            });

            openSettingsBtn.addEventListener('click', openJellyBallSettingsWindow);
            
            updateUIVisibility();
        }


        return { init: initSettings, create: _create, destroy: _destroy };
    })();
    // ===== [END] FLOATING JELLYFISH BALL LOGIC =====
        /* =============================================================== */
        /* ============== [最终修正] 备份提醒功能管理器 V3.0 =============== */
        /* =============================================================== */
        const BackupReminderManager = (() => {
            // [核心修改1] 将 ui 对象声明为空，延迟初始化
            let ui = {}; 
            let activeTimers = [];

            // [核心修改2] 新增一个专门用于获取DOM元素的函数
            function initUI() {
                ui = {
                    // 入口
                    toggle: document.getElementById('backupReminderToggle'),
                    settingsEntry: document.getElementById('backupSettingsEntry'),
                    openSettingsBtn: document.getElementById('openBackupSettingsBtn'),
                    // 设置弹窗 V2
                    modal: document.getElementById('backupReminderSettingsModal'),
                    timeBasedToggle: document.getElementById('backupTimeBasedToggle'),
                    timeContainer: document.getElementById('backupTimeContainer'),
                    timeListContainer: document.getElementById('backupTimeListContainer'),
                    messageTextarea: document.getElementById('backupMessageTextarea'),
                    onExitToggle: document.getElementById('backupOnExitToggle'),
                    projectsSection: document.getElementById('backupProjectsSection'),
                    projectList: document.getElementById('backupProjectList'),
                    saveBtn: document.getElementById('saveBackupSettingsBtn'),
                };
            }

            function getSettings() {
                if (!currentConfig.settings.backupReminder) {
                    currentConfig.settings.backupReminder = getDefaultConfig().settings.backupReminder;
                }
                return currentConfig.settings.backupReminder;
            }
            
            function renderTimeRows(times = []) {
                ui.timeListContainer.innerHTML = '';
                if (times.length > 0) {
                    times.forEach(time => addTimeRow(time));
                } else {
                    addTimeRow();
                }
            }

            function addTimeRow(timeValue = '') {
                const row = document.createElement('div');
                row.className = 'time-input-row';
                row.innerHTML = `
                    <input type="time" class="modal-input" value="${timeValue}">
                    <button class="time-action-btn add" title="添加新一行">+</button>
                    <button class="time-action-btn remove" title="删除此行">-</button>
                `;
                row.querySelector('.add').addEventListener('click', () => addTimeRow());
                row.querySelector('.remove').addEventListener('click', (e) => {
                    if (ui.timeListContainer.childElementCount <= 1) {
                         e.currentTarget.parentElement.querySelector('input[type="time"]').value = '';
                    } else {
                         e.currentTarget.parentElement.remove();
                    }
                });
                ui.timeListContainer.appendChild(row);
            }

            function renderProjectList() {
                ui.projectList.innerHTML = '';
                const reminderSettings = getSettings();
                const allButtons = currentConfig.categories.flatMap(c => c.buttons);
                const uniqueButtons = Array.from(new Map(allButtons.map(item => [item.href, item])).values());
                if (uniqueButtons.length === 0) {
                    ui.projectList.innerHTML = '<p style="color: #889; text-align: center;">暂无项目</p>';
                    return;
                }
                uniqueButtons.forEach(btn => {
                    const isChecked = reminderSettings.projects.includes(btn.href);
                    const itemHtml = `<label class="project-checkbox-item"><input type="checkbox" data-href="${btn.href}" ${isChecked ? 'checked' : ''}><span>${btn.text}</span></label>`;
                    ui.projectList.innerHTML += itemHtml;
                });
            }

            function populateSettingsModal() {
                const settings = getSettings();
                ui.messageTextarea.value = settings.message;
                ui.timeBasedToggle.checked = settings.timeBasedEnabled;
                ui.timeContainer.style.display = settings.timeBasedEnabled ? 'flex' : 'none';
                renderTimeRows(settings.times);
                ui.onExitToggle.checked = settings.onExit;
                ui.projectsSection.style.display = settings.onExit ? 'block' : 'none';
                renderProjectList();
            }

            function openSettingsModal() {
                populateSettingsModal();
                ui.modal.classList.add('show');
            }

            function saveSettings() {
                const times = Array.from(ui.timeListContainer.querySelectorAll('.time-input-row input[type="time"]'))
                                .map(input => input.value)
                                .filter(Boolean);

                const newSettings = {
                    enabled: getSettings().enabled,
                    timeBasedEnabled: ui.timeBasedToggle.checked,
                    times: [...new Set(times)],
                    message: ui.messageTextarea.value.trim() || '是时候该备份你的项目啦！',
                    onExit: ui.onExitToggle.checked,
                    projects: Array.from(ui.projectList.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.dataset.href)
                };

                currentConfig.settings.backupReminder = newSettings;
                saveGlobalConfig('Update backup reminder settings');
                startTimers();
                ui.modal.classList.remove('show');
                showTopToast('备份提醒设置已保存！', 2000);
            }
            
            function clearTimers() {
                activeTimers.forEach(timerId => clearTimeout(timerId));
                activeTimers = [];
            }

            function startTimers() {
                clearTimers();
                const settings = getSettings();
                if (!settings.enabled || !settings.timeBasedEnabled || settings.times.length === 0) return;
                const now = new Date();
                settings.times.forEach(timeStr => {
                    const [hours, minutes] = timeStr.split(':').map(Number);
                    let reminderTime = new Date();
                    reminderTime.setHours(hours, minutes, 0, 0);
                    if (reminderTime < now) reminderTime.setDate(reminderTime.getDate() + 1);
                    const delay = reminderTime.getTime() - now.getTime();
                    const createReminder = () => {
                        showTopToast(settings.message);
                        activeTimers.push(setTimeout(createReminder, 24 * 60 * 60 * 1000));
                    };
                    activeTimers.push(setTimeout(createReminder, delay));
                });
            }

            function triggerOnExitReminder() {
                const settings = getSettings();
                if (!settings.enabled || !settings.onExit) return;
                const originalUrl = iframeModal.dataset.originalUrl;
                if (!originalUrl) return;
                const targetProjects = settings.projects;
                if (targetProjects.length === 0 || targetProjects.includes(originalUrl)) {
                    showTopToast(settings.message);
                }
            }

            // [核心修改3] init 函数现在只负责绑定事件监听器
            function init() {
                const initialSettings = getSettings();
                ui.toggle.checked = initialSettings.enabled;
                ui.settingsEntry.style.display = initialSettings.enabled ? 'block' : 'none';

                ui.toggle.addEventListener('change', () => {
                    const settings = getSettings();
                    settings.enabled = ui.toggle.checked;
                    ui.settingsEntry.style.display = settings.enabled ? 'block' : 'none';
                    saveGlobalConfig('Toggle backup reminder');
                    if (settings.enabled) startTimers(); else clearTimers();
                });

                ui.openSettingsBtn.addEventListener('click', openSettingsModal);
                ui.timeBasedToggle.addEventListener('change', () => {
                    ui.timeContainer.style.display = ui.timeBasedToggle.checked ? 'flex' : 'none';
                });
                ui.onExitToggle.addEventListener('change', () => {
                    ui.projectsSection.style.display = ui.onExitToggle.checked ? 'block' : 'none';
                });
                ui.saveBtn.addEventListener('click', saveSettings);

                startTimers();
            }

            // [核心修改4] 导出 initUI 和 init
            return {
                init,
                initUI,
                triggerOnExitReminder
            };

        })();
    /* =============================================================== */
    /* ============== [新增] Codeberg 管理器 V1.1 (修正版) ========== */
    /* =============================================================== */
    const CodebergManager = (() => {
        // [⚠️ 重要] 请在此处填写你在 Codeberg 申请的客户端 ID
        const CLIENT_ID = '44041218-171a-40d1-b8ab-206d5ff4eb75';
        const REDIRECT_URI = window.location.origin + window.location.pathname;
        const STORAGE_KEY_ACCOUNTS = 'codeberg_accounts';
        const STORAGE_KEY_ACTIVE = 'codeberg_active_account_username';

        // [核心修正] 将 ui 对象声明为一个空对象，延迟初始化
        let ui = {};

        // --- 内部辅助函数 ---
        const _getAccounts = () => JSON.parse(localStorage.getItem(STORAGE_KEY_ACCOUNTS)) || [];
        const _saveAccounts = (accounts) => localStorage.setItem(STORAGE_KEY_ACCOUNTS, JSON.stringify(accounts));
        const _getActiveUser = () => localStorage.getItem(STORAGE_KEY_ACTIVE);
        const _setActiveUser = (username) => localStorage.setItem(STORAGE_KEY_ACTIVE, username);

        const _generateRandomString = (length) => {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
            let result = '';
            const randomValues = new Uint8Array(length);
            window.crypto.getRandomValues(randomValues);
            for (let i = 0; i < length; i++) {
                result += chars[randomValues[i] % chars.length];
            }
            return result;
        };

        const _generateCodeVerifier = () => _generateRandomString(128);

        async function _generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            return window.btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        // --- UI 渲染函数 ---
        function _renderActiveAccount() {
            const activeUser = _getActiveUser();
            const accounts = _getAccounts();
            const activeAccount = accounts.find(acc => acc.username === activeUser);

            if (activeAccount) {
                ui.activeAccountDisplay.textContent = activeAccount.username;
                ui.activeAccountDisplay.classList.remove('inactive');
                ui.activeAccountDisplay.classList.add('active');
            } else {
                ui.activeAccountDisplay.textContent = '未连接';
                ui.activeAccountDisplay.classList.add('inactive');
                ui.activeAccountDisplay.classList.remove('active');
            }
        }

        function _renderAuthorizedList() {
            const accounts = _getAccounts();
            const activeUser = _getActiveUser();
            ui.authorizedList.innerHTML = ''; // 清空列表

            if (accounts.length === 0) {
                ui.authorizedList.innerHTML = '<div class="codeberg-empty-list">暂无已授权的账户</div>';
                return;
            }

            accounts.forEach(account => {
                const item = document.createElement('div');
                item.className = 'codeberg-account-item';
                const isActive = account.username === activeUser;

                item.innerHTML = `
                    <span>${account.username}</span>
                    <div class="account-actions">
                        ${isActive ? '' : '<button class="modal-button" data-action="set-active">设为活动</button>'}
                        <button class="modal-button" data-action="delete" style="color: #e53e3e;">删除</button>
                    </div>
                `;
                item.querySelector('[data-action="delete"]').addEventListener('click', () => _handleAccountDelete(account.username));
                if (!isActive) {
                    item.querySelector('[data-action="set-active"]').addEventListener('click', () => _handleAccountSwitch(account.username));
                }
                ui.authorizedList.appendChild(item);
            });
        }
        
        function _renderAll() {
            _renderActiveAccount();
            _renderAuthorizedList();
        }

        // --- 事件处理与逻辑 ---
        async function _handleAuthorizeClick() {
            if (CLIENT_ID.startsWith('在此处')) {
                alert('开发者尚未配置 Codeberg 客户端 ID！');
                return;
            }
            const state = _generateRandomString(43);
            sessionStorage.setItem('codeberg_oauth_state', state);
            const codeVerifier = _generateCodeVerifier();
            sessionStorage.setItem('codeberg_code_verifier', codeVerifier);
            const codeChallenge = await _generateCodeChallenge(codeVerifier);
            const params = new URLSearchParams({
                client_id: CLIENT_ID,
                redirect_uri: REDIRECT_URI,
                response_type: 'code',
                scope: 'repository',
                state: state,
                code_challenge: codeChallenge,
                code_challenge_method: 'S256',
            });
            window.location.href = `https://codeberg.org/login/oauth/authorize?${params.toString()}`;
        }
        
        async function _handleOAuthCallback(code, state) {
            const savedState = sessionStorage.getItem('codeberg_oauth_state');
            const codeVerifier = sessionStorage.getItem('codeberg_code_verifier');
            sessionStorage.removeItem('codeberg_oauth_state');
            sessionStorage.removeItem('codeberg_code_verifier');
            if (!savedState || savedState !== state) { alert('OAuth 状态校验失败，请重试。'); return; }
            if (!codeVerifier) { alert('OAuth code_verifier 丢失，请重试。'); return; }
            try {
                const tokenResponse = await fetch('https://codeberg.org/login/oauth/access_token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({ client_id: CLIENT_ID, grant_type: 'authorization_code', code: code, redirect_uri: REDIRECT_URI, code_verifier: codeVerifier }),
                });
                if (!tokenResponse.ok) throw new Error(`获取 Token 失败: ${tokenResponse.statusText}`);
                const tokenData = await tokenResponse.json();
                const userResponse = await fetch('https://codeberg.org/api/v1/user', { headers: { 'Authorization': `token ${tokenData.access_token}` } });
                if (!userResponse.ok) throw new Error(`获取用户信息失败: ${userResponse.statusText}`);
                const userData = await userResponse.json();
                const username = userData.login;
                let accounts = _getAccounts();
                const existingAccountIndex = accounts.findIndex(acc => acc.username === username);
                const newAccount = { username, accessToken: tokenData.access_token };
                if (existingAccountIndex > -1) { accounts[existingAccountIndex] = newAccount; } 
                else { accounts.push(newAccount); }
                _saveAccounts(accounts);
                _setActiveUser(username);
                showTopToast(`Codeberg 账户 "${username}" 已成功连接！`, 3000);
            } catch (error) {
                console.error("Codeberg OAuth 处理失败:", error);
                alert(`Codeberg 认证失败: ${error.message}`);
            }
        }
        
        function _handleAccountDelete(username) {
            if (!confirm(`确定要删除账户 "${username}" 吗？此操作将移除应用的授权。`)) return;
            let accounts = _getAccounts();
            accounts = accounts.filter(acc => acc.username !== username);
            _saveAccounts(accounts);
            if (_getActiveUser() === username) {
                _setActiveUser(accounts.length > 0 ? accounts[0].username : '');
            }
            _renderAll();
            showTopToast(`账户 "${username}" 已删除。`, 2000);
        }

        function _handleAccountSwitch(username) {
            _setActiveUser(username);
            _renderAll();
            // 在切换后，立刻刷新当前项目的文件列表
            if (document.getElementById('memoryModal').classList.contains('show') && 
                document.getElementById('cloud-drive-section').classList.contains('active'))
            {
                showTopToast(`活动账户已切换为 "${username}"，正在刷新文件列表...`, 2000);
                setTimeout(MemoryApp.fetchFilesForSelectedProject, 100);
            } else {
                 showTopToast(`活动账户已切换为 "${username}"。`, 2000);
            }
        }

        // --- 公开接口 ---
        return {
            getActiveAccount: () => {
                const activeUser = _getActiveUser();
                if (!activeUser) return null;
                return _getAccounts().find(acc => acc.username === activeUser) || null;
            },
            init: async () => {
                // [核心修正] 在 init 函数内部进行 UI 元素的选择，确保DOM已加载
                ui = {
                    modal: document.getElementById('codebergSettingsModal'),
                    openBtn: document.getElementById('codebergSettingsBtn'),
                    addAccountBtn: document.getElementById('add-codeberg-account-btn'),
                    activeAccountDisplay: document.getElementById('codeberg-active-account-display'),
                    authorizedList: document.getElementById('codeberg-authorized-list'),
                };
                
                if (!ui.openBtn) { console.error("CodebergManager: openBtn not found!"); return; }

                ui.openBtn.addEventListener('click', () => {
                    _renderAll();
                    ui.modal.classList.add('show');
                });
                ui.addAccountBtn.addEventListener('click', (e) => { e.preventDefault(); _handleAuthorizeClick(); });
                
                const params = new URLSearchParams(window.location.search);
                const code = params.get('code');
                const state = params.get('state');
                if (code && state) {
                    document.getElementById('memoryModal').classList.add('show');
                    document.querySelector('[data-action="goto-cloud"]').click();
                    await _handleOAuthCallback(code, state);
                    const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                    setTimeout(() => { _renderAll(); ui.modal.classList.add('show'); }, 300);
                }
            },
        };
    })();


    /* =============================================================== */
    /* ========================= [新增结束] ========================== */
    /* =============================================================== */


    const utf8_to_b64 = (str) => btoa(unescape(encodeURIComponent(str)));
    const b64_to_utf8 = (str) => decodeURIComponent(escape(atob(str)));

    function b64toBlob(b64Data, contentType = '', sliceSize = 512) {
        contentType = contentType || 'application/octet-stream';
        const byteCharacters = atob(b64Data);
        const byteArrays = [];
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            const slice = byteCharacters.slice(offset, offset + sliceSize);
            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        return new Blob(byteArrays, { type: contentType });
    }

    async function handleApiError(context, error) {
        let userMessage = `${context}失败，请稍后重试。`;
        const errorString = error.message || String(error);

        try {
            const errorJson = JSON.parse(errorString.substring(errorString.indexOf('{')));
            if (errorJson.message) {
                if (errorJson.message.includes("Not Found")) {
                    userMessage = `${context}失败：找不到目标文件或路径。请检查您的仓库配置和路径是否正确。`;
                } else if (errorJson.message.includes("Bad credentials")) {
                    userMessage = `认证失败：您的 Personal Access Token 无效或已过期。`;
                } else if (errorJson.message.includes("requires authentication")) {
                    userMessage = `认证失败：此操作需要有效的 Personal Access Token。`;
                } else if (errorJson.message.includes("sha doesn't match")) {
                    userMessage = `同步冲突：云端数据已被更新，请使用“手动同步与修复”功能后再试。`;
                } else if (errorJson.message.includes("path exists")) {
                    userMessage = `${context}失败：云端已存在同名文件或文件夹。`;
                } else {
                     userMessage = `${context}失败：${errorJson.message}`;
                }
            }
        } catch (e) {
            if (errorString.includes('401') || errorString.includes('403')) {
                userMessage = `认证失败：请检查您的 Personal Access Token 是否正确且拥有 'repo' 权限。`;
            } else if (errorString.includes('404')) {
                userMessage = `${context}失败：找不到对应的文件或仓库。请检查您的仓库配置是否正确。`;
            } else if (errorString.toLowerCase().includes('failed to fetch') || errorString.toLowerCase().includes('networkerror')) {
                userMessage = '网络连接失败，请检查您的网络并重试。';
            } else if (errorString.includes('rate limit exceeded')) {
                userMessage = 'API请求频率过高，请稍等片刻再试。';
            }
        }
        
        console.error(`API Error in context "${context}":`, error);
        return userMessage;
    }

    let syncStatusTimeout;
    function updateSyncStatus(status, message = '') {
        syncStatusIndicator.className = status;
        syncStatusIndicator.title = message || `云同步状态: ${status}`;
        clearTimeout(syncStatusTimeout);
        if (status === 'synced') {
            syncStatusTimeout = setTimeout(() => {
                syncStatusIndicator.className = '';
                syncStatusIndicator.title = '云同步状态';
            }, 3000);
            syncErrorModal.classList.remove('show');
        } else if (status === 'error') {
            // [核心修改] 只有在已配置的情况下才弹出错误框
            const isConfigured = GITHUB_CONFIG.owner && GITHUB_CONFIG.repo && GITHUB_CONFIG.token;
            if (isConfigured) {
                document.getElementById('sync-error-message').textContent = message;
                syncErrorModal.classList.add('show');
            }
        }
    }

    
    async function fetchFromGithub(path, method = 'GET', body = null, signal = null) {
        if (!checkConfig(false)) return { data: null, error: "GitHub未配置" };
        
        let endpoint, displayContext, showSyncIndicator = false;
        if(method === 'contents' || method === 'git') { // Legacy compatibility
            endpoint = method;
            method = 'GET';
        } else {
            endpoint = 'contents';
        }

        if(path.startsWith('git/blobs')) {
            endpoint = 'git'; // Override for blob fetches
            path = path.substring(4);
            displayContext = '读取文件内容';
        } else {
            displayContext = `读取 ${path}`;
            showSyncIndicator = true;
        }

        if (showSyncIndicator) updateSyncStatus('syncing', `正在从云端读取...`);

        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/${endpoint}/${path}`;
        
        try {
            const response = await fetch(url, {
                method: method,
                headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` },
                body: body ? JSON.stringify(body) : null,
                signal: signal, // Pass the signal to fetch
                cache: 'no-cache'
            });

            if (response.status === 404) return { data: null, error: null, response };
            if (!response.ok) {
                 const errorData = await response.json().catch(() => ({}));
                 throw new Error(`${response.status}: ${JSON.stringify(errorData)}`);
            }
            
            const data = await response.json();
            if (showSyncIndicator) updateSyncStatus('synced', '读取成功');
            return { data, response };

        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Fetch aborted by user.');
                return { data: null, error: '用户取消了操作' };
            }
            const userMessage = await handleApiError(displayContext, error);
            if (showSyncIndicator) updateSyncStatus('error', userMessage);
            return { data: null, error: userMessage, response: null };
        }
    }


    async function saveToGithub(path, content, commitMessage, sha = null) { // sha is now effectively a fallback
        if (!checkConfig(true)) {
            updateSyncStatus('error', '配置不完整，无法同步。');
            return { sha: null, error: "配置不完整" };
        }
        updateSyncStatus('syncing', `正在同步: ${commitMessage}`);
        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;
        const body = { message: commitMessage, content: content, branch: 'main' };

        // ============ [核心修复逻辑 V2] ============
        // 在每次写入前，都主动获取最新的 sha，从根本上解决冲突问题
        try {
            const { data: remoteFileData, response: fetchResponse } = await fetchFromGithub(path);
            // 如果文件存在(响应不是404)，就使用它的 sha
            if (fetchResponse && fetchResponse.status !== 404 && remoteFileData && remoteFileData.sha) {
                console.log(`Fetched latest sha for "${path}" before saving.`);
                body.sha = remoteFileData.sha;
            } else {
                // 如果文件不存在 (404)，则不提供 sha，这是创建新文件的正确行为
                console.log(`File "${path}" not found on remote. Proceeding with creation.`);
            }
        } catch (e) {
            // 如果在获取 sha 的过程中出错，则中止保存操作
            const userMessage = await handleApiError(`准备写入 ${path} 时`, e);
            updateSyncStatus('error', userMessage);
            return { sha: null, error: userMessage };
        }
        // =========================================

        try {
            const response = await fetch(url, {
                method: 'PUT',
                headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` },
                body: JSON.stringify(body),
                cache: 'no-cache'
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                // 专门处理仍然可能发生的、极小概率的竞争条件
                if (response.status === 409 || response.status === 422 || (errorData.message && errorData.message.includes("sha "))) {
                    const conflictMessage = `同步冲突：在您保存的瞬间，云端数据被另一处修改。请稍后重试。`;
                    updateSyncStatus('error', conflictMessage);
                    return { sha: null, error: conflictMessage };
                }
                throw new Error(`${response.status}: ${JSON.stringify(errorData)}`);
            }

            const data = await response.json();
            updateSyncStatus('synced', '同步成功！');
            
            // [重要] 返回新的 sha，以便全局变量可以更新
            const newSha = data.content.sha;
            if (path === 'config.json') configSha = newSha;
            if (path === 'memory/data.json') MemoryApp.updateSha(newSha); // 需要在MemoryApp中添加一个更新sha的函数
            
            return { sha: newSha, error: null };
            
        } catch (error) {
            const userMessage = await handleApiError(`写入 ${path}`, error);
            updateSyncStatus('error', userMessage);
            return { sha: null, error: userMessage };
        }
    }

    
    async function uploadFileViaGitData({ file, path, commitMessage, onProgress }) {
        if (!checkConfig(true)) throw new Error("GitHub未配置");
        
        // 1. 将文件读取为 Base64 编码的 Data URL
        const contentB64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            //  reader.onload 的结果是 'data:image/jpeg;base64,....'，我们需要去掉头部
            reader.onload = () => resolve(reader.result.split(',')[1]); 
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });

        // 2. 调用我们已经非常稳定的 saveToGithub 函数
        // 这个函数内部使用了 Contents API (PUT /.../contents/:path)，是原子操作，更可靠。
        // 它还会自动处理文件已存在时的 SHA 更新，避免冲突。
        
        // 尽管 onProgress 不再被精确调用，我们仍然可以在关键步骤调用它来更新UI
        if (onProgress) onProgress(50); // 表示文件已读取，准备上传

        const result = await saveToGithub(path, contentB64, commitMessage);

        if (onProgress) onProgress(100);

        // 3. 检查结果并返回
        if (result.sha) {
            // 上传成功，返回与旧函数兼容的格式
            return { sha: result.sha, path: path };
        } else {
            // 如果 saveToGithub 失败，它内部已经处理了错误提示，这里我们抛出错误以便上层捕获
            throw new Error(result.error || "未知上传错误");
        }
    }

    async function deleteFromGithub(path, commitMessage, sha, ignoreNotFound = false) {
        if (!checkConfig(true)) return false;
        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;
        try {
            const response = await fetch(url, {
                method: 'DELETE',
                headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` },
                body: JSON.stringify({ message: commitMessage, sha: sha, branch: 'main' }),
                cache: 'no-cache'
            });
            if (response.status === 404 && ignoreNotFound) {
                console.log(`File ${path} not found during deletion, which is acceptable.`);
                return true;
            }
            if (!response.ok) {
                 const errorData = await response.json().catch(() => ({}));
                 throw new Error(`${response.status}: ${JSON.stringify(errorData)}`);
            }
            return true;
        } catch (error) {
            const userMessage = await handleApiError(`删除文件 ${path.split('/').pop()}`, error);
            console.error(userMessage);
            return false;
        }
    }

    async function fetchConfigFromGithub() {
        const { data, error } = await fetchFromGithub('config.json');
        if (error && error !== "GitHub未配置") {
             navContainer.innerHTML = `<p id="loading-status" style="text-align: center; color: #e53e3e;">加载配置失败：${error}</p>`;
             return null;
        }
        if (data) {
            configSha = data.sha;
            try {
                return JSON.parse(b64_to_utf8(data.content));
            } catch (e) {
                alert('云端 config.json 文件格式错误，请尝试使用“手动同步与修复”功能。');
                return null;
            }
        }
        return null;
    }
    
    async function saveGlobalConfig(commitMessage) {
        const content = utf8_to_b64(JSON.stringify(currentConfig, null, 2));
        const result = await saveToGithub('config.json', content, commitMessage, configSha);
        if (result.sha) {
            configSha = result.sha;
            console.log('Global configuration saved successfully.');
        } else {
            // Error handling is managed inside saveToGithub
        }
    }
    
    function toggleManagementMode(forceState) {
        isManagementMode = forceState !== undefined ? forceState : !isManagementMode;
        
        // [核心修复] 移除对 pageOverlay 的所有操作，不再显示那层“透明膜”
        // pageOverlay.classList.toggle('show', isManagementMode);
        // pageOverlay.classList.toggle('management-overlay', isManagementMode);

        document.body.classList.toggle('management-active', isManagementMode);
        document.querySelectorAll('.nav-btn').forEach(btn => {
            const deleteIcon = btn.querySelector('.delete-icon');
            if (isManagementMode) {
                 btn.title = '点击编辑，点击 × 删除';
                if (!deleteIcon) {
                    const icon = document.createElement('span');
                    icon.className = 'delete-icon';
                    icon.innerHTML = '&times;';
                    icon.title = '删除此按钮';
                    btn.appendChild(icon);
                }
            } else {
                btn.title = '';
                if (deleteIcon) {
                    deleteIcon.remove();
                }
            }
        });
    }

    const fabContainer = document.getElementById('fabContainer'), fabMainBtn = document.getElementById('themeBtn');
    let fabPressTimer = null, isFabLongPress = false;
    function toggleFabMenu(forceState) { const isActive = forceState !== undefined ? forceState : !fabContainer.classList.contains('active'); fabContainer.classList.toggle('active', isActive); if (!isManagementMode) pageOverlay.classList.toggle('show', isActive); }
    fabMainBtn.addEventListener('mousedown', (e) => { e.preventDefault(); isFabLongPress = false; fabPressTimer = setTimeout(() => { isFabLongPress = true; toggleFabMenu(true); }, 300); });
    fabMainBtn.addEventListener('mouseup', () => { clearTimeout(fabPressTimer); if (!isFabLongPress) { fabContainer.classList.contains('active') ? toggleFabMenu(false) : toggleTheme(); } });
    fabMainBtn.addEventListener('contextmenu', e => e.preventDefault());
    fabMainBtn.addEventListener('touchstart', e => { e.preventDefault(); fabMainBtn.dispatchEvent(new MouseEvent('mousedown')); }, { passive: false });
    fabMainBtn.addEventListener('touchend', e => { e.preventDefault(); fabMainBtn.dispatchEvent(new MouseEvent('mouseup')); }, { passive: false });

        // [核心修复 V2] 使用 body 监听全局点击，以精准退出管理模式
    document.body.addEventListener('click', (e) => {
        // 如果 fab 菜单是打开的，点击任何地方都应该关闭它
        if (fabContainer.classList.contains('active') && !e.target.closest('.fab-container')) {
            toggleFabMenu(false);
        }

        // 如果不是管理模式，则不执行后续逻辑
        if (!isManagementMode) return;

        // 定义哪些元素被认为是“管理区域”，点击它们不应退出管理模式
        const isClickInsideManagementArea = 
            e.target.closest('.nav-btn') ||         // 点击了导航按钮本身
            e.target.closest('.modal-overlay') ||   // 点击了任何弹窗
            e.target.closest('.fab-container') ||   // 点击了右下角悬浮按钮
            e.target.closest('#addNavModalTitle');  // 兼容点击弹窗标题

        // 只有当点击事件不在“管理区域”内时，才退出管理模式
        if (!isClickInsideManagementArea) {
            toggleManagementMode(false);
        }
    }, true); // 使用捕获阶段，确保比其他点击事件更早执行，避免冲突

    function attachButtonListeners(btn) {
        btn.addEventListener('click', async function(e) {
            if (isManagementMode) {
                const href = this.dataset.href;
                if (!e.target.classList.contains('delete-icon')) {
                    e.preventDefault();
                    const buttonData = findButtonConfigByHref(href);
                    if (buttonData) {
                        openEditModal(buttonData);
                    }
                }
                return;
            }
            const href = this.dataset.href;
            if (!href) return;

            const buttonConfig = findButtonConfigByHref(href);

            if (buttonConfig && buttonConfig.openExternally) {
                window.open(href, '_blank', 'noopener,noreferrer');
                return;
            }

            if (href.startsWith('projects/')) {
                e.preventDefault();
                const secureUrl = await getSecureFileUrl(href);
                if(secureUrl) {
                    openIframeModal(secureUrl);
                } else {
                     alert('无法加载项目文件，请检查您的网络和GitHub配置。');
                }
                        } else if (href.startsWith('http')) {
                e.preventDefault();
                const isGithubLink = ['github.com', 'raw.githack.com', 'github.io'].some(domain => href.includes(domain));
                if (isGithubLink) {
                    // 调用新的非阻塞提示框函数
                    showTopToast('GitHub链接加载中，如遇缓慢请开启VPN');
                }
                openIframeModal(href);
            } else {

                window.location.href = href;
            }
        });
    }

    function findButtonConfigByHref(href) {
        for (const category of currentConfig.categories) {
            const button = category.buttons.find(b => b.href === href);
            if (button) return { ...button, categoryName: category.name };
        }
        return null;
    }

    document.getElementById('enterManageModeBtn').addEventListener('click', () => { document.getElementById('addNavModal').classList.remove('show'); setTimeout(() => toggleManagementMode(true), 150); });
    navContainer.addEventListener('click', async (e) => { 
        if (!e.target.classList.contains('delete-icon')) return; 
        e.stopPropagation();
        const btnToDelete = e.target.closest('.nav-btn'); 
        const buttonName = btnToDelete.firstChild.textContent.trim(); 
        if (!confirm(`确定要删除 "${buttonName}" 吗？\n警告：如果这是上传的项目，其在GitHub上的整个文件夹都将被永久删除！`)) return; 
        btnToDelete.style.cssText = 'transition: all 0.3s ease; transform: scale(0.8); opacity: 0;'; 
        setTimeout(async () => { 
            btnToDelete.remove(); 
            const href = btnToDelete.dataset.href; 
            let categoryModified = false;
            currentConfig.categories.forEach(cat => {
                const initialLength = cat.buttons.length;
                cat.buttons = cat.buttons.filter(b => b.href !== href);
                if (cat.buttons.length < initialLength) categoryModified = true;
            });

            currentConfig.categories = currentConfig.categories.filter(cat => cat.name === '全部' || cat.buttons.length > 0);

            if (href.startsWith('projects/')) {
                const folderPath = href.substring(0, href.lastIndexOf('/'));
                const success = await deleteGithubFolder(folderPath);
                if (!success) { alert('删除云端文件夹失败!'); location.reload(); return; }
            }
            if (categoryModified) {
                await saveGlobalConfig(`Delete button: ${buttonName}`);
                renderCategories();
                renderButtonsForCategory(currentCategory);
            }
        }, 300); 
    });
    document.getElementById('title').addEventListener('click', () => { if(isManagementMode) return; const newTitle = prompt('新标题：', currentConfig.title); if (newTitle?.trim() && newTitle.trim() !== currentConfig.title) { document.getElementById('title').textContent = newTitle.trim(); currentConfig.title = newTitle.trim(); saveGlobalConfig('Update main title'); } });
    document.getElementById('subtitle').addEventListener('click', () => { if(isManagementMode) return; const newSubtitle = prompt('新描述：', currentConfig.subtitle); if (newSubtitle !== null && newSubtitle.trim() !== currentConfig.subtitle) { document.getElementById('subtitle').textContent = newSubtitle.trim(); currentConfig.subtitle = newSubtitle.trim(); saveGlobalConfig('Update subtitle'); } });
    
    function applyAllBackgrounds() {
        const isDark = document.body.classList.contains('dark-mode');
        const bodyBgKey = isDark ? 'nightBgImage' : 'dayBgImage';
        const bodyBgImage = localStorage.getItem(bodyBgKey);
        
        if (bodyBgImage) {
            document.body.style.backgroundImage = `url(${bodyBgImage})`;
        } else {
            const color1 = getComputedStyle(document.documentElement).getPropertyValue(isDark ? '--night-color1' : '--day-color1').trim();
            const color2 = getComputedStyle(document.documentElement).getPropertyValue(isDark ? '--night-color2' : '--day-color2').trim();
            document.body.style.backgroundImage = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
        }

        const titleCardBgKey = isDark ? 'nightTitleCardBgImage' : 'dayTitleCardBgImage';
        const titleCardBgImage = localStorage.getItem(titleCardBgKey);
        const titleCard = document.getElementById('titleCard');
        if (titleCardBgImage) {
            titleCard.style.backgroundImage = `url(${titleCardBgImage})`;
            titleCard.style.backgroundSize = 'cover';
            titleCard.style.backgroundPosition = 'center';
        } else {
            titleCard.style.backgroundImage = isDark ? 'var(--bg-night-element)' : 'var(--bg-day-element)';
        }
    }
    

    function toggleTheme() { 
        document.body.classList.toggle('dark-mode'); 
        const i=document.body.classList.contains('dark-mode'); 
        fabMainBtn.textContent=i?'🌜':'🌞'; 
        localStorage.setItem('theme', i?'dark':'light');
        applyAllBackgrounds();
        WanderView.updateTheme();
        renderLockscreenWidgets(); // 新增：切换主题时重新渲染组件

        // [新增] 联动Giscus主题
        const giscusFrame = document.querySelector('.giscus-frame');
        if (giscusFrame) {
            const newTheme = PhoneCollectionManager.getGiscusTheme();
            giscusFrame.contentWindow.postMessage({ giscus: { setConfig: { theme: newTheme } } }, 'https://giscus.app');
        }
    };

     function setThemeStyle(styleName) {
        const pneumorphismSettings = document.getElementById('pneumorphism-settings');
        if (styleName === 'glass') {
            document.body.classList.add('theme-glass');
            document.documentElement.style.setProperty('--shadow-dark-night', 'rgba(0, 0, 0, 0.1)');
            document.documentElement.style.setProperty('--shadow-dark-day', 'rgba(0, 0, 0, 0.1)');

            pneumorphismSettings.classList.add('hidden');
            document.getElementById('theme-style-glass').checked = true;
        } else { // 默认或 neumorphism
            document.body.classList.remove('theme-glass');
            document.documentElement.style.setProperty('--shadow-dark-day', 'rgba(174, 190, 212, 0.4)');
             document.documentElement.style.setProperty('--shadow-dark-night', 'rgba(0, 0, 0, 0.3)');
            pneumorphismSettings.classList.remove('hidden');
            document.getElementById('theme-style-neumorphism').checked = true;
        }
        
        // [修改] 将设置存入 config 文件并触发保存，而不是 localStorage
        if (currentConfig.settings.themeStyle !== styleName) {
            currentConfig.settings.themeStyle = styleName;
            saveGlobalConfig('Update theme style');
        }

        // [新增] 联动Giscus主题
        const giscusFrame = document.querySelector('.giscus-frame');
        if (giscusFrame) {
            const newTheme = PhoneCollectionManager.getGiscusTheme();
            giscusFrame.contentWindow.postMessage({ giscus: { setConfig: { theme: newTheme } } }, 'https://giscus.app');
        }
    }


    document.querySelectorAll('input[name="theme-style"]').forEach(radio => {
        radio.addEventListener('change', (e) => setThemeStyle(e.target.value));
    });

    const colorModal = { 
        pickerD1: document.getElementById('dayColor1Picker'), hexD1: document.getElementById('dayColor1HexInput'),
        pickerD2: document.getElementById('dayColor2Picker'), hexD2: document.getElementById('dayColor2HexInput'),
        pickerN1: document.getElementById('nightColor1Picker'), hexN1: document.getElementById('nightColor1HexInput'),
        pickerN2: document.getElementById('nightColor2Picker'), hexN2: document.getElementById('nightColor2HexInput'),
        presetSelector: document.getElementById('presetSelector'), 
        randomToggle: document.getElementById('randomPaletteToggle'),
        dayPreview: document.getElementById('dayPreview'), nightPreview: document.getElementById('nightPreview') 
    };
    const root = document.documentElement;
    function applyColors(colors, saveToLocal = true) { 
        Object.entries(colors).forEach(([key, value]) => { 
            const cssVar = `--${key.replace('Color', '-color')}`; 
            root.style.setProperty(cssVar, value); 
            if (saveToLocal) localStorage.setItem(key, value); 
        }); 
        updateColorUI(colors); 
        applyAllBackgrounds(); 
        WanderView.updateTheme(); 
    }
    function updateColorUI(colors) { 
        colorModal.pickerD1.value = colors.dayColor1; colorModal.hexD1.value = colors.dayColor1;
        colorModal.pickerD2.value = colors.dayColor2; colorModal.hexD2.value = colors.dayColor2;
        colorModal.pickerN1.value = colors.nightColor1; colorModal.hexN1.value = colors.nightColor1;
        colorModal.pickerN2.value = colors.nightColor2; colorModal.hexN2.value = colors.nightColor2;
        colorModal.dayPreview.style.background = `linear-gradient(135deg, ${colors.dayColor2}, ${colors.dayColor1})`; 
        colorModal.nightPreview.style.background = `linear-gradient(135deg, ${colors.nightColor2}, ${colors.nightColor1})`; 
    }
    function getCurrentColors(fromLocalStorage = true) { 
        const source = fromLocalStorage ? localStorage : { getItem: (key) => getComputedStyle(root).getPropertyValue(`--${key.replace('Color', '-color')}`).trim() }; 
        return { 
            dayColor1: source.getItem('dayColor1') || '#f5f7fa', 
            dayColor2: source.getItem('dayColor2') || '#e4eaf5', 
            nightColor1: source.getItem('nightColor1') || '#1f2a40', 
            nightColor2: source.getItem('nightColor2') || '#16213e', 
        }; 
    }
    function setupColorSync(picker, hexInput, key) { 
        picker.addEventListener('input', () => { 
            hexInput.value = picker.value; 
            applyColors({ ...getCurrentColors(), [key]: picker.value }); 
        }); 
    }
    // [V2 优化] 函数，用于同步十六进制输入框的更改，并增加UX交互
    function setupHexInputSync(hexInput, colorPicker, key) {
        const handleHexInput = () => {
            let value = hexInput.value.trim();
            if (!value.startsWith('#')) value = '#' + value;
            if (/^#([0-9a-f]{3}){1,2}$/i.test(value)) {
                colorPicker.value = value;
                applyColors({ ...getCurrentColors(false), [key]: value });
            } else {
                hexInput.value = colorPicker.value;
            }
            hexInput.classList.add('confirmed-color');
        };
        hexInput.addEventListener('focus', function() { this.classList.remove('confirmed-color'); this.select(); });
        hexInput.addEventListener('blur', handleHexInput);
        hexInput.addEventListener('keydown', e => { if (e.key === 'Enter') { handleHexInput(); hexInput.blur(); } });
        hexInput.classList.add('confirmed-color');
    }

    function loadColorState() { populatePresetDropdown(); const randomPaletteEnabled = localStorage.getItem('randomPaletteEnabled') === 'true'; colorModal.randomToggle.checked = randomPaletteEnabled; if (randomPaletteEnabled && currentConfig.themePresets && currentConfig.themePresets.length > 0) { const randomPreset = currentConfig.themePresets[Math.floor(Math.random() * currentConfig.themePresets.length)]; applyColors(randomPreset.colors, false); } else { applyColors(getCurrentColors()); } }
    function populatePresetDropdown() { colorModal.presetSelector.innerHTML = '<option value="">选择或管理预设...</option>'; (currentConfig.themePresets || []).forEach((p, i) => { const opt = document.createElement('option'); opt.value = i; opt.textContent = p.name; colorModal.presetSelector.appendChild(opt); }); }
    
    // ★ 全新的预设管理逻辑 ★
    const addPresetBtn = document.getElementById('addColorPresetBtn');
    const updatePresetBtn = document.getElementById('updateColorPresetBtn');
    const deletePresetBtn = document.getElementById('deleteColorPresetBtn');

    addPresetBtn.addEventListener('click', () => {
        const name = prompt("请输入新预设的名称：");
        if (!name || name.trim() === '') return;
        const trimmedName = name.trim();
        if ((currentConfig.themePresets || []).some(p => p.name === trimmedName)) return alert('预设名称已存在');
        
        if (!currentConfig.themePresets) currentConfig.themePresets = [];
        currentConfig.themePresets.push({ name: trimmedName, colors: getCurrentColors(false) });
        saveGlobalConfig(`Save theme preset: ${trimmedName}`);
        populatePresetDropdown();
        colorModal.presetSelector.value = currentConfig.themePresets.length - 1;
    });

    updatePresetBtn.addEventListener('click', () => {
        const index = colorModal.presetSelector.value;
        if (index === '') return alert('请先从下拉框中选择一个要更新的预设');
        
        currentConfig.themePresets[index].colors = getCurrentColors(false);
        const presetName = currentConfig.themePresets[index].name;
        saveGlobalConfig(`Update theme preset: ${presetName}`);
        showTopToast(`预设 "${presetName}" 已更新！`, 2000);
    });

    deletePresetBtn.addEventListener('click', () => {
        const index = colorModal.presetSelector.value;
        if (index === '') return alert('请先从下拉框中选择一个要删除的预设');
        
        const presetName = currentConfig.themePresets[index].name;
        if (!confirm(`确定要删除预设 "${presetName}" 吗？`)) return;
        
        currentConfig.themePresets.splice(index, 1);
        saveGlobalConfig(`Delete theme preset: ${presetName}`);
        populatePresetDropdown();
    });

    colorModal.presetSelector.addEventListener('change', () => {
        const index = colorModal.presetSelector.value;
        if (index === '') return;
        applyColors(currentConfig.themePresets[index].colors);
    });
    
    colorModal.randomToggle.addEventListener('change', () => { localStorage.setItem('randomPaletteEnabled', colorModal.randomToggle.checked); });

    
    function setupBgImageManager() {
        const setupPicker = (pickerId, uploadBtnId, clearBtnId, statusId, storageKey, storageNameKey) => {
            const picker = document.getElementById(pickerId);
            document.getElementById(uploadBtnId).addEventListener('click', () => picker.click());
            document.getElementById(clearBtnId).addEventListener('click', () => {
                localStorage.removeItem(storageKey);
                localStorage.removeItem(storageNameKey);
                applyAllBackgrounds();
                updateBgStatus();
            });
            picker.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    localStorage.setItem(storageKey, event.target.result);
                    localStorage.setItem(storageNameKey, file.name);
                    applyAllBackgrounds();
                    updateBgStatus();
                };
                reader.readAsDataURL(file);
            });
        };
        setupPicker('dayBgImagePicker', 'uploadDayBgBtn', 'clearDayBgBtn', 'dayBgStatus', 'dayBgImage', 'dayBgImageName');
        setupPicker('nightBgImagePicker', 'uploadNightBgBtn', 'clearNightBgBtn', 'nightBgStatus', 'nightBgImage', 'nightBgImageName');
        setupPicker('dayTitleCardBgImagePicker', 'uploadDayTitleCardBgBtn', 'clearDayTitleCardBgBtn', 'dayTitleCardBgStatus', 'dayTitleCardBgImage', 'dayTitleCardBgImageName');
        setupPicker('nightTitleCardBgImagePicker', 'uploadNightTitleCardBgBtn', 'clearNightTitleCardBgBtn', 'nightTitleCardBgStatus', 'nightTitleCardBgImage', 'nightTitleCardBgImageName');
    }
    
    function updateBgStatus() {
        document.getElementById('dayBgStatus').textContent = localStorage.getItem('dayBgImageName') || '未设置';
        document.getElementById('nightBgStatus').textContent = localStorage.getItem('nightBgImageName') || '未设置';
        document.getElementById('dayTitleCardBgStatus').textContent = localStorage.getItem('dayTitleCardBgImageName') || '未设置';
        document.getElementById('nightTitleCardBgStatus').textContent = localStorage.getItem('nightTitleCardBgImageName') || '未设置';
    }
    
    const settingsModalElements = { githubRepoInput: document.getElementById("githubRepoInput"), githubTokenInput: document.getElementById("githubTokenInput"), saveSettingsBtn: document.getElementById("saveSettingsBtn"), manualSyncBtn: document.getElementById('manualSyncBtn') };
    function setupModals(){document.querySelectorAll(".close-btn").forEach(e=>e.addEventListener("click",()=>{document.getElementById(e.dataset.modalId).classList.remove("show")})),document.querySelectorAll(".modal-overlay").forEach(e=>e.addEventListener("click",t=>e===t.target&&e.classList.remove("show"))),document.getElementById("helpBtn").addEventListener("click", () => {
    // 切换弹窗和菜单的显示
    document.getElementById("helpModal").classList.add("show");
    toggleFabMenu(false);
})

,document.getElementById("dataSyncBtn").addEventListener("click",()=>{GITHUB_CONFIG.owner&&GITHUB_CONFIG.repo&&(settingsModalElements.githubRepoInput.value=`${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}`),settingsModalElements.githubTokenInput.value=GITHUB_CONFIG.token||"",document.getElementById("settingsModal").classList.add("show"),toggleFabMenu(!1)}),document.getElementById("addNavBtn").addEventListener("click",()=>{openAddModal(); toggleFabMenu(false);}),document.getElementById("colorBtn").addEventListener("click", ()=>{document.getElementById("colorPaletteModal").classList.add("show"); updateColorUI(getCurrentColors()); updateBgStatus(); toggleFabMenu(false);}),document.getElementById("memoryBtn").addEventListener('click', () => { MemoryApp.open(); toggleFabMenu(false); }), document.getElementById('jelly-css-help-modal').querySelectorAll('.copy-btn').forEach(btn => { btn.addEventListener('click', async (e) => { const textBlock = e.target.parentElement; const textToCopy = textBlock.innerText.replace(e.target.innerText, '').trim(); try { await navigator.clipboard.writeText(textToCopy); const originalText = e.target.textContent; e.target.textContent = '已复制!'; setTimeout(() => { e.target.textContent = originalText; }, 1500); } catch (err) { alert('复制失败，请手动复制。'); } }); });}
    function saveGithubConfig(e){localStorage.setItem("githubConfig",JSON.stringify(e)),GITHUB_CONFIG=e}function loadGithubConfig(){const e=localStorage.getItem("githubConfig");e&&(GITHUB_CONFIG=JSON.parse(e))}function checkConfig(e=!0){return!GITHUB_CONFIG.owner||!GITHUB_CONFIG.repo||!GITHUB_CONFIG.token?(e&&alert("请先配置GitHub仓库信息。\n(打开菜单 -> 数据同步)"),!1):!0}
    
    function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
    function mergeDeep(target, ...sources) {
        if (!sources.length) return target;
        const source = sources.shift();
        if (isObject(target) && isObject(source)) {
            for (const key in source) {
                if (isObject(source[key])) {
                    if (!target[key]) Object.assign(target, { [key]: {} });
                    mergeDeep(target[key], source[key]);
                } else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        return mergeDeep(target, ...sources);
    }
    
    function migrateLegacyConfig(config) {
        if (!config) return { migratedConfig: config, wasMigrated: false };

        let wasModified = false;

        if (!Array.isArray(config.categories)) {
            config.categories = [];
            wasModified = true;
            console.log("Migration: 'categories' array not found, created a new one.");
        }

        let allCategory = config.categories.find(c => c.name === '全部');
        if (!allCategory) {
            allCategory = { name: '全部', buttons: [] };
            config.categories.unshift(allCategory);
            wasModified = true;
            console.log("Migration: Default '全部' category not found, created a new one.");
        }

        if (Array.isArray(config.buttons) && config.buttons.length > 0) {
            console.log(`Migration: Found ${config.buttons.length} orphaned buttons at the root level. Merging...`);
            const allCategoryButtonHrefs = new Set(allCategory.buttons.map(b => b.href));

            config.buttons.forEach(orphanButton => {
                if (!allCategoryButtonHrefs.has(orphanButton.href)) {
                    allCategory.buttons.push(orphanButton);
                    console.log(`  -> Merged button: "${orphanButton.text}"`);
                } else {
                    console.log(`  -> Skipped duplicate button: "${orphanButton.text}"`);
                }
            });
            
            wasModified = true;
        }

        if (config.hasOwnProperty('buttons')) {
            delete config.buttons;
            console.log("Migration: Cleaned up legacy root 'buttons' array.");
        }

        return { migratedConfig: config, wasMigrated: wasModified };
    }


    // [V2 修改] 增加几个新的辅助函数
    /**
     * 获取指定文件的提交历史
     * @param {string} path - 文件路径, e.g., 'config.json'
     * @returns {Promise<Array|null>} - 包含提交对象的数组或null
     */
    async function getHistoryForFile(path) {
        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/commits?path=${path}&per_page=5`;
        try {
            const response = await fetch(url, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` } });
            if (!response.ok) throw new Error(`API error: ${response.status}`);
            return await response.json();
        } catch (error) {
            console.error(`Failed to get history for ${path}:`, error);
            return null;
        }
    }

    /**
     * 获取文件在某次特定提交时的内容
     * @param {string} path - 文件路径
     * @param {string} commitSha - 提交的SHA值
     * @returns {Promise<string|null>} - 文件的UTF-8字符串内容或null
     */
    async function getContentAtCommit(path, commitSha) {
        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}?ref=${commitSha}`;
        try {
            const response = await fetch(url, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` } });
            if (response.status === 404) return null; // 该版本不存在此文件
            if (!response.ok) throw new Error(`API error: ${response.status}`);
            const data = await response.json();
            return data.content ? b64_to_utf8(data.content) : null;
        } catch (error) {
            console.error(`Failed to get content for ${path} at commit ${commitSha}:`, error);
            return null;
        }
    }

    settingsModalElements.manualSyncBtn.addEventListener("click", async () => {
        if (!checkConfig(true)) return;
        
        const btn = settingsModalElements.manualSyncBtn;
        const originalText = btn.textContent;
        const recoveryModal = document.getElementById('dataRecoveryModal');
        const versionsListContainer = document.getElementById('recovery-versions-list');
        const confirmRecoveryBtn = document.getElementById('confirmRecoveryBtn');
        const cancelRecoveryBtn = document.getElementById('cancelRecoveryBtn');

        btn.disabled = true;
        btn.textContent = '正在检查云端数据...';

        try {
            const currentConfigData = await fetchConfigFromGithub();
            const isDataEmpty = !currentConfigData || !currentConfigData.categories || currentConfigData.categories.length === 0 || 
                                (currentConfigData.categories.length === 1 && currentConfigData.categories[0].buttons.length === 0);

            if (isDataEmpty) {
                btn.textContent = '检测到数据为空，正在查找历史版本...';
                
                const history = await getHistoryForFile('config.json');
                const historyToConsider = history ? history.slice(1, 5) : []; // 跳过最新的错误提交，取最多4个历史版本

                if (!historyToConsider || historyToConsider.length === 0) {
                    throw new Error('未找到足够的历史记录来进行恢复。');
                }

                btn.textContent = '正在解析历史数据...';

                const versions = [];
                await Promise.all(historyToConsider.map(async (commit) => {
                    const commitSha = commit.sha;
                    const [configContent, memoryContent] = await Promise.all([
                        getContentAtCommit('config.json', commitSha),
                        getContentAtCommit('memory/data.json', commitSha)
                    ]);
                    if (!configContent) return;

                    let summary = { buttons: 0, categories: 0, photos: 0, albums: 0, memos: 0, memoFolders: 0 };
                    try {
                        const parsedConfig = JSON.parse(configContent);
                        summary.categories = parsedConfig.categories?.length || 0;
                        summary.buttons = parsedConfig.categories?.reduce((acc, cat) => acc + (cat.buttons?.length || 0), 0) || 0;
                    } catch (e) { /* ignore */ }
                    if (memoryContent) {
                        try {
                            const parsedMemory = JSON.parse(memoryContent);
                            summary.albums = parsedMemory.album?.folders?.length || 0;
                            summary.photos = parsedMemory.album?.items?.reduce((acc, item) => acc + (item.type === 'photoset' ? item.photos.length : 1), 0) || 0;
                            summary.memoFolders = parsedMemory.memo?.folders?.length || 0;
                            summary.memos = parsedMemory.memo?.notes?.length || 0;
                        } catch (e) { /* ignore */ }
                    }
                    versions.push({sha:commitSha,message:commit.commit.message,date:new Date(commit.commit.author.date).toLocaleString('zh-CN'),summary,configContent,memoryContent});
                }));

                if (versions.length === 0) {
                    throw new Error('无法解析任何有效的历史版本。');
                }
                
                // 渲染版本列表
                versionsListContainer.innerHTML = '';
                versions.forEach((version, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'recovery-version-item';
                    itemEl.innerHTML = `
                        <input type="radio" name="recovery-version" id="version-${index}" value="${version.sha}">
                        <label for="version-${index}">
                            <div class="version-meta">${version.message} <span>(${version.date})</span></div>
                            <div class="version-summary">
                                <span><pre>按钮: ${version.summary.buttons}</pre></span>
                                <span><pre>分类: ${version.summary.categories}</pre></span>
                                <span><pre>备忘录: ${version.summary.memos}</pre></span>
                                <span><pre>相册: ${version.summary.albums}</pre></span>
                                <span><pre>照片: ${version.summary.photos}</pre></span>
                            </div>
                        </label>
                    `;
                    versionsListContainer.appendChild(itemEl);
                });
                
                document.getElementById('settingsModal').classList.remove('show');
                recoveryModal.classList.add('show');
                btn.textContent = '请选择恢复版本...';
                confirmRecoveryBtn.disabled = true;

                return new Promise(resolve => {
                    const handleSelectionChange = () => confirmRecoveryBtn.disabled = false;
                    versionsListContainer.addEventListener('change', handleSelectionChange);

                    const handleConfirm = async () => {
                        const selectedSha = versionsListContainer.querySelector('input[name="recovery-version"]:checked')?.value;
                        if (!selectedSha) return;

                        const selectedVersion = versions.find(v => v.sha === selectedSha);
                        if (!selectedVersion) return alert('无法找到所选版本的数据。');

                        recoveryModal.classList.remove('show');
                        btn.textContent = '正在恢复数据...';

                        const commitMsg = `Recover data from commit ${selectedVersion.sha.substring(0, 7)}`;
                        const configPromise = saveToGithub('config.json', utf8_to_b64(selectedVersion.configContent), commitMsg);
                        const memoryPromise = selectedVersion.memoryContent ? saveToGithub('memory/data.json', utf8_to_b64(selectedVersion.memoryContent), commitMsg) : Promise.resolve();
                        
                        await Promise.all([configPromise, memoryPromise]);
                        alert('数据恢复成功！页面将刷新以应用新数据。');
                        location.reload();
                        resolve();
                    };

                    const handleCancel = () => {
                        recoveryModal.classList.remove('show');
                        btn.disabled = false;
                        btn.textContent = originalText;
                        resolve();
                    };
                    
                    confirmRecoveryBtn.onclick = handleConfirm;
                    cancelRecoveryBtn.onclick = handleCancel;
                });

            } else {
                btn.textContent = '数据完整，执行常规同步...';
                let fetchedConfig = currentConfigData;
                const defaultConfig = getDefaultConfig();
                let needsSave = false;
                let wasMigrated = false;

                const migrationResult = migrateLegacyConfig(fetchedConfig);
                fetchedConfig = migrationResult.migratedConfig;
                wasMigrated = migrationResult.wasMigrated;
                if (wasMigrated) btn.textContent = '迁移旧版配置...';

                const mergedConfig = mergeDeep({}, defaultConfig, fetchedConfig);
                if (JSON.stringify(mergedConfig) !== JSON.stringify(fetchedConfig) || wasMigrated) {
                    currentConfig = mergedConfig;
                    needsSave = true;
                }
                
                if (needsSave) {
                    btn.textContent = '正在保存至云端...';
                    await saveGlobalConfig(wasMigrated ? 'Manual sync: Migrated legacy config' : 'Manual sync and repair');
                    btn.textContent = '同步完成，即将刷新';
                    alert("同步与修复完成！页面将刷新以应用最新配置。");
                    location.reload();
                } else {
                    btn.textContent = '配置已是最新';
                    alert("配置已是最新，无需修复。");
                }
            }
        } catch (e) {
            btn.textContent = '发生错误';
            alert(`操作失败: ${e.message}`);
        } finally {
            setTimeout(() => {
                if(btn.textContent.includes('...')) { // 只在未完成最终操作时恢复按钮
                   btn.disabled = false;
                   btn.textContent = originalText;
                }
            }, 3000);
        }
    });

    async function loadInitialData() { 
        navContainer.innerHTML = '<p id="loading-status" style="text-align: center; color: #889;">正在从云端加载配置...</p>'; 
        let fetchedConfig = await fetchConfigFromGithub(); 
        let needsSave = false;
        let wasMigrated = false;

        // [核心修复逻辑]
        if (fetchedConfig) {
            // 云端存在配置，以此为基础进行合并和迁移
            const migrationResult = migrateLegacyConfig(fetchedConfig);
            const migratedConfig = migrationResult.migratedConfig;
            wasMigrated = migrationResult.wasMigrated;

            const defaultConfig = getDefaultConfig();
            // 正确的合并顺序：以用户数据 (migratedConfig) 为主，用默认配置 (defaultConfig) 补充缺失的字段
            const mergedConfig = mergeDeep({}, defaultConfig, migratedConfig); 
            
            currentConfig = mergedConfig;
            
            // 检查合并或迁移后是否有变化，有则需要保存
            if (JSON.stringify(currentConfig) !== JSON.stringify(fetchedConfig) || wasMigrated) {
                needsSave = true;
                console.log("Config updated with new fields or migrated. Scheduling an auto-save.");
            }
        } else {
            // 只有当云端确实没有 config.json 文件时，才使用全新的默认配置并创建
            console.log('Config.json not found on remote. Creating a new one with default settings.');
            currentConfig = getDefaultConfig();
            configSha = null; // 确保是创建新文件
            needsSave = true; 
        }

        if (needsSave) {
            await saveGlobalConfig(wasMigrated ? 'Auto-migrate legacy config format' : 'Auto-create or repair config.json');
        }

        // --- [UI 初始化逻辑保持不变] ---
        const t = localStorage.getItem('theme');
        if (t === 'dark' || (!t && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.body.classList.add('dark-mode');
            fabMainBtn.textContent = '🌜';
        } else {
            fabMainBtn.textContent = '🌞';
        }

        const savedThemeStyle = currentConfig.settings.themeStyle || 'neumorphism';
        setThemeStyle(savedThemeStyle);

        applyAllBackgrounds();
        
        document.getElementById('title').textContent = currentConfig.title; 
        document.getElementById('subtitle').textContent = currentConfig.subtitle; 
        document.querySelector('.editable-title').style.opacity = 1; 
        document.querySelector('.editable-subtitle').style.opacity = 1; 
        
        currentCategory = localStorage.getItem('lastSelectedCategory') || '全部';
        if (!currentConfig.categories.some(c => c.name === currentCategory)) {
            currentCategory = '全部';
        }
        
        renderCategories();
        loadColorState(); 
    }

    
    function renderCategories() {
        const navContainerEl = document.getElementById('categoryNavContainer');
        if (!currentConfig.settings) {
            currentConfig.settings = { paginationEnabled: true };
        }
        const paginationEnabled = currentConfig.settings.paginationEnabled !== false; // Default to true
        navContainerEl.style.display = paginationEnabled ? 'block' : 'none';
        
        const categoryNav = document.getElementById('categoryNav');
        categoryNav.innerHTML = '';

        if(paginationEnabled) {
            currentConfig.categories.forEach(cat => {
                const pill = document.createElement('button');
                pill.className = 'category-pill';
                pill.textContent = cat.name;
                pill.dataset.category = cat.name;
                if (cat.name === currentCategory) {
                    pill.classList.add('active');
                }
                categoryNav.appendChild(pill);
            });
        }
        
        const categoryToRender = paginationEnabled ? currentCategory : '全部';
        renderButtonsForCategory(categoryToRender);
    }

    document.getElementById('categoryNav').addEventListener('click', (e) => {
        if (e.target.classList.contains('category-pill')) {
            const categoryName = e.target.dataset.category;
            currentCategory = categoryName;
            localStorage.setItem('lastSelectedCategory', categoryName);
            document.querySelectorAll('.category-pill').forEach(p => p.classList.remove('active'));
            e.target.classList.add('active');
            renderButtonsForCategory(categoryName);
        }
    });

    function renderButtonsForCategory(categoryName) {
        navContainer.innerHTML = '';
        let buttons = [];

        if (currentConfig.settings.paginationEnabled === false) {
             categoryName = '全部';
        }
        
        if (categoryName === '全部') {
            const allButtons = new Map();
            currentConfig.categories.forEach(cat => {
                cat.buttons.forEach(btn => {
                    if (!allButtons.has(btn.href)) {
                        allButtons.set(btn.href, btn);
                    }
                });
            });
            buttons = Array.from(allButtons.values());
        } else {
            const category = currentConfig.categories.find(c => c.name === categoryName);
            buttons = category ? category.buttons : [];
        }

        if (buttons.length === 0) {
            navContainer.innerHTML = '<p id="loading-status" style="text-align: center; color: #889;">该分类下暂无项目。</p>';
        } else {
            buttons.forEach(item => addNewButtonToDOM(item.text, item.href, false));
        }
    }

    async function deleteGithubFolder(folderPath) { if (!checkConfig(true)) return false; const contentsUrl = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${folderPath}`; try { const contentsResponse = await fetch(contentsUrl, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` }, cache: 'no-cache' }); if (contentsResponse.status === 404) { console.log(`Folder "${folderPath}" not found, nothing to delete.`); return true; } if (!contentsResponse.ok) throw new Error(`Could not list folder: ${contentsResponse.statusText}`); const files = await contentsResponse.json(); for (const file of files) { await deleteFromGithub(file.path, `Recursive delete: ${file.path}`, file.sha); } return true; } catch (error) { console.error(`Failed to delete folder "${folderPath}":`, error); return false; } }
    
    settingsModalElements.saveSettingsBtn.addEventListener("click",async()=>{const[e,t]=settingsModalElements.githubRepoInput.value.trim().split("/").map(e=>e.trim()),n=settingsModalElements.githubTokenInput.value.trim();if(e&&t&&n){saveGithubConfig({owner:e,repo:t,token:n,branch:"main"}),alert("配置已保存！正在刷新..."),document.getElementById("settingsModal").classList.remove("show"), location.reload() }else{alert("请填写完整信息。")}});

    const addNavModalElements={modal: document.getElementById('addNavModal'), title: document.getElementById('addNavModalTitle'), typeLinkRadio:document.getElementById("type-link"),typeUploadRadio:document.getElementById("type-upload"),linkSection:document.getElementById("link-section"),uploadSection:document.getElementById("upload-section"),categoryInput:document.getElementById("newButtonCategoryInput"),nameInput:document.getElementById("newButtonNameInput"),urlInput:document.getElementById("newButtonUrlInput"),openExternallyToggle:document.getElementById("openExternallyToggle"),filePickerBtn:document.getElementById("filePickerBtn"),projectHtmlPicker:document.getElementById("projectHtmlPicker"),fileStatus:document.getElementById("file-picker-status"),createBtn:document.getElementById("createNavBtn"),uploadStatus:document.getElementById("upload-status"),stayOpenToggle:document.getElementById("stayOpenToggle"), paginationToggle: document.getElementById('paginationToggle'), categoryMgmtSection: document.getElementById('category-management-section'), deleteCategoryBtn: document.getElementById('deleteCategoryBtn')};
    
    function updateAddNavModalUI() {
        const paginationEnabled = currentConfig.settings.paginationEnabled !== false;
        addNavModalElements.paginationToggle.checked = paginationEnabled;
        const selectedCategory = addNavModalElements.categoryInput.value.trim();
        const showDeleteBtn = selectedCategory && selectedCategory !== '全部' && currentConfig.categories.some(c => c.name === selectedCategory);
        addNavModalElements.categoryMgmtSection.style.display = showDeleteBtn ? 'block' : 'none';
    }
    
    addNavModalElements.paginationToggle.addEventListener('change', () => {
        currentConfig.settings.paginationEnabled = addNavModalElements.paginationToggle.checked;
        saveGlobalConfig('Toggle pagination setting');
        renderCategories();
    });

    addNavModalElements.categoryInput.addEventListener('input', updateAddNavModalUI);
    addNavModalElements.deleteCategoryBtn.addEventListener('click', async () => {
        const categoryNameToDelete = addNavModalElements.categoryInput.value.trim();
        if (!categoryNameToDelete || categoryNameToDelete === '全部') return;

        const choice = prompt(`您想如何处理 "${categoryNameToDelete}" 分类？\n\n1: 仅删除分类 (项目保留在"全部"中)\n2: 删除分类和其下所有项目 (危险！)\n\n请输入数字 1 或 2。`);

        if (choice === '1') {
            const categoryObj = currentConfig.categories.find(c => c.name === categoryNameToDelete);
            currentConfig.categories = currentConfig.categories.filter(c => c.name !== categoryNameToDelete);
            await saveGlobalConfig(`Delete category (keep items): ${categoryNameToDelete}`);
            alert(`分类 "${categoryNameToDelete}" 已删除，其项目现在仅在“全部”中显示。`);
        } else if (choice === '2') {
            if (confirm(`⚠️ 再次确认：\n您确定要永久删除分类 "${categoryNameToDelete}" 以及其中的所有项目吗？此操作不可逆！`)) {
                currentConfig.categories = currentConfig.categories.filter(c => c.name !== categoryNameToDelete);
                await saveGlobalConfig(`Delete category and items: ${categoryNameToDelete}`);
                alert(`分类 "${categoryNameToDelete}" 及其所有项目已被删除。`);
            }
        } else {
            alert("操作已取消。");
            return;
        }
        
        addNavModalElements.categoryInput.value = '';
        currentCategory = '全部';
        localStorage.setItem('lastSelectedCategory', '全部');
        renderCategories();
        populateCategoryDatalist();
        updateAddNavModalUI();
    });

    function addNewButtonToDOM(text, href) { 
        navContainer.querySelector("#loading-status")?.remove(); 
        const btn = document.createElement("button"); 
        btn.className = "nav-btn"; 
        btn.dataset.href = href; 
        const textNode = document.createTextNode(text); 
        btn.appendChild(textNode); 
        navContainer.appendChild(btn); 
        attachButtonListeners(btn); 
        if (isManagementMode) { 
            btn.title = '点击编辑，点击 × 删除';
            const icon = document.createElement('span'); 
            icon.className = 'delete-icon'; 
            icon.innerHTML = '&times;'; 
            icon.title = '删除此按钮'; 
            btn.appendChild(icon); 
        } 
    }
    function resetAddNavForm() { addNavModalElements.nameInput.value = ""; addNavModalElements.urlInput.value = ""; addNavModalElements.openExternallyToggle.checked = false; addNavModalElements.fileStatus.textContent = "未选择任何文件"; addNavModalElements.uploadStatus.textContent = ""; addNavModalElements.projectHtmlPicker.value = ""; isEditingButton = false; editingButtonData = null; }
    
    function populateCategoryDatalist() {
        const datalist = document.getElementById('category-datalist');
        datalist.innerHTML = '';
        currentConfig.categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.name;
            datalist.appendChild(option);
        });
    }

    document.querySelectorAll('input[name="nav-type"]').forEach(radio => {
        radio.addEventListener('change', function() {
            addNavModalElements.linkSection.style.display = this.value === 'link' ? 'block' : 'none';
            addNavModalElements.uploadSection.style.display = this.value === 'upload' ? 'flex' : 'none';
        });
    });

    addNavModalElements.filePickerBtn.addEventListener("click", () => addNavModalElements.projectHtmlPicker.click()); addNavModalElements.projectHtmlPicker.addEventListener("change", () => { if (addNavModalElements.projectHtmlPicker.files.length > 0) { const projectFile = addNavModalElements.projectHtmlPicker.files[0]; addNavModalElements.fileStatus.textContent = `已选择: ${projectFile.name}`; } else { addNavModalElements.fileStatus.textContent = '未选择任何文件'; }});
    addNavModalElements.createBtn.addEventListener("click",async()=>{
        const categoryName = addNavModalElements.categoryInput.value.trim() || '全部';
        const name = addNavModalElements.nameInput.value.trim();
        if(!name) return alert("请输入按钮名称。");
        const type=document.querySelector('input[name="nav-type"]:checked').value;
        addNavModalElements.createBtn.disabled = true;
        addNavModalElements.createBtn.textContent="处理中...";

        try {
            let newButtonData;
            if (type === "link") {
                const url = addNavModalElements.urlInput.value.trim();
                let finalUrl = url;
                 try {
                    new URL(url);
                } catch (_) {
                    if (!url.startsWith('https://') && !url.startsWith('http://') && url.includes('.')) {
                        finalUrl = 'https://' + url;
                    } else if (!url) {
                        alert("请输入网址链接。"); throw new Error("URL is required.");
                    }
                }
                 newButtonData = { text: name, href: finalUrl, openExternally: addNavModalElements.openExternallyToggle.checked };
            } else if (type === "upload") {
                 if (isEditingButton) {
                    alert("已上传的项目无法编辑，请删除后重新上传。"); return;
                 }
                 if (!checkConfig()) return;
                 const projectFile = addNavModalElements.projectHtmlPicker.files[0]; 
                 if(!projectFile) { alert("请选择一个HTML文件。"); throw new Error("File is required."); }
                 addNavModalElements.uploadStatus.textContent="正在上传文件...";
                 const path=`projects/${name.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g,"").replace(/\s+/g,"-")||`project-${Date.now()}`}/index.html`;
                 await uploadFileViaGitData({ file: projectFile, path, commitMessage: `Create project: ${name}`, onProgress: (p) => { addNavModalElements.uploadStatus.textContent = `上传中: ${Math.round(p)}%`; } });
                 addNavModalElements.uploadStatus.textContent="正在处理...";
                 newButtonData= { text:name, href: path, openExternally: false }; // **FIX**: Store the path, not the githack URL
                 alert("项目上传成功！");
            }
            
            let commitMsg;
            // [修改] 优化编辑逻辑
            if (isEditingButton && editingButtonData) {
                commitMsg = `Edit button: ${name}`;
                const oldCategoryName = editingButtonData.categoryName;
                const oldCategory = currentConfig.categories.find(c => c.name === oldCategoryName);
                const buttonIndex = oldCategory ? oldCategory.buttons.findIndex(b => b.href === editingButtonData.href) : -1;

                if (oldCategory && buttonIndex > -1) {
                    if (oldCategoryName === categoryName) {
                        // 类别未变，在原位更新
                        oldCategory.buttons[buttonIndex] = newButtonData;
                    } else {
                        // 类别改变，从旧类别移除，添加到新类别
                        oldCategory.buttons.splice(buttonIndex, 1);
                        let newCategoryObj = currentConfig.categories.find(c => c.name === categoryName);
                        if (!newCategoryObj) {
                            newCategoryObj = { name: categoryName, buttons: [] };
                            currentConfig.categories.push(newCategoryObj);
                        }
                        newCategoryObj.buttons.push(newButtonData);
                    }
                }
            } else {
                // 新增按钮逻辑保持不变
                commitMsg = `Add button: ${name} to ${categoryName}`;
                let categoryObj = currentConfig.categories.find(c => c.name === categoryName);
                if (!categoryObj) {
                    categoryObj = { name: categoryName, buttons: [] };
                    currentConfig.categories.push(categoryObj);
                }
                categoryObj.buttons.push(newButtonData);
            }

            await saveGlobalConfig(commitMsg); 
            
            resetAddNavForm(); 
            populateCategoryDatalist();
            renderCategories();
            
            if(!addNavModalElements.stayOpenToggle.checked || isEditingButton) { 
                addNavModalElements.modal.classList.remove("show");
            } 
        } catch(o) {
            addNavModalElements.uploadStatus.textContent="操作失败!";
            if(o.message !== "URL is required." && o.message !== "File is required.") {
                 alert(await handleApiError("创建/编辑项目", o));
            }
        } finally {
            addNavModalElements.createBtn.disabled = false;
            addNavModalElements.createBtn.textContent = isEditingButton ? "保存更改" : "加入新项目";
        }
    });


    function openAddModal() {
        isEditingButton = false;
        editingButtonData = null;
        const els = addNavModalElements;
        els.modal.classList.add('show');
        els.title.textContent = '管理项目';
        els.createBtn.textContent = '加入新项目';
        
        els.uploadSection.style.pointerEvents = 'auto';
        els.uploadSection.style.opacity = '1';
        document.querySelector('label[for="type-upload"]').style.display = 'block';

        resetAddNavForm();
        populateCategoryDatalist();
        updateAddNavModalUI();
    }

    function openEditModal(buttonData) {
        isEditingButton = true;
        editingButtonData = buttonData;
        const els = addNavModalElements;
        
        els.modal.classList.add('show');
        els.title.textContent = '编辑项目';
        els.createBtn.textContent = '保存更改';
        
        els.categoryInput.value = buttonData.categoryName;
        els.nameInput.value = buttonData.text;
        
        const isUploadedProject = buttonData.href.startsWith('projects/');
        
        if (isUploadedProject) {
            els.urlInput.value = "已上传的项目，路径不可编辑。";
            els.typeUploadRadio.checked = true;
            els.linkSection.style.display = 'none';
            els.uploadSection.style.display = 'flex';
            els.uploadSection.style.pointerEvents = 'none';
            els.uploadSection.style.opacity = '0.5';
            document.querySelector('label[for="type-upload"]').style.display = 'none';
        } else {
            els.urlInput.value = buttonData.href;
            els.typeLinkRadio.checked = true;
            els.linkSection.style.display = 'block';
            els.uploadSection.style.display = 'none';
        }
        
        els.openExternallyToggle.checked = buttonData.openExternally || false;
        
        populateCategoryDatalist();
        updateAddNavModalUI();
    }
    
    function openIframeModal(url) { 
        if (!localStorage.getItem('swipeHintShown')) { swipeHint.classList.add('show'); setTimeout(() => { swipeHint.classList.remove('show'); localStorage.setItem('swipeHintShown', 'true'); }, 4000); } 
        iframeEl.src = url; 
        iframeModal.dataset.originalUrl = url; // [新增] 记录原始URL
        iframeModal.classList.add('active'); 
    }


     function closeIframeModal() { 
        FloatingProjectWindowManager.closeAll();
        hideReturnConfirmation(); 
        iframeModal.classList.remove('active'); 
    }


    function showReturnConfirmation() { returnConfirmationToast.classList.add('show'); }
    function hideReturnConfirmation() { returnConfirmationToast.classList.remove('show'); }
    document.getElementById('confirmReturnBtn').addEventListener('click', () => {
        // [新增] 触发退出提醒
        BackupReminderManager.triggerOnExitReminder();
        closeIframeModal();
    });
    document.getElementById('cancelReturnBtn').addEventListener('click', hideReturnConfirmation);
    
    const gestureCaptureZone = document.getElementById('gestureCaptureZone');
    let startX = 0, startY = 0, currentX = 0, isIframeDragging = false, isSwipeIntent = false;
    gestureCaptureZone.addEventListener('touchstart', (e) => {
        if(currentConfig.settings?.jellyBall?.swipeBack === false) return;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        isIframeDragging = true;
        isSwipeIntent = false;
        iframeModalContent.classList.add('dragging');
    }, { passive: true });
    window.addEventListener('touchmove', (e) => {
        if (!isIframeDragging || returnConfirmationToast.classList.contains('show')) return;
        currentX = e.touches[0].clientX;
        const diffX = currentX - startX;
        if (diffX > 0) {
            if (!isSwipeIntent) {
                const diffY = Math.abs(e.touches[0].clientY - startY);
                if (diffX > 10 && diffX > diffY) {
                    isSwipeIntent = true;
                } else if (diffY > 10) {
                    isIframeDragging = false;
                    return;
                }
            }
            if (isSwipeIntent) {
                e.preventDefault();
                iframeModalContent.style.transform = `translateX(${diffX}px)`;
            }
        }
    }, { passive: false });
    window.addEventListener('touchend', (e) => {
        if (!isIframeDragging) return;
        isIframeDragging = false;
        iframeModalContent.classList.remove('dragging');
        iframeModalContent.style.transform = '';
        const diffX = currentX - startX;
        const closeThreshold = window.innerWidth / 3.5;
        if (isSwipeIntent && diffX > closeThreshold && !returnConfirmationToast.classList.contains('show')) {
            showReturnConfirmation();
        }
        startX = 0; currentX = 0; startY = 0; isSwipeIntent = false;
    });

    async function nukeAllData() {
        if (!checkConfig(true)) return;
        const btn = document.getElementById('nukeDataBtn');
        const originalText = btn.textContent;

        const confirmation = confirm("⚠️ 极度危险操作！\n\n这将永久删除您的所有数据，包括：\n\n- 所有本地设置 (主题、GitHub配置等)\n- GitHub仓库中的 `config.json` (所有按钮和设置)\n- GitHub仓库中的所有上传的项目和文件\n\n此操作不可逆，将使应用恢复到空白的初始状态。确定要继续吗？");
        if (!confirmation) return;
        
        btn.disabled = true;
        
        try {
            btn.textContent = '获取仓库内容...';
            updateSyncStatus('syncing', '正在执行重置...');
            
            const rootContentsUrl = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/`;
            const rootContentsRes = await fetch(rootContentsUrl, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` } });
            
            if (!rootContentsRes.ok) {
                let errorMsg = '无法获取仓库内容。';
                try {
                    const errorData = await rootContentsRes.json();
                    errorMsg = errorData.message || errorMsg;
                } catch (e) { /* ignore json parsing error */ }
                throw new Error(errorMsg);
            }

            const items = await rootContentsRes.json();
            const foldersToNuke = ['projects', 'memory', 'data_sync'];
            
            let i = 0;
            for (const item of items) {
                i++;
                btn.textContent = `删除中 (${i}/${items.length})...`;
                if (item.path === 'config.json') {
                    await deleteFromGithub(item.path, 'NUKE: Deleting config file', item.sha, true);
                } else if (item.type === 'dir' && foldersToNuke.includes(item.name)) {
                    await deleteGithubFolder(item.path);
                }
            }
            btn.textContent = '正在清空本地...';
            localStorage.clear();
            
            alert('所有云端及本地数据已清空。页面将刷新。');
            location.reload();

        } catch (error) {
            const userMessage = await handleApiError("重置操作", error);
            updateSyncStatus('error', userMessage);
            alert(`重置失败: ${userMessage}`);
            btn.textContent = '重置失败';
        } finally {
            setTimeout(() => {
                btn.disabled = false;
                btn.textContent = originalText;
            }, 3000);
        }
    }
    document.getElementById('nukeDataBtn').addEventListener('click', nukeAllData);
    
    // ===== [START] MEMORY APP LOGIC =====
    let memoryCache = null; // [修复] 将 memoryCache 提升到模块共享作用域
    // [新增] 基于 IndexedDB 的图片持久化缓存
    const ImageCacheDB = (() => {
        let db;
        const DB_NAME = 'JellyfishImageCache';
        const STORE_NAME = 'photo_blobs';
        const DB_VERSION = 1;

        // 初始化/打开数据库
        async function init() {
            return new Promise((resolve, reject) => {
                if (db) {
                    resolve(db);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.error);
                    reject("IndexedDB 初始化失败。");
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB 图片缓存库已准备就绪。");
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    // 当数据库首次创建或版本升级时调用
                    const store = event.target.result.createObjectStore(STORE_NAME, { keyPath: 'path' });
                    console.log("IndexedDB 对象存储空间已创建。");
                };
            });
        }

        // 存储图片 Blob
        async function set(path, blob) {
            if (!db) await init();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put({ path, blob });
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error('无法将图片存入 IndexedDB:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // 获取图片 Blob
        async function get(path) {
            if (!db) await init();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(path);
                request.onsuccess = () => {
                    resolve(request.result ? request.result.blob : null);
                };
                request.onerror = (event) => {
                    console.error('无法从 IndexedDB 读取图片:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        return { init, set, get };
    })();

    const MemoryApp = (() => {
        const MEMORY_DATA_PATH = 'memory/data.json';
        const MEMORY_PHOTOS_PATH = 'memory/photos/';
        let memoryDataSha = null;
        let isSaving = false;
        let saveTimeout = null;

        
        const ui = {
            modal: document.getElementById('memoryModal'),
            appContainer: document.getElementById('memoryAppContainer'),
            status: document.getElementById('memory-sync-status'),
            folderList: document.getElementById('folder-list-container'),
            notesList: document.getElementById('notes-list-container'),
            albumList: document.getElementById('album-list-container'),
            photoList: document.getElementById('photo-list-container'),
            photoUploader: document.getElementById('photo-uploader'),
        memoManageControls: document.getElementById('memo-management-controls'),
        albumManageControls: document.getElementById('album-management-controls'),
        photoManageControls: document.getElementById('photo-management-controls'),
        noteManageControls: document.getElementById('note-management-controls'),
            folderModal: document.getElementById('memoryFolderModal'),
            photoDetailsModal: document.getElementById('memoryPhotoDetailsModal'),
            photoViewer: document.getElementById('memoryPhotoViewerOverlay'),
            photosetToggleContainer: document.getElementById('photoset-toggle-container'),
            photosetToggle: document.getElementById('create-photoset-toggle'),
            categorySelector: document.getElementById("categorySelector"),
            projectSelector: document.getElementById("projectSelector"),
            fileList: document.getElementById("fileList"), 
            fileListStatus: document.getElementById("fileListStatus"), 
            fileUploader: document.getElementById("fileUploader"), 
            selectFileBtn: document.getElementById("selectFileBtn"), 
            selectedFileName: document.getElementById("selectedFileName"), 
            fileNameInput: document.getElementById("fileNameInput"), 
            uploadBtn: document.getElementById("uploadBtn"), 
            progressContainer: document.getElementById("progressContainer"), 
            progressBar: document.getElementById("uploadProgressBar")
        };

    const state = {
        currentSection: null,
        isMemoManageMode: false, memoFoldersToDelete: [],
        isAlbumManageMode: false, albumFoldersToDelete: [],
        isPhotoManageMode: false, photosToDelete: [],
        isNoteManageMode: false, notesToDelete: [],
        currentMemoFolderId: null, currentNoteId: null, currentAlbumId: null,
        folderModalContext: null,
        viewerContext: { items: [], index: -1 },
        photoUploadQueue: [],
        isSavingPhoto: false,
        skipAllPhotoDetails: false, // [新增] 用于标记是否跳过后续所有照片详情
        cloudDriveRequestToken: null, // [新增] 为文件夹加载请求创建一个唯一令牌
    };

        function getInitialData() {
            return {
                memo: { folders: [{ id: Date.now(), name: "默认文件夹" }], notes: [] },
                album: { folders: [{ id: Date.now() + 1, name: "我的照片" }], items: [] }
            };
        }

        function updateStatus(text, isError = false, reason = '') { ui.status.textContent = isError && reason ? `${text}: ${reason}` : text; ui.status.style.color = isError ? '#e53e3e' : 'inherit'; }

        async function syncWithGithub() {
                        if (!checkConfig(false)) return;
            updateStatus('同步中...');
            const { data, error } = await fetchFromGithub(MEMORY_DATA_PATH);
            if (error) { updateStatus('同步失败', true, error); return; }
            memoryCache = data ? JSON.parse(b64_to_utf8(data.content)) : getInitialData();
            memoryDataSha = data ? data.sha : null;
            updateStatus('已同步');
            if (!memoryCache.memo) memoryCache.memo = { folders: [], notes: [] };
            if (!memoryCache.album) memoryCache.album = { folders: [], items: [] };
            if (memoryCache.album.photos && !memoryCache.album.items) {
                    memoryCache.album.items = memoryCache.album.photos.map(p => ({...p, type: 'photo'}));
                    delete memoryCache.album.photos;
                }
        }
        
         function scheduleSave() {
            if (isSaving) return;
            clearTimeout(saveTimeout);
            updateStatus('有未保存的更改');
            saveTimeout = setTimeout(async () => {
                isSaving = true;
                updateStatus('保存中...');
                const content = utf8_to_b64(JSON.stringify(memoryCache, null, 2));
                const result = await saveToGithub(MEMORY_DATA_PATH, content, 'Update memory data'); 
                
                // [修改] 增加保存成功或失败后的状态更新
                if (result.sha) {
                    updateStatus('已同步');
                } else { 
                    updateStatus('保存失败', true, result.error); 
                }
                isSaving = false;
            }, 1500);
        }


        
        function showPage(pageId) { ui.appContainer.querySelectorAll(':scope > .page').forEach(p => p.classList.remove('active')); ui.appContainer.querySelector(`#${pageId}`).classList.add('active'); }
        function showView(viewId, sectionId) { const section = ui.appContainer.querySelector(`#${sectionId}`); section.querySelectorAll(':scope > .page').forEach(p => p.classList.remove('active')); section.querySelector(`#${viewId}`).classList.add('active'); showPage(sectionId); }

        function renderMemoFolders() {
            ui.folderList.innerHTML = '';
            memoryCache.memo.folders.forEach(folder => {
                const isSelected = state.memoFoldersToDelete.includes(folder.id);
                const el = document.createElement('div');
                el.className = `folder-item ${state.isMemoManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`;
                el.dataset.folderId = folder.id;
                el.dataset.action = "open-memo-folder";
                // 新增了 sort-handle 和 rename-icon
                el.innerHTML = `<span class="sort-handle memo-sort-handle" title="按住拖拽排序">☰</span><input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}><div class="folder-icon">📁</div><div class="folder-name">${folder.name}</div><span class="rename-icon" data-action="rename-memo-folder" title="重命名">&#9998;</span>`;
                ui.folderList.appendChild(el);
            });
            if (memoryCache.memo.folders.length === 0) ui.folderList.innerHTML = `<p class="empty-list-placeholder">没有文件夹</p>`;
        }

        function renderNotes() {
            ui.notesList.innerHTML = '';
            const notesInFolder = memoryCache.memo.notes.filter(n => n.folderId === state.currentMemoFolderId).sort((a, b) => (b.isPinned ? 1 : 0) - (a.isPinned ? 1 : 0) || b.timestamp - a.timestamp);
            notesInFolder.forEach(note => {
                const isSelected = state.notesToDelete.includes(note.id); // 检查是否被选中
                const el = document.createElement('div');
                // 添加管理模式相关的 class
                el.className = `note-item ${note.isPinned ? 'pinned' : ''} ${state.isNoteManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`; 
                el.dataset.noteId = note.id;
                el.dataset.action = "open-note";
                const preview = (note.content || '').substring(0, 100).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const date = new Date(note.timestamp).toLocaleDateString('zh-CN');
                // 添加复选框，并将图标从 📌 替换为 "置顶"
                el.innerHTML = `<input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}><div class="note-content-area"><div class="note-title">${note.title || '无标题'}</div><div class="note-preview">${preview || '没有内容'}</div><div class="note-timestamp">${date}</div></div><button class="pin-btn" data-action="pin-note" data-note-id="${note.id}" title="置顶">置顶</button>`;
                ui.notesList.appendChild(el);
            });
            if (notesInFolder.length === 0) ui.notesList.innerHTML = `<p class="empty-list-placeholder">没有笔记</p>`;
        }

        function renderAlbumFolders() {
            ui.albumList.innerHTML = '';
            // [修改] 如果存在排序，则使用排序后的数组，否则使用原数组
            const foldersToRender = memoryCache.album.folders;

            foldersToRender.forEach(folder => {
                const itemCount = memoryCache.album.items.filter(p => p.albumId === folder.id).length;
                const isSelected = state.albumFoldersToDelete.includes(folder.id);
                const el = document.createElement('div');
                el.className = `album-item ${state.isAlbumManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`;
                el.dataset.albumId = folder.id;
                el.dataset.action = "open-album-folder";
                el.innerHTML = `<span class="sort-handle" title="按住拖拽排序">☰</span><input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}><div><div class="folder-icon">🖼️</div><div class="folder-name">${folder.name}</div></div><div class="album-info">${itemCount} 个项目</div><span class="rename-icon" data-action="rename-album" title="重命名">&#9998;</span>`;


                
                // [核心修正] 处理自定义背景逻辑
                if (folder.background) {
                    el.classList.add('has-custom-bg');
                    el.style.backgroundSize = 'cover';
                    el.style.backgroundPosition = 'center';
                    
                    // 判断 background 是 Base64 还是路径
                    if (folder.background.startsWith('data:image')) {
                        // 兼容可能存在的旧数据
                        el.style.backgroundImage = `url(${folder.background})`;
                    } else {
                        // 新的路径方案，需要异步获取安全URL
                        getSecureFileUrl(folder.background).then(secureUrl => {
                            if (secureUrl) {
                                el.style.backgroundImage = `url(${secureUrl})`;
                            }
                        });
                    }
                }

                ui.albumList.appendChild(el);
            });
            if (foldersToRender.length === 0) ui.albumList.innerHTML = `<p class="empty-list-placeholder">没有相册</p>`;
        }

        function renderPhotos() {
            if (photoObserver) photoObserver.disconnect();
            ui.photoList.innerHTML = '';
            
            const itemsInAlbum = memoryCache.album.items
                .filter(p => p.albumId === state.currentAlbumId)
                .sort((a, b) => b.timestamp - a.timestamp);
            
            if (itemsInAlbum.length === 0) {
                ui.photoList.innerHTML = `<p class="empty-list-placeholder">没有照片</p>`;
                return;
            }

            const fragment = document.createDocumentFragment();
            itemsInAlbum.forEach(item => {
                const isSelected = state.photosToDelete.includes(item.id);
                const el = document.createElement('div');
                el.dataset.itemId = item.id;
                
                let imgSrc = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // Placeholder
                let firstPhotoPath = '';
                
                if (item.type === 'photoset') {
                    el.className = `photo-item-set ${state.isPhotoManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`;
                    el.dataset.action = "open-item";
                    let stackHtml = '';
                    const photosToDisplay = item.photos.slice(0, 3);
                    firstPhotoPath = photosToDisplay.length > 0 ? photosToDisplay[photosToDisplay.length - 1].path : '';
                     
                    for (let i = photosToDisplay.length - 1; i >= 0; i--) {
                        stackHtml += `<img data-src="${photosToDisplay[i].path}" class="photo-stack-img lazyload" loading="lazy" src="${imgSrc}">`;
                    }
                    const title = (item.title || '照片集');
                    el.innerHTML = `<input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}>${stackHtml}<div class="photo-title-overlay">${title}</div><div class="count-overlay">${item.photos.length} 张</div>`;
                } else {
                    el.className = `photo-item ${state.isPhotoManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`;
                    el.dataset.action = "open-item";
                    firstPhotoPath = item.path;
                    const title = (item.title || '');
                    el.innerHTML = `<input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}><img data-src="${firstPhotoPath}" class="lazyload" alt="${title}" loading="lazy" src="${imgSrc}"><div class="photo-title-overlay">${title}</div>`;
                }
                fragment.appendChild(el);
            });

            ui.photoList.appendChild(fragment);

            const lazyImages = ui.photoList.querySelectorAll('.lazyload');
            lazyImages.forEach(img => photoObserver.observe(img));
        }
        
        async function openPhotoViewer(items, initialIndex) {
            if (!items || items.length === 0) return;
            state.viewerContext = { items, index: initialIndex };
            ui.photoViewer.classList.add('active');
            await updatePhotoViewerContent();
        }

        async function updatePhotoViewerContent() {
            const { items, index } = state.viewerContext;
            if (!items || items.length === 0 || index < 0) { closePhotoViewer(); return; }
            
            const currentItem = items[index];
            let photo, title, description, timestamp, isSet, setIndex = 0, setLength = 0;

            if (currentItem.type === 'photoset') {
                isSet = true;
                setIndex = currentItem.internalIndex || 0;
                setLength = currentItem.photos.length;
                photo = currentItem.photos[setIndex];
                title = currentItem.title;
                description = currentItem.description;
                timestamp = currentItem.timestamp;
            } else {
                isSet = false;
                photo = currentItem;
                title = photo.title;
                description = photo.description;
                timestamp = photo.timestamp;
            }

            const viewerImg = ui.photoViewer.querySelector('#viewer-img');
            viewerImg.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // Placeholder
            
            const photoUrl = await getSecureFileUrl(photo.path);
            viewerImg.src = photoUrl;
            ui.photoViewer.querySelector('#viewer-title').textContent = title || '';
            ui.photoViewer.querySelector('#viewer-description').textContent = description || '';
            ui.photoViewer.querySelector('#viewer-timestamp').textContent = new Date(timestamp).toLocaleString('zh-CN');
            
            // [新增] 更新下载按钮逻辑
            const downloadBtn = document.getElementById('download-photo-btn');
            if (downloadBtn) {
                downloadBtn.href = photoUrl;
                // 从路径中提取文件名，如果标题存在则优先使用标题作为文件名
                const originalFilename = photo.path.split('/').pop();
                const extension = originalFilename.includes('.') ? '.' + originalFilename.split('.').pop() : '.jpg';
                const smartTitle = title ? title.replace(/[/\\?%*:|"<>]/g, '-') : ''; // 清理标题中的非法字符
                downloadBtn.download = smartTitle ? `${smartTitle}${extension}` : originalFilename;
                downloadBtn.style.display = 'flex';
            }

            const prevBtn = document.getElementById('prev-photo-btn');
            const nextBtn = document.getElementById('next-photo-btn');
            const counter = document.getElementById('viewer-counter');

            const canGoPrev = (isSet && setIndex > 0) || index > 0;
            const canGoNext = (isSet && setIndex < setLength - 1) || index < items.length - 1;

            prevBtn.style.display = canGoPrev ? 'flex' : 'none';
            nextBtn.style.display = canGoNext ? 'flex' : 'none';

            if (isSet) {
                counter.textContent = `${setIndex + 1} / ${setLength}`;
                counter.style.display = 'block';
            } else {
                counter.style.display = 'none';
            }
        }

        function closePhotoViewer() { 
            document.getElementById('viewer-img-container').classList.remove('zoomed-long'); // 重置缩放状态
            state.viewerContext.items.forEach(item => { if(item.type === 'photoset') delete item.internalIndex; });
            ui.photoViewer.classList.remove('active'); 
            // [新增] 隐藏下载按钮
            const downloadBtn = document.getElementById('download-photo-btn');
            if (downloadBtn) {
                downloadBtn.style.display = 'none';
            }
        }
        async function changePhotoInViewer(direction) {
            const { items, index } = state.viewerContext;
            const currentItem = items[index];
            
            if (currentItem.type === 'photoset') {
                const newSetIndex = (currentItem.internalIndex || 0) + direction;
                if (newSetIndex >= 0 && newSetIndex < currentItem.photos.length) {
                    currentItem.internalIndex = newSetIndex;
                } else {
                    changeViewerItem(direction);
                }
            } else {
                changeViewerItem(direction);
            }
            await updatePhotoViewerContent();
        }

        function changeViewerItem(direction) {
            let newIndex = state.viewerContext.index + direction;
            if (newIndex >= 0 && newIndex < state.viewerContext.items.length) {
                state.viewerContext.index = newIndex;
                    const newItem = state.viewerContext.items[newIndex];
                if (newItem.type === 'photoset') {
                    newItem.internalIndex = direction > 0 ? 0 : newItem.photos.length - 1;
                }
            }
        }
        
        const actions = {
            'goto-memo': () => { showPage('memo-section'); state.currentSection = 'memo'; document.getElementById('memory-modal-title').textContent = '备忘录'; renderMemoFolders(); },
            'goto-album': () => { showPage('album-section'); state.currentSection = 'album'; document.getElementById('memory-modal-title').textContent = '相册'; renderAlbumFolders(); },
            'goto-cloud': () => { 
    showPage('cloud-drive-section'); 
    state.currentSection = 'cloud'; 
    document.getElementById('memory-modal-title').textContent = '文件夹'; 
    populateDriveCategorySelector(); 
    populateDriveProjectSelector(); // 新增此行
    fetchFilesForSelectedProject(); 
},

            'back-to-hub': () => { showPage('hub-view'); state.currentSection = null; document.getElementById('memory-modal-title').textContent = '记忆'; },
            'add-memo-folder': () => { state.folderModalContext = { type: 'memo', id: null }; document.getElementById('folder-modal-title').textContent = '新文件夹'; ui.folderModal.querySelector('#folder-name-input').value = ''; ui.folderModal.classList.add('show'); },
            'add-album-folder': () => {
                if (memoryCache.album.folders.length >= 100) { alert('相册数量已达上限（100个），请整理后再创建。'); return; }
                state.folderModalContext = { type: 'album', id: null }; document.getElementById('folder-modal-title').textContent = '新相册'; ui.folderModal.querySelector('#folder-name-input').value = ''; ui.folderModal.classList.add('show'); },
            'close-folder-modal': () => ui.folderModal.classList.remove('show'),
            'save-folder': () => {
                const { type, id } = state.folderModalContext;
                const name = ui.folderModal.querySelector('#folder-name-input').value.trim();
                if (!name) return alert('名称不能为空');
                const list = memoryCache[type].folders;
                if (id) {
                    const item = list.find(f => f.id === id);
                    if (item) item.name = name;
                } else {
                    list.push({ id: Date.now(), name });
                }
                ui.folderModal.classList.remove('show');
                if (type === 'memo') renderMemoFolders(); else renderAlbumFolders();
                scheduleSave();
            },
            // --- 在此下方新增 ---
            'rename-memo-folder': (target) => {
                const folderId = parseInt(target.closest('[data-folder-id]').dataset.folderId, 10);
                const folder = memoryCache.memo.folders.find(f => f.id === folderId);
                if (folder) {
                    const newName = prompt('请输入新的文件夹名称：', folder.name);
                    if (newName && newName.trim() && newName.trim() !== folder.name) {
                        folder.name = newName.trim();
                        renderMemoFolders();
                        scheduleSave();
                    }
                }
            },
            // --- 新增结束 ---
            'open-memo-folder': (target) => {
                const folderId = parseInt(target.closest('[data-folder-id]').dataset.folderId, 10);
                if (state.isMemoManageMode) {
                    const index = state.memoFoldersToDelete.indexOf(folderId);
                    if (index > -1) state.memoFoldersToDelete.splice(index, 1);
                    else state.memoFoldersToDelete.push(folderId);
                    renderMemoFolders();
                    return;
                }
                state.currentMemoFolderId = folderId;
                const folder = memoryCache.memo.folders.find(f => f.id === folderId);
                if (folder) document.getElementById('notes-view-title').textContent = folder.name;
                showView('notes-view', 'memo-section');
                renderNotes();
            },
            'open-album-folder': (target) => {
                const albumId = parseInt(target.closest('[data-album-id]').dataset.albumId, 10);
                if (state.isAlbumManageMode) {
                    const index = state.albumFoldersToDelete.indexOf(albumId);
                    if (index > -1) state.albumFoldersToDelete.splice(index, 1);
                    else state.albumFoldersToDelete.push(albumId);
                    renderAlbumFolders();
                    return;
                }
                state.currentAlbumId = albumId;
                const folder = memoryCache.album.folders.find(f => f.id === albumId);
                if (folder) document.getElementById('photo-grid-title').textContent = folder.name;
                showView('photo-grid-view', 'album-section');
                renderPhotos();
            },
            'back-to-memo-folders': () => {
                if (document.getElementById('note-editor-view').classList.contains('active')) {
                   actions['cancel-note']();
                } else {
                   showView('folder-view', 'memo-section'); state.currentMemoFolderId = null;
                }
            },
            'back-to-album-folders': () => { showView('album-folder-view', 'album-section'); state.currentAlbumId = null; },
            'add-note': () => {
                state.currentNoteId = null;
                document.getElementById('note-title-input').value = '';
                document.getElementById('note-content-editor').innerHTML = ''; // 修正点：清空 contenteditable div
                document.querySelector('[data-action="delete-note"]').style.display = 'none';
                showView('note-editor-view', 'memo-section');
            },

         'open-note': (target) => {
            const noteId = parseInt(target.closest('[data-note-id]').dataset.noteId, 10);
            if (state.isNoteManageMode) {
                const index = state.notesToDelete.indexOf(noteId);
                if (index > -1) state.notesToDelete.splice(index, 1);
                else state.notesToDelete.push(noteId);
                renderNotes();
                return;
            }
            const note = memoryCache.memo.notes.find(n => n.id === noteId);
            if (note) {
                state.currentNoteId = note.id;
                document.getElementById('note-title-input').value = note.title;
                document.getElementById('note-content-editor').innerHTML = note.content; 
                document.querySelector('[data-action="delete-note"]').style.display = 'inline-block';
                showView('note-editor-view', 'memo-section');
            }
        },

            'save-note': () => {
                const title = document.getElementById('note-title-input').value.trim();
                // 从 contenteditable div 获取 innerHTML
                const content = document.getElementById('note-content-editor').innerHTML;
                const now = Date.now();
                if (state.currentNoteId) {
                    const note = memoryCache.memo.notes.find(n => n.id === state.currentNoteId);
                    if (note) {
                        note.title = title;
                        note.content = content;
                        note.timestamp = now;
                    }
                } else {
                    memoryCache.memo.notes.push({ id: now, folderId: state.currentMemoFolderId, title, content, timestamp: now, isPinned: false });
                }
                showView('notes-view', 'memo-section');
                renderNotes();
                scheduleSave();
            },

            'cancel-note': () => {
                showView('notes-view', 'memo-section');
            },
            'delete-note': () => {
                if (state.currentNoteId && confirm('确定要删除这篇笔记吗？')) {
                    memoryCache.memo.notes = memoryCache.memo.notes.filter(n => n.id !== state.currentNoteId);
                    showView('notes-view', 'memo-section');
                    renderNotes();
                    scheduleSave();
                }
            },
            'pin-note': (target) => {
                const noteId = parseInt(target.dataset.noteId, 10);
                const note = memoryCache.memo.notes.find(n => n.id === noteId);
                if(note) { note.isPinned = !note.isPinned; }
                renderNotes();
                scheduleSave();
            },

            'toggle-memo-manage': (target) => {
                state.isMemoManageMode = !state.isMemoManageMode;
                target.textContent = state.isMemoManageMode ? '完成' : '管理';
                ui.memoManageControls.classList.toggle('active', state.isMemoManageMode);
                if (!state.isMemoManageMode) state.memoFoldersToDelete = [];
                renderMemoFolders();
            },
            'select-all-memo': () => {
                if (state.memoFoldersToDelete.length === memoryCache.memo.folders.length) {
                    state.memoFoldersToDelete = [];
                } else {
                    state.memoFoldersToDelete = memoryCache.memo.folders.map(f => f.id);
                }
                renderMemoFolders();
            },
            'delete-selected-memo': () => {
                if (state.memoFoldersToDelete.length === 0) return;
                let notesToDeleteCount = 0;
                memoryCache.memo.notes.forEach(note => {
                    if (state.memoFoldersToDelete.includes(note.folderId)) {
                        notesToDeleteCount++;
                    }
                });
                if (confirm(`确定要删除选中的 ${state.memoFoldersToDelete.length} 个文件夹及其包含的 ${notesToDeleteCount} 篇笔记吗？`)) {
                    memoryCache.memo.notes = memoryCache.memo.notes.filter(n => !state.memoFoldersToDelete.includes(n.folderId));
                    memoryCache.memo.folders = memoryCache.memo.folders.filter(f => !state.memoFoldersToDelete.includes(f.id));
                    state.memoFoldersToDelete = [];
                    renderMemoFolders();
                    scheduleSave();
                }
            },
            'toggle-album-manage': (target) => {
                state.isAlbumManageMode = !state.isAlbumManageMode;
                target.textContent = state.isAlbumManageMode ? '完成' : '管理';
                ui.albumManageControls.classList.toggle('active', state.isAlbumManageMode);
                if (!state.isAlbumManageMode) state.albumFoldersToDelete = [];
                
                // [新增] 替换全局漫游按钮的逻辑
                const globalWanderBtn = document.querySelector('#album-folder-view [data-action="wander-global"]');
                if (globalWanderBtn) {
                     if (state.isAlbumManageMode) {
                        // 在管理模式下，全局漫游没有意义，可以隐藏或禁用
                        globalWanderBtn.style.display = 'none';
                    } else {
                        // 退出管理模式时恢复
                        globalWanderBtn.style.display = 'inline-block';
                    }
                }

                renderAlbumFolders();
            },

            'select-all-album': () => {
                if (state.albumFoldersToDelete.length === memoryCache.album.folders.length) {
                    state.albumFoldersToDelete = [];
                } else {
                    state.albumFoldersToDelete = memoryCache.album.folders.map(f => f.id);
                }
                renderAlbumFolders();
            },
            'delete-selected-album': async () => {
                if (state.albumFoldersToDelete.length === 0) return;
                const itemsToDelete = memoryCache.album.items.filter(p => state.albumFoldersToDelete.includes(p.albumId));
                let photoCount = 0;
                itemsToDelete.forEach(item => { photoCount += item.type === 'photoset' ? item.photos.length : 1; });
                if (confirm(`确定要删除选中的 ${state.albumFoldersToDelete.length} 个相册及其包含的 ${photoCount} 张照片吗？`)) {
                    await Promise.all(itemsToDelete.map(item => {
                        if (item.type === 'photoset') return Promise.all(item.photos.map(p => deleteFromGithub(p.path, `Delete photo from set`, p.sha, true)));
                        else return deleteFromGithub(item.path, `Delete photo`, item.sha, true);
                    }));
                    memoryCache.album.items = memoryCache.album.items.filter(p => !state.albumFoldersToDelete.includes(p.albumId));
                    memoryCache.album.folders = memoryCache.album.folders.filter(f => !state.albumFoldersToDelete.includes(f.id));
                    state.albumFoldersToDelete = [];
                    renderAlbumFolders();
                    scheduleSave();
                }
            },
        'toggle-note-manage': (target) => {
            state.isNoteManageMode = !state.isNoteManageMode;
            target.textContent = state.isNoteManageMode ? '完成' : '管理';
            ui.noteManageControls.classList.toggle('active', state.isNoteManageMode);
            if (!state.isNoteManageMode) state.notesToDelete = [];
            renderNotes();
        },
        'select-all-notes': () => {
            const currentFolderNotes = memoryCache.memo.notes.filter(n => n.folderId === state.currentMemoFolderId);
            if (state.notesToDelete.length === currentFolderNotes.length) {
                state.notesToDelete = [];
            } else {
                state.notesToDelete = currentFolderNotes.map(n => n.id);
            }
            renderNotes();
        },
        'delete-selected-notes': () => {
            if (state.notesToDelete.length === 0) return;
            if (confirm(`确定要删除选中的 ${state.notesToDelete.length} 篇笔记吗？`)) {
                memoryCache.memo.notes = memoryCache.memo.notes.filter(n => !state.notesToDelete.includes(n.id));
                state.notesToDelete = [];
                renderNotes();
                scheduleSave();
            }
        },
        'move-selected-notes': () => {
            if (state.notesToDelete.length === 0) {
                alert('请先选择要移动的笔记。');
                return;
            }
            const destSelector = document.getElementById('memo-destination-selector');
            destSelector.innerHTML = '';
            memoryCache.memo.folders.forEach(folder => {
                if (folder.id !== state.currentMemoFolderId) {
                    const option = document.createElement('option');
                    option.value = folder.id;
                    option.textContent = folder.name;
                    destSelector.appendChild(option);
                }
            });

            if (destSelector.options.length === 0) {
                alert('没有其他文件夹可以移动。');
                return;
            }
            document.getElementById('moveNotesModal').classList.add('show');
        },
        'close-move-notes-modal': () => {
            document.getElementById('moveNotesModal').classList.remove('show');
        },
        'confirm-move-notes': () => {
            const destFolderId = parseInt(document.getElementById('memo-destination-selector').value, 10);
            if (!destFolderId) {
                alert('无效的目标文件夹。');
                return;
            }

            memoryCache.memo.notes.forEach(note => {
                if (state.notesToDelete.includes(note.id)) {
                    note.folderId = destFolderId;
                }
            });

            state.notesToDelete = [];
            renderNotes();
            scheduleSave();
            document.getElementById('moveNotesModal').classList.remove('show');
            showTopToast('笔记移动成功！', 2000);
        },

             'toggle-photo-manage': (target) => {
                state.isPhotoManageMode = !state.isPhotoManageMode;
                target.textContent = state.isPhotoManageMode ? '完成' : '管理';
                ui.photoManageControls.classList.toggle('active', state.isPhotoManageMode);
                if (!state.isPhotoManageMode) state.photosToDelete = [];

                // [修改] 替换漫游按钮的逻辑
                const wanderBtn = document.querySelector('#photo-grid-view [data-action="wander-local"], #photo-grid-view [data-action="set-album-bg"]'); // 确保能选中按钮
                if (wanderBtn) {
                    if (state.isPhotoManageMode) {
                        wanderBtn.innerHTML = '🖼️'; // [修改] 使用emoji图标
                        wanderBtn.dataset.action = 'set-album-bg';
                        wanderBtn.title = '设置相册背景'; // [新增] 增加提示
                        wanderBtn.classList.remove('wander-btn');
                    } else {
                        wanderBtn.innerHTML = '💫'; // 恢复emoji
                        wanderBtn.dataset.action = 'wander-local';
                        wanderBtn.title = '漫游此相册'; // [新增] 恢复提示
                        wanderBtn.classList.add('wander-btn');
                    }
                }
                
                renderPhotos();
            },

            // [V2 修正] 使用文件上传机制设置相册背景
            'set-album-bg': () => {
                // 1. 创建一个文件选择器
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';

                // 2. 监听文件选择事件
                input.onchange = async e => {
                    const file = e.target.files[0];
                    if (!file) return;

                    // 3. 立即显示加载状态，提升用户体验
                    showTopToast('正在上传背景图...', 60000); // 长时间提示以防上传慢

                    try {
                        // 4. 定义上传路径和唯一文件名
                        const ALBUM_BG_PATH = 'memory/album_backgrounds/';
                        const path = `${ALBUM_BG_PATH}bg-${state.currentAlbumId}-${Date.now()}.${file.name.split('.').pop()}`;
                        
                        // 5. 调用文件上传函数（复用已有逻辑）
                        const result = await uploadFileViaGitData({
                            file,
                            path,
                            commitMessage: `Update album background for ID ${state.currentAlbumId}`,
                            onProgress: (p) => { /* 可以在这里更新提示，暂时省略 */ }
                        });

                        // 6. 核心：只保存返回的路径
                        const album = memoryCache.album.folders.find(f => f.id === state.currentAlbumId);
                        if (album) {
                            album.background = result.path; // 只保存路径！
                            scheduleSave();
                            renderAlbumFolders(); // 重新渲染当前相册列表，即时看到效果
                            renderPhotos(); // 刷新照片视图，背景图可能也需要在这里更新
                            showTopToast('相册背景已成功设置！', 2000);
                        }
                    } catch (error) {
                        console.error("Failed to upload album background:", error);
                        const userMessage = await handleApiError("上传背景图", error);
                        alert(`上传失败: ${userMessage}`);
                        showTopToast('上传背景图失败', 3000);
                    }
                };
                
                // 7. 触发文件选择
                input.click();
            },

             'select-all-photos': () => {
                const currentAlbumItems = memoryCache.album.items.filter(p => p.albumId === state.currentAlbumId);
                if (state.photosToDelete.length === currentAlbumItems.length) {
                    state.photosToDelete = [];
                } else {
                    state.photosToDelete = currentAlbumItems.map(p => p.id);
                }
                renderPhotos();
            },
            'delete-selected-photos': async () => {
                if (state.photosToDelete.length === 0) return;
                const itemsToDelete = memoryCache.album.items.filter(p => state.photosToDelete.includes(p.id));
                let photoCount = 0;
                itemsToDelete.forEach(item => { photoCount += item.type === 'photoset' ? item.photos.length : 1; });
                if (confirm(`确定要删除选中的 ${itemsToDelete.length} 个项目(共 ${photoCount} 张照片)吗？`)) {
                    await Promise.all(itemsToDelete.map(item => {
                        if (item.type === 'photoset') return Promise.all(item.photos.map(p => deleteFromGithub(p.path, `Delete photo from set`, p.sha, true)));
                        else return deleteFromGithub(item.path, `Delete photo`, item.sha, true);
                    }));
                    memoryCache.album.items = memoryCache.album.items.filter(p => !state.photosToDelete.includes(p.id));
                    state.photosToDelete = [];
                    renderPhotos(); scheduleSave();
                }
            },
            'save-photo-details': () => { state.isSavingPhoto = true; },
            'skip-photo-details': () => {
                // [修改] 如果当前是多文件上传，点击跳过将跳过后续所有
                if (state.photoUploadQueue.length > 1) {
                    state.skipAllPhotoDetails = true;
                }
                state.isSavingPhoto = false; 
                document.getElementById('photo-title-input').value = ''; 
                document.getElementById('photo-desc-input').value = '';
            },

            'open-item': (target) => {
                const itemId = parseInt(target.closest('[data-item-id]').dataset.itemId, 10);
                 if (state.isPhotoManageMode) {
                    const index = state.photosToDelete.indexOf(itemId);
                    if (index > -1) state.photosToDelete.splice(index, 1);
                    else state.photosToDelete.push(itemId);
                    renderPhotos();
                    return;
                }
                const itemsInAlbum = memoryCache.album.items.filter(p => p.albumId === state.currentAlbumId).sort((a,b) => b.timestamp - a.timestamp);
                const itemIndex = itemsInAlbum.findIndex(p => p.id === itemId);
                openPhotoViewer(itemsInAlbum, itemIndex);
            },
            'close-viewer': () => closePhotoViewer(),
            'prev-photo': () => changePhotoInViewer(-1),
            'next-photo': () => changePhotoInViewer(1),

            'move-selected-photos': () => {
                if (state.photosToDelete.length === 0) {
                    alert('请先选择要移动的照片。');
                    return;
                }
                const destSelector = document.getElementById('album-destination-selector');
                destSelector.innerHTML = '';
                memoryCache.album.folders.forEach(folder => {
                    if (folder.id !== state.currentAlbumId) {
                        const option = document.createElement('option');
                        option.value = folder.id;
                        option.textContent = folder.name;
                        destSelector.appendChild(option);
                    }
                });

                if (destSelector.options.length === 0) {
                    alert('没有其他相册可以移动。');
                    return;
                }
                document.getElementById('movePhotosModal').classList.add('show');
            },
            'close-move-modal': () => {
                document.getElementById('movePhotosModal').classList.remove('show');
            },
            'confirm-move-photos': () => {
                const destAlbumId = parseInt(document.getElementById('album-destination-selector').value, 10);
                if (!destAlbumId) {
                    alert('无效的目标相册。');
                    return;
                }

                memoryCache.album.items.forEach(item => {
                    if (state.photosToDelete.includes(item.id)) {
                        item.albumId = destAlbumId;
                    }
                });

                state.photosToDelete = [];
                renderPhotos();
                scheduleSave();
                document.getElementById('movePhotosModal').classList.remove('show');
                showTopToast('照片移动成功！', 2000);
            },

            'rename-album': (target) => {
                const albumId = parseInt(target.closest('[data-album-id]').dataset.albumId, 10);
                const album = memoryCache.album.folders.find(f => f.id === albumId);

                if (album) {
                    const newName = prompt('请输入新的相册名称：', album.name);
                    if (newName && newName.trim() !== '' && newName.trim() !== album.name) {
                        album.name = newName.trim();
                        renderAlbumFolders(); // 重新渲染以显示新名称
                        scheduleSave();
                    }
                }
            },

            'wander-global': () => WanderView.start(memoryCache.album.items),
            'wander-local': () => WanderView.start(memoryCache.album.items.filter(p => p.albumId === state.currentAlbumId)),
            'close-wander-view': () => WanderView.close(),
            'toggle-player-collapse': () => WanderView.togglePlayerCollapse(),
        };

        async function processPhotoUploadQueue() {
            if (state.photoUploadQueue.length === 0) return;

            // [解决方案 1] 同步添加一个标记，确保在文件读取期间关闭页面也能触发提示。
            activePhotoUploadXHRs.push("photo_upload_session");

            const totalPhotos = state.photoUploadQueue.length;

            // [解决方案 2] 弹出一个长时存在的顶部提示框作为视觉反馈。
            showTopToast(`正在上传 ${totalPhotos} 张照片...`, 600000); // 持续10分钟或直到任务结束

            state.skipAllPhotoDetails = false;
            let isPhotoSetMode = false;
            const isBatch = totalPhotos > 1;
            ui.photosetToggleContainer.style.display = isBatch ? 'block' : 'none';
            ui.photosetToggle.checked = isBatch;

            let photosetData = { id: Date.now(), albumId: state.currentAlbumId, type: 'photoset', title: '', description: '', timestamp: Date.now(), photos: [] };
            
            try {
                for (let i = 0; i < totalPhotos; i++) {
                    const file = state.photoUploadQueue[i];
                    let title = '';
                    let description = '';
                    
                    let statusText = `上传中 (${i + 1}/${totalPhotos})`;
                    updateStatus(statusText);

                    const shouldShowModal = i === 0 || (!isPhotoSetMode && !state.skipAllPhotoDetails);

                    if (shouldShowModal) {
                        ui.photoDetailsModal.querySelector('#photo-details-modal-title').textContent = '添加照片信息';
                        ui.photoDetailsModal.querySelector('#upload-thumbnail').src = URL.createObjectURL(file);
                        ui.photoDetailsModal.classList.add('show');
                        
                        await new Promise(resolve => {
                            const saveHandler = () => { state.isSavingPhoto = true; resolve(); };
                            const skipHandler = () => { actions['skip-photo-details'](); state.isSavingPhoto = false; resolve(); };
                            
                            const saveBtn = ui.photoDetailsModal.querySelector('[data-action="save-photo-details"]');
                            const skipBtn = ui.photoDetailsModal.querySelector('[data-action="skip-photo-details"]');

                            saveBtn.addEventListener('click', saveHandler, { once: true });
                            skipBtn.addEventListener('click', skipHandler, { once: true });
                        });
                        
                        if (state.isSavingPhoto) {
                            title = document.getElementById('photo-title-input').value.trim();
                            description = document.getElementById('photo-desc-input').value.trim();
                        }
                        if (i === 0) isPhotoSetMode = document.getElementById('create-photoset-toggle').checked;
                        
                        ui.photoDetailsModal.classList.remove('show');
                        document.getElementById('photo-title-input').value = '';
                        document.getElementById('photo-desc-input').value = '';
                    }
                    
                    const photoData = await uploadPhoto(file, (percent) => {
                         // 此回调为空，因为用户不需要进度条
                    });
                    
                    if (photoData) {
                        if (isPhotoSetMode) {
                            photosetData.photos.push(photoData);
                            if (i === 0) {
                                photosetData.title = title;
                                photosetData.description = description;
                            }
                        } else {
                            memoryCache.album.items.push({
                                id: Date.now() + i, albumId: state.currentAlbumId, type: 'photo',
                                title: title, description: description, timestamp: Date.now(),
                                ...photoData
                            });
                        }
                    }
                } // 循环结束

                if (photosetData.photos.length > 0) {
                    memoryCache.album.items.push(photosetData);
                }

                showTopToast('所有照片上传完成!', 3000); // 显示最终成功状态
                updateStatus('上传完成!');
                state.photoUploadQueue = [];
                renderPhotos();
                scheduleSave();

            } catch (error) {
                showTopToast('照片上传失败，请检查网络或配置', 4000); // 显示最终失败状态
                updateStatus('上传失败', true, error.message);
                alert(error.message); 
                state.photoUploadQueue = []; 
            } finally {
                // [解决方案 1 清理] 无论成功或失败，都在任务结束后移除标记。
                const index = activePhotoUploadXHRs.indexOf("photo_upload_session");
                if (index > -1) {
                    activePhotoUploadXHRs.splice(index, 1);
                }
            }
        }



        function uploadPhoto(file, onProgressCallback) {
            return new Promise((resolve, reject) => {
                const extension = (file.name.split('.').pop() || 'jpg').toLowerCase();
                const newSafeFileName = `${Date.now()}_${Math.random().toString(36).substring(2, 10)}.${extension}`;
                const path = `${MEMORY_PHOTOS_PATH}${newSafeFileName}`;
                const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;

                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = async () => {
                    const contentB64 = reader.result.split(',')[1];
                    const body = { message: `Upload photo: ${newSafeFileName}`, content: contentB64, branch: 'main' };

                    const xhr = new XMLHttpRequest();
                    activePhotoUploadXHRs.push(xhr); // [核心] 将请求添加到跟踪列表

                    xhr.open('PUT', url, true);
                    xhr.setRequestHeader('Authorization', `token ${GITHUB_CONFIG.token}`);
                    xhr.setRequestHeader('Content-Type', 'application/json');

                    xhr.upload.onprogress = (e) => {
                        if (e.lengthComputable && onProgressCallback) {
                            const percent = (e.loaded / e.total) * 100;
                            onProgressCallback(percent);
                        }
                    };

                    xhr.onload = function() {
                        const index = activePhotoUploadXHRs.indexOf(xhr);
                        if (index > -1) activePhotoUploadXHRs.splice(index, 1);

                        if (this.status >= 200 && this.status < 300) {
                            const response = JSON.parse(this.responseText);
                            resolve({ path: response.content.path, sha: response.content.sha });
                        } else {
                            const errorResponse = JSON.parse(this.responseText);
                            const errorMessage = errorResponse.message || `HTTP ${this.status}`;
                            reject(new Error(`上传照片 ${file.name || '未知文件'} 失败: ${errorMessage}`));
                        }
                    };

                    xhr.onerror = () => {
                        const index = activePhotoUploadXHRs.indexOf(xhr);
                        if (index > -1) activePhotoUploadXHRs.splice(index, 1);
                        reject(new Error("网络错误，上传失败。"));
                    };
                    
                    xhr.onabort = () => {
                        const index = activePhotoUploadXHRs.indexOf(xhr);
                        if (index > -1) activePhotoUploadXHRs.splice(index, 1);
                        reject(new Error("上传已取消。"));
                    };

                    xhr.send(JSON.stringify(body));
                };
                reader.onerror = () => {
                   reject(new Error("读取文件失败！"));
                };
            });
        }


       
              function populateDriveCategorySelector() {
    ui.categorySelector.innerHTML = '<option value="">-- 请选择分类 --</option>';
    if (currentConfig.categories && currentConfig.categories.length > 0) {
        // 直接遍历所有分类并添加到下拉菜单
        currentConfig.categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.name;
            option.textContent = cat.name;
            ui.categorySelector.appendChild(option);
        });
    }
}

         function populateDriveProjectSelector() {
            const selectedCategory = ui.categorySelector.value;
            ui.projectSelector.innerHTML = ''; // 首先清空旧的项目

            // 如果没有选择分类，则隐藏项目选择器
            if (!selectedCategory || selectedCategory === '') {
                ui.projectSelector.classList.add('hidden');
                ui.fileList.innerHTML = ''; // 同时清空文件列表
                ui.fileListStatus.textContent = '请选择一个分类';
                ui.fileListStatus.style.display = 'block';
                return;
            }

            ui.projectSelector.classList.remove('hidden');

            let projectsToShow = [];
            // 如果选择的是"全部"，则合并所有分类下的项目
            if (selectedCategory === '全部') {
                 const allButtons = new Map();
                currentConfig.categories.forEach(cat => {
                    if (cat.buttons) {
                        cat.buttons.forEach(btn => {
                             // 使用 href 作为 key 来去重
                            if (!allButtons.has(btn.href)) {
                                allButtons.set(btn.href, btn);
                            }
                        });
                    }
                });
                projectsToShow = Array.from(allButtons.values());
            } else {
                const category = currentConfig.categories.find(c => c.name === selectedCategory);
                projectsToShow = (category && category.buttons) ? category.buttons : [];
            }


            if (projectsToShow.length > 0) {
                 ui.projectSelector.innerHTML = '<option value="">-- 请选择项目 --</option>'; // 添加一个默认提示选项
                // 遍历所有项目并添加到选择框
                projectsToShow.forEach(btn => {
                    const option = document.createElement('option');
                    // 使用项目的 href 作为唯一标识
                    option.value = btn.href; 
                    option.textContent = btn.text;
                    ui.projectSelector.appendChild(option);
                });
            } else {
                // 如果分类下确实没有任何项目
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "此分类下无任何项目";
                option.disabled = true;
                ui.projectSelector.appendChild(option);
            }
            
            // 切换分类后，主动清空文件列表并更新状态提示
            fetchFilesForSelectedProject();
        }

        function fetchFilesForSelectedProject() {
            const categoryName = ui.categorySelector.value;
            const projectHref = ui.projectSelector.value;
            ui.fileList.innerHTML = '';
            ui.fileListStatus.style.display = 'block';

            if (!projectHref) {
                ui.fileListStatus.textContent = (categoryName && categoryName !== '') ? "该分类下无上传项目" : '请选择一个分类';
                return;
            }
            fetchFilesFromGithubProject(projectHref);
        }

                // [新增] 辅助函数：格式化文件大小
                function formatFileSize(bytes) {
                    if (bytes === 0) return '0 B';
                    if (!bytes) return '...'; // 处理 undefined 或 null 的情况

                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    
                    // 使用 toFixed(1) 来保留一位小数
                    const size = parseFloat((bytes / Math.pow(k, i)).toFixed(1));
                    return `${size} ${sizes[i]}`;
                }

                // [新增] 辅助函数：通过GitHub API获取文件的最后提交日期
                async function getFileCommitDate(filePath) {
                    const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/commits?path=${encodeURIComponent(filePath)}&page=1&per_page=1`;
                    try {
                        const response = await fetch(url, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` } });
                        if (!response.ok) return '日期未知';
                        const commits = await response.json();
                        if (commits && commits.length > 0) {
                            const date = new Date(commits[0].commit.committer.date);
                            // 格式化为 年-月-日
                            return date.toISOString().split('T')[0];
                        }
                        return '日期未知';
                    } catch (error) {
                        console.error(`Error fetching commit date for ${filePath}:`, error);
                        return '日期未知';
                    }
                }

                // [修改] fetchFilesForSelectedProject 重命名并重构为 fetchAllFilesForProject v2 (增加容错)
                async function fetchFilesForSelectedProject() {
                    const requestToken = Symbol();
                    state.cloudDriveRequestToken = requestToken;
                    ui.fileList.innerHTML = '';
                    ui.fileListStatus.style.display = 'block';

                    const projectHref = ui.projectSelector.value;
                    const projectConfig = findButtonConfigByHref(projectHref);
                    if (!projectConfig) {
                        ui.fileListStatus.textContent = "请选择一个项目以查看文件";
                        return;
                    }

                    ui.fileListStatus.textContent = "加载中...";

                    let githubFiles = [];
                    let codebergFiles = [];

                    // --- 1. 获取 GitHub 文件 (增加容错) ---
                    try {
                        if (checkConfig(false)) { // 检查 GitHub 是否配置
                            const githubFolderName = projectConfig.text.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-");
                            const githubPath = `jellyfish_drive/${githubFolderName}`;
                            const { data } = await fetchFromGithub(githubPath);
                            if (data) githubFiles = data;
                        }
                    } catch (e) {
                         console.error("加载 GitHub 文件列表时出错:", e);
                    }
                    if (state.cloudDriveRequestToken !== requestToken) { return; }

                    // --- 2. 获取 Codeberg 文件 (增加容错) ---
                    try {
                        const activeCbAccount = CodebergManager.getActiveAccount();
                        if (activeCbAccount) {
                            const codebergRepoName = projectConfig.text.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-") || `drive-${Date.now()}`;
                            const cbUrl = `https://codeberg.org/api/v1/repos/${activeCbAccount.username}/${codebergRepoName}/contents/`;
                            const res = await fetch(cbUrl, { headers: { 'Authorization': `token ${activeCbAccount.accessToken}` } });
                            if (res.ok) {
                                codebergFiles = await res.json();
                            }
                        }
                    } catch (e) {
                        console.warn("加载 Codeberg 文件列表失败 (这可能是正常的，比如仓库还未创建):", e);
                    }
                    if (state.cloudDriveRequestToken !== requestToken) { return; }
                    
                    // --- 3. 合并和渲染 ---
                    const allFiles = [
                        ...githubFiles.map(f => ({ ...f, storage: 'github' })),
                        ...codebergFiles.map(f => ({ ...f, storage: 'codeberg', last_commit: { created_at: f.last_modified } }))
                    ].sort((a,b) => new Date(b.last_commit?.created_at || b.last_modified || 0) - new Date(a.last_commit?.created_at || a.last_modified || 0));

                    if (allFiles.length === 0) {
                        ui.fileListStatus.textContent = "该项目下暂无文件";
                        return;
                    }

                    ui.fileListStatus.style.display = "none";
                    allFiles.forEach(file => {
                        const li = document.createElement("li");
                        const storageIcon = file.storage === 'codeberg' ? '📦 ' : '';
                        const sizeText = formatFileSize(file.size);
                        const dateText = new Date(file.last_commit?.created_at || file.last_modified || Date.now()).toISOString().split('T')[0];
                        const metaText = `${sizeText} • ${dateText}`;

                        li.innerHTML = `
                            <div class="file-info" data-storage="${file.storage}">
                                <span class="file-name">${storageIcon}${file.name}</span>
                                <span class="file-meta" data-path="${file.path}">${metaText}</span>
                            </div>
                            <button class="delete-btn" data-sha="${file.sha}">&times;</button>
                        `;
                        ui.fileList.appendChild(li);

                        li.querySelector(".file-info").addEventListener("click", () => forceDownload(file, li));
                        li.querySelector(".delete-btn").addEventListener("click", () => deleteFile(file, li));
                    });
                }


                async function forceDownload(file, el) {
                    const fileNameSpan = el.querySelector(".file-name");
                    const originalText = fileNameSpan.textContent;
                    el.style.pointerEvents = "none";

                    let url;
                    let authToken;
                    let acceptHeader = 'application/vnd.github.v3.raw';

                    if (file.storage === 'codeberg') {
                        const activeAccount = CodebergManager.getActiveAccount();
                        const repoName = findButtonConfigByHref(ui.projectSelector.value).text.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-");
                        url = `https://codeberg.org/api/v1/repos/${activeAccount.username}/${repoName}/media/${file.path}`; // 使用 media API
                        authToken = `token ${activeAccount.accessToken}`;
                        acceptHeader = 'application/octet-stream'; // Codeberg raw content
                    } else { // GitHub
                        url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${file.path}`;
                        authToken = `token ${GITHUB_CONFIG.token}`;
                    }
                    
                    try {
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', url, true);
                        xhr.setRequestHeader('Authorization', authToken);
                        xhr.setRequestHeader('Accept', acceptHeader);
                        xhr.responseType = 'blob';

                        let lastProgressText = '';
                        xhr.onprogress = (event) => {
                            let newProgressText = '正在下载...';
                            if (event.lengthComputable) {
                                newProgressText = `下载中... ${Math.round((event.loaded / event.total) * 100)}%`;
                            }
                            if (newProgressText !== lastProgressText) { fileNameSpan.textContent = newProgressText; lastProgressText = newProgressText;}
                        };
                        xhr.onload = () => {
                            if (xhr.status === 200) {
                                const blobUrl = URL.createObjectURL(xhr.response);
                                const link = document.createElement("a");
                                link.href = blobUrl;
                                link.download = file.name;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                URL.revokeObjectURL(blobUrl);
                                fileNameSpan.textContent = "下载完成";
                            } else {
                                fileNameSpan.textContent = "下载失败";
                                alert(`下载失败: ${xhr.statusText}`);
                            }
                            setTimeout(() => { fileNameSpan.textContent = originalText; el.style.pointerEvents = "auto"; }, 2000);
                        };
                        xhr.onerror = async () => {
                            fileNameSpan.textContent = "下载错误";
                            alert("下载时发生网络错误");
                            setTimeout(() => { fileNameSpan.textContent = originalText; el.style.pointerEvents = "auto"; }, 2000);
                        };
                        fileNameSpan.textContent = "准备下载...";
                        xhr.send();
                    } catch (error) {
                        alert("准备下载时出错: " + error.message);
                        fileNameSpan.textContent = originalText;
                        el.style.pointerEvents = "auto";
                    }
                }

                async function uploadFile() {
                    const FILE_SIZE_LIMIT_MB = 50;
                    if (activeUploadXHR) {
                        if (confirm("当前有文件正在上传，要终止它吗？")) {
                            activeUploadXHR.abort();
                        }
                        return;
                    }
                    
                    const selectedProjectHref = ui.projectSelector.value;
                    const file = ui.fileUploader.files[0];
                    let fileName = ui.fileNameInput.value.trim() || (file && file.name);

                    if (!selectedProjectHref || !file || !fileName) {
                        return alert("请选择要上传到的项目、文件，并确保文件名不为空。");
                    }
                    
                    const useCodeberg = file.size >= FILE_SIZE_LIMIT_MB * 1024 * 1024;
                    
                    // 根据文件大小选择上传服务
                    if (useCodeberg) {
                        await uploadToCodeberg(file, fileName, selectedProjectHref);
                    } else {
                        await uploadToGithub(file, fileName, selectedProjectHref);
                    }
                }
                
                // [新增] Codeberg 上传函数
                async function uploadToCodeberg(file, fileName, projectHref) {
                    const activeAccount = CodebergManager.getActiveAccount();
                    if (!activeAccount) {
                        alert("请先在 Codeberg 设置中连接并激活一个账户！");
                        document.getElementById('codebergSettingsBtn').click();
                        return;
                    }

                    const projectConfig = findButtonConfigByHref(projectHref);
                    if (!projectConfig) { return alert("项目配置无效。"); }
                    const repoName = projectConfig.text.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-") || `drive-${Date.now()}`;
                    const path = `${fileName}`;
                    const url = `https://codeberg.org/api/v1/repos/${activeAccount.username}/${repoName}/contents/${path}`;

                    setupAndRunUpload(file, url, `token ${activeAccount.accessToken}`, repoName, activeAccount.username);
                }
                
                // [新增] GitHub 上传函数 (从原 uploadFile 逻辑中提取)
                async function uploadToGithub(file, fileName, projectHref) {
                     if (!checkConfig(true)) return;
                     const projectConfig = findButtonConfigByHref(projectHref);
                     if (!projectConfig) { return alert("项目配置无效。"); }
                    const folderName = projectConfig.text.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-");
                    const path = `jellyfish_drive/${folderName}/${fileName}`;
                    const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;
                    
                    setupAndRunUpload(file, url, `token ${GITHUB_CONFIG.token}`);
                }

                // [新增] 通用上传逻辑函数
                async function setupAndRunUpload(file, url, authToken, cbRepoName = null, cbOwner = null) {
                    let progressToast = null;
                    const manageProgressToast = (status, isFinal = false, duration = 3000) => {
                        if (isFinal && !progressToast) { showTopToast(status, duration); return; }
                        if (!progressToast) {
                            progressToast = document.createElement('div');
                            progressToast.className = 'top-toast';
                            document.body.appendChild(progressToast);
                            setTimeout(() => { if (progressToast) progressToast.classList.add('show'); }, 50);
                        }
                        progressToast.textContent = status;
                        if (isFinal) {
                            setTimeout(() => {
                                if (progressToast) {
                                    progressToast.classList.remove('show');
                                    progressToast.addEventListener('transitionend', () => { if (progressToast) progressToast.remove(); progressToast = null; }, { once: true });
                                }
                            }, duration);
                        }
                    };

                    const modalObserver = new MutationObserver(mutations => {
                        for (const mutation of mutations) {
                            if (mutation.attributeName === 'class' && !ui.modal.classList.contains('show') && activeUploadXHR) {
                                const currentProgress = parseInt(ui.progressBar.style.width, 10) || 0;
                                manageProgressToast(`上传中... ${currentProgress}%`);
                                modalObserver.disconnect();
                                return;
                            }
                        }
                    });
                    modalObserver.observe(ui.modal, { attributes: true });

                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = async () => {
                        const contentB64 = reader.result.split(',')[1];
                        
                        let existingFileSha = null;
                        
                        // 动态获取 sha
                        try {
                            const shaRes = await fetch(url, { method: 'GET', headers: { 'Authorization': authToken } });
                            if (shaRes.ok) {
                                const fileData = await shaRes.json();
                                existingFileSha = fileData.sha;
                            }
                        } catch(e) { console.warn("Could not fetch existing file sha, proceeding with create.", e); }

                        // 只有 Codeberg 上传新文件时才需要创建仓库
                        if (cbRepoName && !existingFileSha) {
                            try {
                                  const repoCreateUrl = 'https://codeberg.org/api/v1/user/repos';
                                  const repoCreateRes = await fetch(repoCreateUrl, {
                                        method: 'POST',
                                        headers: { 'Authorization': authToken, 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ name: cbRepoName, "private": true })
                                  });
                               
                                 // 如果仓库已存在(422)或创建成功(201)，都算成功
                                 if (!repoCreateRes.ok && repoCreateRes.status !== 422) {
                                     throw new Error(`创建Codeberg仓库失败: ${repoCreateRes.statusText}`);
                                 }
                            } catch(e) {
                                alert(e.message);
                                return; // 创建失败则中断上传
                            }
                        }

                        const body = { message: `Upload file: ${file.name}`, content: contentB64, sha: existingFileSha };
                        
                        activeUploadXHR = new XMLHttpRequest();
                        activeUploadXHR.open('PUT', url, true);
                        activeUploadXHR.setRequestHeader('Authorization', authToken);
                        activeUploadXHR.setRequestHeader('Content-Type', 'application/json');
                        
                        const uploadCancelBtn = document.getElementById('upload-cancel-btn');
                        const uploadCancelHandler = () => { if (activeUploadXHR) activeUploadXHR.abort(); };
                        uploadCancelBtn.addEventListener('click', uploadCancelHandler);

                        activeUploadXHR.upload.onprogress = (e) => {
                            if (e.lengthComputable) {
                                const percent = (e.loaded / e.total) * 100;
                                ui.progressBar.style.width =`${percent}%`;
                                if(progressToast) manageProgressToast(`上传中... ${Math.round(percent)}%`);
                            }
                        };
                        activeUploadXHR.onload = function() {
                           if (this.status >= 200 && this.status < 300) {
                                manageProgressToast("上传成功！", true, 2000);
                                fetchFilesForSelectedProject();
                                ui.fileUploader.value = "";
                                ui.fileNameInput.value = "";
                                ui.selectedFileName.textContent = '未选择任何文件';
                            } else {
                                const errorMsg = JSON.parse(this.responseText).message || `HTTP ${this.status}`;
                                manageProgressToast(`上传失败: ${errorMsg}`, true, 4000);
                            }
                            cleanup();
                        };
                        activeUploadXHR.onerror = () => { manageProgressToast("网络错误", true, 4000); cleanup(); };
                        activeUploadXHR.onabort = () => { manageProgressToast("已取消", true, 2000); cleanup(); };
                        const cleanup = () => {
                            uploadCancelBtn.removeEventListener('click', uploadCancelHandler);
                            ui.progressContainer.style.display = 'none';
                            activeUploadXHR = null;
                            modalObserver.disconnect();
                            if (progressToast && !progressToast.textContent.includes('成功') && !progressToast.textContent.includes('失败') && !progressToast.textContent.includes('取消')) {
                                progressToast.classList.remove('show');
                                progressToast.addEventListener('transitionend', () => progressToast.remove(), { once: true });
                                progressToast = null;
                            }
                        };
                        ui.progressContainer.style.display = 'flex';
                        ui.progressBar.style.width = '0%';
                        activeUploadXHR.send(JSON.stringify(body));
                    };
                    reader.onerror = () => { alert("读取文件失败！"); };
                }

        return {
            open: () => {
                if (!checkConfig(true)) { document.getElementById('settingsModal').classList.add('show'); return; }
                ui.modal.classList.add('show');
                if (!memoryCache) { syncWithGithub(); }
            },
            init: () => {
                 photoObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            const src = img.dataset.src;
                            if (src) {
                                getSecureFileUrl(src).then(url => {
                                    if(url) img.src = url;
                                });
                            }
                            observer.unobserve(img);
                        }
                    });
                }, { root: ui.photoList, rootMargin: "0px 0px 200px 0px" });


                ui.appContainer.addEventListener('click', e => {
                    const target = e.target.closest('[data-action]');
                    if (target && actions[target.dataset.action]) {
                        actions[target.dataset.action](target);
                    }
                });

                // [新增] 长图双击缩放逻辑
                const viewerImg = ui.photoViewer.querySelector('#viewer-img');
                const viewerImgContainer = ui.photoViewer.querySelector('#viewer-img-container');
                
                viewerImgContainer.addEventListener('dblclick', () => {
                    const isCurrentlyZoomed = viewerImgContainer.classList.contains('zoomed-long');
                    
                    if (isCurrentlyZoomed) {
                        viewerImgContainer.classList.remove('zoomed-long');
                        viewerImgContainer.scrollTop = 0; 
                        return;
                    }

                    const isLongImage = viewerImg.naturalHeight > viewerImg.naturalWidth;
                    const isTallerThanContainer = viewerImg.naturalHeight > viewerImgContainer.clientHeight;

                    if (isLongImage && isTallerThanContainer) {
                        viewerImgContainer.classList.add('zoomed-long');
                    } else {
                        showTopToast('此图片无需放大', 2000);
                    }
                });

                // [新增] 备忘录富文本编辑器逻辑 v2
                const editor = document.getElementById('note-content-editor');
                const toolbar = document.querySelector('.memo-toolbar');

                const updateToolbarState = () => {
                    const commands = ['bold', 'italic', 'underline', 'strikeThrough'];
                    commands.forEach(command => {
                        const button = toolbar.querySelector(`[data-command="${command}"]`);
                        if (button) {
                            button.classList.toggle('active', document.queryCommandState(command));
                        }
                    });
                };

                toolbar.addEventListener('click', (e) => {
                    const button = e.target.closest('.toolbar-btn');
                    if (!button) return;

                    const command = button.dataset.command;
                    editor.focus();

                    if (command === 'createCodeBlock') {
                        const selection = window.getSelection();
                        if (!selection.rangeCount || selection.isCollapsed) {
                            showTopToast('请先选择一段文字', 2000);
                            return;
                        }
                        const range = selection.getRangeAt(0);
                        const selectedText = range.toString();
                        const codeBlock = document.createElement('div');
                        codeBlock.className = 'memo-code-block';
                        const pre = document.createElement('pre');
                        pre.style.margin = '0';
                        pre.textContent = selectedText;
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'code-block-copy-btn';
                        copyBtn.contentEditable = 'false'; // [V2 修复] 将按钮设置为不可编辑
                        copyBtn.textContent = '❏';
                        copyBtn.title = '复制';
                        codeBlock.appendChild(copyBtn);
                        codeBlock.appendChild(pre);
                        range.deleteContents();
                        const fragment = document.createDocumentFragment();
                        fragment.appendChild(codeBlock);
                        fragment.appendChild(document.createTextNode('\u200B')); // 零宽度空格，用于放置光标
                        range.insertNode(fragment);
                        range.setStartAfter(codeBlock.nextSibling);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    } else if (command === 'todo') {
                        document.execCommand('insertUnorderedList', false, null);
                        setTimeout(() => {
                            const listItems = editor.querySelectorAll('li');
                            listItems.forEach(li => {
                                if (!li.querySelector('.todo-text')) {
                                    const textNode = document.createTextNode(li.textContent.trim());
                                    const span = document.createElement('span');
                                    span.className = 'todo-text';
                                    span.appendChild(textNode);
                                    li.innerHTML = '';
                                    li.appendChild(span);
                                }
                            });
                        }, 50);
                    } else {
                        document.execCommand(command, false, null);
                    }
                    setTimeout(updateToolbarState, 0);
                });

                editor.addEventListener('keyup', updateToolbarState);
                editor.addEventListener('mouseup', updateToolbarState);

                // [V2 新增] 监听输入事件，用于自动清理空的代码块
                editor.addEventListener('input', () => {
                   // 使用 setTimeout 延迟执行，确保在 DOM 更新后进行检查
                   setTimeout(() => {
                        const codeBlocks = editor.querySelectorAll('.memo-code-block pre');
                        codeBlocks.forEach(pre => {
                            // 如果 pre 标签内没有文本内容（注意 trim() 以处理空白字符）
                            if (pre.textContent.trim() === '') {
                                const parentBlock = pre.closest('.memo-code-block');
                                if (parentBlock) {
                                    parentBlock.remove(); // 移除整个代码块
                                }
                            }
                        });
                   }, 0);
                });

                // 编辑器内部的交互事件（待办清单完成/代码块复制）
                editor.addEventListener('click', (e) => {
                    const li = e.target.closest('li');
                    const copyBtn = e.target.closest('.code-block-copy-btn');

                    if (li) {
                        li.classList.toggle('completed');
                    } else if (copyBtn) {
                        const codeBlock = copyBtn.closest('.memo-code-block');
                        const textToCopy = codeBlock.querySelector('pre')?.textContent || '';
                        
                        if (navigator.clipboard && window.isSecureContext) {
                            navigator.clipboard.writeText(textToCopy).then(() => {
                                const originalText = copyBtn.textContent;
                                copyBtn.textContent = '✓';
                                setTimeout(() => { copyBtn.textContent = originalText; }, 1500);
                            }).catch(err => {
                                showTopToast('复制失败', 2000);
                            });
                        } else {
                            // 兼容非安全环境的降级方案
                            const textArea = document.createElement("textarea");
                            textArea.value = textToCopy;
                            textArea.style.position = "fixed"; textArea.style.left = "-9999px";
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                const originalText = copyBtn.textContent;
                                copyBtn.textContent = '✓';
                                setTimeout(() => { copyBtn.textContent = originalText; }, 1500);
                            } catch (err) {
                                showTopToast('复制失败', 2000);
                            }
                            document.body.removeChild(textArea);
                        }
                    }
                    updateToolbarState();
                });



                ui.folderModal.addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target) actions[target.dataset.action]?.(); });
                ui.photoDetailsModal.addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target) actions[target.dataset.action]?.(); });
                ui.photoViewer.addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target) actions[target.dataset.action]?.(); });
                document.getElementById('movePhotosModal').addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target && actions[target.dataset.action]) actions[target.dataset.action](target); });
            document.getElementById('moveNotesModal').addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target && actions[target.dataset.action]) actions[target.dataset.action](target); });

                ui.photoUploader.addEventListener('change', e => {
                    if (!e.target.files.length) return;
                    state.photoUploadQueue = Array.from(e.target.files);
                    processPhotoUploadQueue();
                    e.target.value = '';
                });
                ui.photosetToggle.addEventListener('change', e => {
                    const isSet = e.target.checked;
                    const button = ui.photoDetailsModal.querySelector('[data-action="save-photo-details"]');
                    const skipBtn = ui.photoDetailsModal.querySelector('[data-action="skip-photo-details"]');
                    button.textContent = '保存';
                    skipBtn.style.display = isSet ? 'none' : 'inline-block';
                });
                document.querySelector('[data-action="close-wander-view"]').addEventListener('click', actions['close-wander-view']);
                document.querySelector('[data-action="toggle-player-collapse"]').addEventListener('click', actions['toggle-player-collapse']);
                ui.categorySelector.addEventListener("change", () => {
   populateDriveProjectSelector();
   fetchFilesForSelectedProject();
});

                ui.projectSelector.addEventListener("change", fetchFilesForSelectedProject);
                ui.selectFileBtn.addEventListener('click', () => ui.fileUploader.click());
                ui.fileUploader.addEventListener("change",()=>{ if(ui.fileUploader.files.length>0){ const file = ui.fileUploader.files[0]; ui.fileNameInput.value=file.name; ui.selectedFileName.textContent = file.name; } else { ui.selectedFileName.textContent = "未选择任何文件"; }});
                ui.uploadBtn.addEventListener("click", uploadFile);
            },
            getAlbumItems: () => memoryCache ? memoryCache.album.items : [],
            scheduleSave,
            // [新增] 供外部调用的 sha 更新函数
            updateSha: (newSha) => {
                memoryDataSha = newSha;
            }
        };

    })();
    // ===== [END] MEMORY APP LOGIC =====


    // ===== [START] WANDER VIEW 4.0 LOGIC (Architecture) =====
    const WanderView = (() => {
        const MUSIC_DATA_PATH = 'memory/music_data.json';
        const MUSIC_FILES_PATH = 'memory/music/';
        let musicDataSha = null;

        const ui = {
            overlay: document.getElementById('wanderViewOverlay'),
            photoContainer: document.getElementById('wander-photo-container'),
            img: document.getElementById('wander-img'),
            title: document.getElementById('wander-title'),
            description: document.getElementById('wander-description'),
            player: {
                container: document.getElementById('wander-music-player'),
                audio: document.getElementById('audio-player'),
                playPauseBtn: document.getElementById('play-pause-btn'),
                prevBtn: document.getElementById('prev-song-btn'),
                nextBtn: document.getElementById('next-song-btn'),
                loopBtn: document.getElementById('loop-mode-btn'),
                playlistBtn: document.getElementById('playlist-btn'),
                displayArea: document.getElementById('player-display-area'),
                progressTrack: document.querySelector('.player-progress-track'),
                progressBar: document.getElementById('player-progress-bar'),
                progressHandle: document.getElementById('player-progress-handle'),
                popover: document.getElementById('playlist-popover'),
                popoverPlaylist: document.getElementById('popover-playlist-ul'),
                openSettingsBtn: document.getElementById('open-music-settings-btn'),
                handle: document.querySelector('.player-handle-container'),
                mainContent: document.querySelector('.wander-main-content'),
            },
            settingsModal: {
                modal: document.getElementById('musicSettingsModal'),
                uploadMusicBtn: document.getElementById('upload-music-btn'),
                uploadLrcBtn: document.getElementById('upload-lrc-btn'),
                musicStatus: document.getElementById('upload-music-status'),
                lrcStatus: document.getElementById('upload-lrc-status'),
                renameInput: document.getElementById('music-rename-input'),
                confirmUploadBtn: document.getElementById('confirm-upload-btn'),
                musicFilePicker: document.getElementById('music-file-picker'),
                lrcFilePicker: document.getElementById('lrc-file-picker'),
                playlistContainer: document.getElementById('music-playlist-container'),
                autoplayToggle: document.getElementById('autoplay-toggle'),
            }
        };

        const state = {
            items: [], currentIndex: -1,
            playlist: [], currentTrackIndex: -1, isPlaying: false,
            loopMode: 'all',
            lyrics: [],
            lastWanderedItemId: null,
            pendingMusicFile: null,
            pendingLrcFile: null,
            isSeeking: false,
        };
        
        const icons = {
            play: '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>',
            pause: '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>',
            prev: '<svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6 8.5 6V6z"/></svg>',
            next: '<svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>',
            loopAll: '<svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>',
            loopOne: '<svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v3H13z"/></svg>',
            shuffle: '<svg viewBox="0 0 24 24"><path d="M10.59 9.17 5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg>',
            musicNote: '<svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>',
            delete: '<svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>',
            list: '<svg viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>',
        };

        function start(items) {
            if (!items || items.length === 0) { alert('没有可漫游的项目。请先在“记忆”中添加一些照片。'); return; }
            let itemPool = [...items];
            if (itemPool.length > 1 && state.lastWanderedItemId) {
                itemPool = itemPool.filter(p => p.id !== state.lastWanderedItemId);
            }
             if (itemPool.length > 0) {
                for ( let i = itemPool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [itemPool[i], itemPool[j]] = [itemPool[j], itemPool[i]];
                }
             } else {
                itemPool = [...items];
             }

            state.items = itemPool;
            state.currentIndex = 0;
            state.lastWanderedItemId = itemPool[0]?.id;
            
            ui.overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
            updateContent();
            loadCloudPlaylist().then(() => {
                if (ui.settingsModal.autoplayToggle.checked && state.playlist.length > 0) {
                    playTrack(state.currentTrackIndex > -1 ? state.currentTrackIndex : 0);
                }
            });
        }

        function close() {
            ui.overlay.classList.remove('active');
            document.body.style.overflow = '';
            if (state.isPlaying) {
                ui.player.audio.pause();
                ui.player.audio.src = ''; // Force stop
            }
        }

        async function updateContent() {
            const item = state.items[state.currentIndex];
            if (!item) return;

            let photo, title, description;
            if (item.type === 'photoset') {
                item.internalIndex = item.internalIndex ?? 0;
                photo = item.photos[item.internalIndex];
                title = item.title;
                description = item.description;
            } else {
                photo = item;
                title = item.title;
                description = item.description;
            }
            
            ui.img.src = ""; 
            ui.img.alt = "渲染中...";

            const photoUrl = await getSecureFileUrl(photo.path);
            ui.img.src = photoUrl;
            ui.img.alt = title || description || "Wander view image";
            ui.photoContainer.style.setProperty('--blur-bg', `url(${photoUrl})`);
            ui.title.textContent = title || '';
            ui.description.textContent = description || '';
        }
        
        async function changePhoto(direction) {
            const item = state.items[state.currentIndex];
            if (item.type === 'photoset' && !ui.photoContainer.classList.contains('fullscreen')) {
                let nextIndex = (item.internalIndex || 0) + direction;
                if (nextIndex >= 0 && nextIndex < item.photos.length) {
                    item.internalIndex = nextIndex;
                } else {
                    changeItem(direction);
                }
            } else {
                changeItem(direction);
            }
            await updateContent();
         }

        function changeItem(direction) {
            let nextIndex = state.currentIndex + direction;
            if (nextIndex < 0) nextIndex = state.items.length - 1;
            if (nextIndex >= state.items.length) nextIndex = 0;
            
            state.currentIndex = nextIndex;
            const newItem = state.items[state.currentIndex];
            if (newItem.type === 'photoset') {
                newItem.internalIndex = direction > 0 ? 0 : newItem.photos.length - 1;
            }
        }
        
        function initGestures() {
            let startX = 0;
            ui.photoContainer.addEventListener('touchstart', e => { startX = e.touches[0].clientX; }, { passive: true });
            ui.photoContainer.addEventListener('touchend', e => {
                const endX = e.changedTouches[0].clientX;
                const swipeDiff = endX - startX;
                if (Math.abs(swipeDiff) < 50) return;
                
                if (ui.photoContainer.classList.contains('fullscreen') && state.items[state.currentIndex].type !== 'photoset') {
                    changePhoto(swipeDiff > 0 ? -1 : 1);
                } else {
                    changePhoto(swipeDiff > 0 ? -1 : 1);
                }
            }, { passive: true });
        }

        function initPlayer() {
            const p = ui.player;
            const sm = ui.settingsModal;

            p.playPauseBtn.innerHTML = icons.play; p.prevBtn.innerHTML = icons.prev; p.nextBtn.innerHTML = icons.next; p.loopBtn.innerHTML = icons.loopAll; p.playlistBtn.innerHTML = icons.list; p.openSettingsBtn.innerHTML = icons.musicNote;
            
            p.playlistBtn.addEventListener('click', (e) => { e.stopPropagation(); p.popover.classList.toggle('active'); });
            p.openSettingsBtn.addEventListener('click', () => { p.popover.classList.remove('active'); sm.modal.classList.add('show'); });
            document.addEventListener('click', (e) => { if (!p.container.contains(e.target)) p.popover.classList.remove('active'); });

            sm.uploadMusicBtn.addEventListener('click', () => sm.musicFilePicker.click());
            sm.uploadLrcBtn.addEventListener('click', () => sm.lrcFilePicker.click());
            sm.musicFilePicker.addEventListener('change', (e) => {
                if(e.target.files.length > 0) {
                    state.pendingMusicFile = e.target.files[0];
                    sm.musicStatus.textContent = state.pendingMusicFile.name;
                    sm.renameInput.value = state.pendingMusicFile.name.replace(/\.[^/.]+$/, "");
                }
            });
            sm.lrcFilePicker.addEventListener('change', (e) => {
                if(e.target.files.length > 0) {
                    state.pendingLrcFile = e.target.files[0];
                    sm.lrcStatus.textContent = state.pendingLrcFile.name;
                }
            });
            sm.confirmUploadBtn.addEventListener('click', () => {
                if (sm.confirmUploadBtn.textContent.startsWith("取消上传")) {
                    if(activeUploadXHR) activeUploadXHR.abort();
                } else {
                    uploadPendingFiles();
                }
            });

            p.playPauseBtn.addEventListener('click', () => {
                if (state.playlist.length === 0) { sm.modal.classList.add('show'); return; }
                if(state.currentTrackIndex === -1) playTrack(0);
                else if (state.isPlaying) p.audio.pause(); 
                else p.audio.play();
            });
            p.audio.onplay = () => { state.isPlaying = true; p.playPauseBtn.innerHTML = icons.pause; p.playPauseBtn.title = "暂停"; p.progressHandle.classList.add('playing'); };
            p.audio.onpause = () => { state.isPlaying = false; p.playPauseBtn.innerHTML = icons.play; p.playPauseBtn.title = "播放"; p.progressHandle.classList.remove('playing'); };
            p.audio.onloadedmetadata = () => updateProgressUI();
            p.audio.ontimeupdate = () => {
                if (!state.isSeeking) updateProgressUI();
                updateLyrics(p.audio.currentTime);
            };
            p.audio.onended = () => nextTrack(false);
            p.nextBtn.addEventListener('click', () => nextTrack(true));
            p.prevBtn.addEventListener('click', () => {
                if (state.playlist.length === 0) return;
                let newIndex = state.currentTrackIndex - 1;
                if (newIndex < 0) newIndex = state.playlist.length - 1;
                playTrack(newIndex);
            });
             p.loopBtn.addEventListener('click', () => {
                if (state.loopMode === 'all') { state.loopMode = 'one'; p.loopBtn.innerHTML = icons.loopOne; p.loopBtn.title = "单曲循环"; }
                else if (state.loopMode === 'one') { state.loopMode = 'shuffle'; p.loopBtn.innerHTML = icons.shuffle; p.loopBtn.title = "随机播放"; }
                else { state.loopMode = 'all'; p.loopBtn.innerHTML = icons.loopAll; p.loopBtn.title = "列表循环"; }
            });
            sm.autoplayToggle.checked = localStorage.getItem('wanderAutoplay') === 'true';
            sm.autoplayToggle.addEventListener('change', (e) => {
                localStorage.setItem('wanderAutoplay', e.target.checked);
            });
            
            const onSeek = (e) => {
                const trackRect = p.progressTrack.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let percent = (clientX - trackRect.left) / trackRect.width;
                percent = Math.max(0, Math.min(1, percent));
                
                if (p.audio.duration) {
                    p.audio.currentTime = percent * p.audio.duration;
                    updateProgressUI();
                }
            };
            const startSeek = (e) => { state.isSeeking = true; onSeek(e); };
            const endSeek = () => { state.isSeeking = false; };
            p.progressTrack.addEventListener('pointerdown', startSeek);
            document.addEventListener('pointermove', (e) => { if(state.isSeeking) onSeek(e); });
            document.addEventListener('pointerup', endSeek);
        }
        
        function updateProgressUI() {
            const p = ui.player;
            if (!p.audio.duration) return;
            const percent = (p.audio.currentTime / p.audio.duration) * 100;
            p.progressBar.style.width = `${percent}%`;
            p.progressHandle.style.left = `${percent}%`;
        }

        function nextTrack(manual = false) {
            if (state.playlist.length === 0) return;
            if (state.playlist.length === 1 && state.loopMode !== 'none') { playTrack(0); return; }
            if (state.loopMode === 'one' && !manual) { playTrack(state.currentTrackIndex); return; }
            
            let newIndex;
            if (state.loopMode === 'shuffle') {
                do { newIndex = Math.floor(Math.random() * state.playlist.length); } while (state.playlist.length > 1 && newIndex === state.currentTrackIndex);
            } else {
                newIndex = state.currentTrackIndex + 1;
                if (newIndex >= state.playlist.length) {
                    if (state.loopMode === 'all') newIndex = 0;
                    else { ui.player.audio.pause(); return; }
                }
            }
            playTrack(newIndex);
        }

        async function playTrack(index) {
            if (index < 0 || index >= state.playlist.length) return;
            state.currentTrackIndex = index;
            const track = state.playlist[index];
            
            ui.player.displayArea.innerHTML = `<div class="music-loader"></div>`;
            const audioUrl = await getSecureFileUrl(track.musicPath);

            if (!audioUrl) {
                console.error(`Failed to get URL for track: ${track.displayName}`);
                alert(`无法播放歌曲 "${track.displayName}"，请检查文件是否存在或网络连接。`);
                ui.player.displayArea.innerHTML = `<div class="song-title-display">${track.displayName} (加载失败)</div>`;
                nextTrack(true);
                return;
            }
            ui.player.audio.src = audioUrl;
            
            state.lyrics = [];

            const displaySongTitle = () => {
                ui.player.displayArea.innerHTML = `<div class="song-title-display">${track.displayName}</div>`;
            };

            if (track.lrcPath) {
                try {
                    const lrcUrl = await getSecureFileUrl(track.lrcPath);
                    const response = await fetch(lrcUrl);
                    if(response.ok) {
                        const lrcText = await response.text();
                        state.lyrics = parseLRC(lrcText);
                    }
                } catch (e) { 
                    console.error("Could not fetch lyrics", e); 
                    state.lyrics = [];
                }
            }
            
            if(state.lyrics && state.lyrics.length > 0) {
                 ui.player.displayArea.innerHTML = `<div id="lyrics-container"><ul id="lyrics-ul"></ul></div>`;
                 renderLyrics();
                 updateLyrics(0);
            } else {
                 displaySongTitle();
            }
            
            ui.player.audio.play().catch(e => console.error("Audio play failed:", e));
            renderPlaylists();
        }

        function renderPlaylists() {
            renderPlaylistInPopover();
            renderPlaylistInModal();
        }

        function renderPlaylistInPopover() {
            ui.player.popoverPlaylist.innerHTML = state.playlist.map((track, index) => 
                `<li data-index="${index}" class="${index === state.currentTrackIndex ? 'playing' : ''}">
                    <span class="playlist-item-name">${track.displayName}</span>
                 </li>`
            ).join('');
            ui.player.popoverPlaylist.querySelectorAll('li').forEach(el => {
                el.addEventListener('click', (e) => {
                    playTrack(parseInt(e.currentTarget.dataset.index, 10));
                    ui.player.popover.classList.remove('active');
                });
            });
        }

        function renderPlaylistInModal() {
            const sm = ui.settingsModal;
            sm.playlistContainer.innerHTML = state.playlist.map((track, index) => 
                `<li data-index="${index}" class="${index === state.currentTrackIndex ? 'playing' : ''}">
                    <span class="song-name">${track.displayName}</span>
                    <button class="player-btn delete-song-btn" data-index="${index}">${icons.delete}</button>
                 </li>`
            ).join('');

            sm.playlistContainer.querySelectorAll('.song-name').forEach(el => {
                el.addEventListener('click', (e) => {
                    const songIndex = parseInt(e.currentTarget.parentElement.dataset.index, 10);
                    sm.modal.classList.remove('show');
                    start(MemoryApp.getAlbumItems());
                    setTimeout(() => playTrack(songIndex), 500);
                });
            });
            sm.playlistContainer.querySelectorAll('.delete-song-btn').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteSong(parseInt(e.currentTarget.dataset.index, 10));
                });
            });
        }

        async function deleteSong(index) {
            const track = state.playlist[index];
            if (!confirm(`确定要从云端永久删除 "${track.displayName}" 吗？`)) return;

            try {
                await deleteFromGithub(track.musicPath, `Delete music: ${track.musicPath}`, track.musicSha);
                if (track.lrcPath && track.lrcSha) {
                    await deleteFromGithub(track.lrcPath, `Delete lyric: ${track.lrcPath}`, track.lrcSha);
                }
                state.playlist.splice(index, 1);
                await saveCloudPlaylist();
                
                if (index === state.currentTrackIndex) {
                    ui.player.audio.pause();
                    ui.player.audio.src = '';
                    state.currentTrackIndex = -1;
                    if (state.playlist.length > 0) playTrack(0);
                } else if (index < state.currentTrackIndex) {
                    state.currentTrackIndex--;
                }
                renderPlaylists();

            } catch(e) { alert(await handleApiError("删除歌曲", e)); }
        }

        function parseLRC(lrc) {
            const lines = lrc.split('\n');
            const result = [];
            const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
            for (const line of lines) {
                const matches = [...line.matchAll(timeRegex)];
                const text = line.substring(line.lastIndexOf(']') + 1).trim();
                
                if (text && matches.length > 0) {
                    for (const match of matches) {
                        const minutes = parseInt(match[1], 10);
                        const seconds = parseInt(match[2], 10);
                        const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
                        const time = minutes * 60 + seconds + milliseconds / 1000;
                        result.push({ time, text });
                    }
                }
            }
            return result.sort((a, b) => a.time - b.time);
        }

        function renderLyrics() {
            const lyricsUl = document.getElementById('lyrics-ul');
            if(!lyricsUl) return;
            lyricsUl.innerHTML = state.lyrics.map(line => `<li>${line.text}</li>`).join('');
        }

        function updateLyrics(currentTime) {
            if (state.lyrics.length === 0) return;
            const lyricsUl = document.getElementById('lyrics-ul');
            if(!lyricsUl) return;

            let currentLineIndex = -1;
            for (let i = 0; i < state.lyrics.length; i++) {
                if (currentTime >= state.lyrics[i].time) {
                    currentLineIndex = i;
                } else {
                    break;
                }
            }
            
            if (currentLineIndex > -1) {
                const allLi = lyricsUl.children;
                if (allLi[currentLineIndex] && !allLi[currentLineIndex].classList.contains('current-lyric')) {
                    const oldLi = lyricsUl.querySelector('.current-lyric');
                    if(oldLi) oldLi.classList.remove('current-lyric');
                    allLi[currentLineIndex].classList.add('current-lyric');
                    
                    const offset = allLi[currentLineIndex].offsetTop;
                    lyricsUl.style.transform = `translateY(-${offset}px)`;
                }
            }
        }
        
        async function loadCloudPlaylist() {
            const { data } = await fetchFromGithub(MUSIC_DATA_PATH);
            if (data && data.content) {
                state.playlist = JSON.parse(b64_to_utf8(data.content));
                musicDataSha = data.sha;
            } else {
                state.playlist = [];
                musicDataSha = null;
            }
            renderPlaylists();
        }

       async function saveCloudPlaylist() {
            const content = utf8_to_b64(JSON.stringify(state.playlist, null, 2));
            const result = await saveToGithub(MUSIC_DATA_PATH, content, 'Update music playlist', musicDataSha);
            if (result.sha) {
                musicDataSha = result.sha;
            }
        }

        async function uploadPendingFiles() {
            const sm = ui.settingsModal;
            if (!state.pendingMusicFile) { alert("请先选择一个音乐文件。"); return; }
            const displayName = sm.renameInput.value.trim();
            if (!displayName) { alert("请输入歌曲名称。"); return; }
            
            const finalMusicFilename = displayName + '.mp3';
            const finalLrcFilename = displayName + '.lrc';
            sm.confirmUploadBtn.textContent = "取消上传 (0%)";
            sm.confirmUploadBtn.disabled = false;
            try {
                const musicPath = MUSIC_FILES_PATH + finalMusicFilename;
                const musicResult = await uploadFileViaGitData({ file: state.pendingMusicFile, path: musicPath, commitMessage: `Upload music: ${finalMusicFilename}`, onProgress: (percent) => { if (percent < 100) sm.confirmUploadBtn.textContent = `取消上传 (${Math.round(percent)}%)`; else sm.confirmUploadBtn.textContent = '正在处理...'; } });
                let lrcResult = { sha: null, path: null };
                if (state.pendingLrcFile) { try { const lrcPath = MUSIC_FILES_PATH + finalLrcFilename; lrcResult = await uploadFileViaGitData({ file: state.pendingLrcFile, path: lrcPath, commitMessage: `Upload lyric: ${finalLrcFilename}`, onProgress: () => {} }); } catch(e) { alert("歌词文件上传失败，但音乐已成功上传。"); } }
                
                const existingIndex = state.playlist.findIndex(t => t.displayName === displayName);
                const newTrackData = { id: Date.now(), displayName, musicPath: musicResult.path, musicSha: musicResult.sha, lrcPath: lrcResult.path, lrcSha: lrcResult.sha };
                if (existingIndex > -1) state.playlist[existingIndex] = { ...state.playlist[existingIndex], ...newTrackData }; else state.playlist.push(newTrackData);
                
                await saveCloudPlaylist();
                renderPlaylists();
                resetUploadForm();
                alert(`"${displayName}" 上传成功！`);
            } catch (e) { if (e.message !== "上传已取消。") alert(await handleApiError(`上传歌曲 ${displayName}`, e)); } 
            finally { sm.confirmUploadBtn.textContent = "确认上传"; sm.confirmUploadBtn.disabled = false; }
        }
        
        function resetUploadForm() {
            const sm = ui.settingsModal;
            state.pendingMusicFile = null; state.pendingLrcFile = null;
            sm.musicFilePicker.value = ''; sm.lrcFilePicker.value = '';
            sm.musicStatus.textContent = ''; sm.lrcStatus.textContent = '';
            sm.renameInput.value = '';
        }

        return {
            init: () => {
                ui.img.addEventListener('click', () => { const isFullscreen = ui.photoContainer.classList.toggle('fullscreen'); ui.player.container.classList.toggle('hidden', isFullscreen); });
                initGestures(); initPlayer();
            }, start, close,
            updateTheme: () => {
                const isDark = document.body.classList.contains('dark-mode');
                ui.overlay.style.background = isDark ? 'var(--bg-night-element)' : 'var(--bg-day-element)';
                ui.overlay.style.color = isDark ? 'var(--text-night)' : 'var(--text-day)';
            },
            togglePlayerCollapse: () => {
                const isCollapsed = ui.player.container.classList.toggle('collapsed');
                ui.player.mainContent.style.transform = isCollapsed ? `translateY(-${ui.player.container.offsetHeight - 30}px)` : 'translateY(0)';
            },
        };
    })();
    // ===== [END] WANDER VIEW LOGIC =====
    
    async function getSecureFileUrl(path) {
        if (!path) return '';

        // 1. 优先从本次会话的内存缓存中读取 (最快)
        if (secureFileCache.has(path)) {
            const cached = secureFileCache.get(path);
            // 如果缓存的是一个Promise，等待它完成
            if (typeof cached.then === 'function') {
                return await cached;
            }
            return cached;
        }
        
        // 2. 如果内存中没有，则尝试从 IndexedDB 持久化缓存中读取
        try {
            const cachedBlob = await ImageCacheDB.get(path);
            if (cachedBlob) {
                const blobUrl = URL.createObjectURL(cachedBlob);
                secureFileCache.set(path, blobUrl); // 存入内存缓存，方便本次会话后续快速访问
                return blobUrl;
            }
        } catch (e) {
            console.warn(`从 IndexedDB 读取缓存失败:`, e);
        }

        // 3. 如果 IndexedDB 中也没有，则发起网络请求
        const fetchPromise = new Promise(async (resolve) => {
            try {
                if (!path.startsWith('projects/') && !path.startsWith('memory/')) {
                    resolve(path);
                    return;
                }
                
                const { data: metaData, error: metaError } = await fetchFromGithub(path, 'contents');
                if (metaError || !metaData || !metaData.sha) {
                    throw new Error(`Could not get metadata for ${path}. ${metaError || 'No SHA found.'}`);
                }

                const { data: blobData, error: blobError } = await fetchFromGithub(`blobs/${metaData.sha}`, 'git');
                if (blobError || !blobData || !blobData.content) {
                    throw new Error(`Could not get blob content for ${path}. ${blobError || 'No content returned.'}`);
                }
                
                const contentType = path.toLowerCase().endsWith('.html') || path.toLowerCase().endsWith('.htm') ? 'text/html' : (metaData.type || 'application/octet-stream');
                const blob = b64toBlob(blobData.content, contentType);

                // 4. [核心] 将获取到的数据存入 IndexedDB
                ImageCacheDB.set(path, blob).catch(e => console.warn('存入IndexedDB失败:', e));

                const blobUrl = URL.createObjectURL(blob);
                secureFileCache.set(path, blobUrl); // 确保内存缓存也被更新
                resolve(blobUrl);

            } catch (error) {
                console.error(`获取安全文件URL失败: ${path}`, error);
                secureFileCache.delete(path); // 从内存缓存中移除失败的条目
                resolve(''); // 返回空字符串，防止界面出错
            }
        });

        // 将Promise存入内存缓存，防止对同一资源发起重复网络请求
        secureFileCache.set(path, fetchPromise);
        return await fetchPromise;
    }

        function checkAppUpdate() {
            const helpPage = document.getElementById('help-page-2');
            if (!helpPage) return;

            const currentUpdateHash = simpleHash(helpPage.innerHTML.trim());
            const lastSeenUpdateHash = localStorage.getItem('lastSeenUpdateHash');
            const updateLogIndicator = document.getElementById('update-log-indicator');

            if (String(currentUpdateHash) !== lastSeenUpdateHash) {
                document.getElementById('helpBtn').classList.add('has-update');
                if (updateLogIndicator) updateLogIndicator.classList.add('show');
            } else {
                if (updateLogIndicator) updateLogIndicator.classList.remove('show');
            }
        }


 window.addEventListener('load', async () => {
        try {
            await ImageCacheDB.init();
        } catch (e) {
            console.error(e);
            alert("本地图片缓存功能启动失败，图片加载速度可能会变慢。");
        }
        loadGithubConfig();
        checkAppUpdate();
        await loadInitialData();
        setupModals();
        MemoryApp.init();
        WanderView.init();
        setupBgImageManager();
        setupColorSync(colorModal.pickerD1, colorModal.hexD1, 'dayColor1'); 
        setupColorSync(colorModal.pickerD2, colorModal.hexD2, 'dayColor2');
        setupColorSync(colorModal.pickerN1, colorModal.hexN1, 'nightColor1'); 
        setupColorSync(colorModal.pickerN2, colorModal.hexN2, 'nightColor2');
        // [新增] 为十六进制输入框绑定同步事件
        setupHexInputSync(colorModal.hexD1, colorModal.pickerD1, 'dayColor1');
        setupHexInputSync(colorModal.hexD2, colorModal.pickerD2, 'dayColor2');
        setupHexInputSync(colorModal.hexN1, colorModal.pickerN1, 'nightColor1');
        setupHexInputSync(colorModal.hexN2, colorModal.pickerN2, 'nightColor2');

        // [核心新增] 将悬浮球初始化移至最后，并增加常驻逻辑
        FloatingBallManager.init();

        // ★ 新增：应用随机CSS预设的逻辑 ★
        const randomCssEnabled = localStorage.getItem('jellyRandomCssEnabled') === 'true';
        if (currentConfig.settings.jellyBall && currentConfig.settings.jellyBall.cssPresets && currentConfig.settings.jellyBall.cssPresets.length > 0 && randomCssEnabled) {
            const presets = currentConfig.settings.jellyBall.cssPresets;
            const randomPreset = presets[Math.floor(Math.random() * presets.length)];
            currentConfig.settings.jellyBall.customCSS = randomPreset.css; // 同步到当前配置
            // 注意：这里不需要saveGlobalConfig，因为这只是本次启动的临时效果
        }

        if (currentConfig.settings.jellyBall && currentConfig.settings.jellyBall.enabled) {
            FloatingBallManager.create();
        }

        function showIosWarning() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            const hasBeenShown = localStorage.getItem('iosWarningShown') === 'true';
            if (isIOS && !hasBeenShown) {
                const modal = document.getElementById('iosWarningModal');
                const confirmBtn = document.getElementById('iosWarningConfirmBtn');
                modal.classList.add('show');
                confirmBtn.addEventListener('click', () => {
                    modal.classList.remove('show');
                    localStorage.setItem('iosWarningShown', 'true');
                    // [核心修改] 用户确认iOS提示后，再检查是否需要显示首次引导
                    checkAndShowFirstTimeGuide();
                }, { once: true });
            } else {
                // [核心修改] 如果不是iOS或已经提示过，直接检查首次引导
                checkAndShowFirstTimeGuide();
            }
        }
        function checkAndShowFirstTimeGuide() {
            const isConfigured = GITHUB_CONFIG.owner && GITHUB_CONFIG.repo && GITHUB_CONFIG.token;
            const guideShown = localStorage.getItem('firstTimeGuideShown') === 'true';

            if (!isConfigured && !guideShown) {
                const guideModal = document.getElementById('firstTimeGuideModal');
                const startBtn = document.getElementById('startConfigGuideBtn');

                guideModal.classList.add('show');

                startBtn.addEventListener('click', () => {
                    guideModal.classList.remove('show');
                    document.getElementById('helpModal').classList.add('show');
                    document.getElementById('help-tab-0').click(); // 直接跳转到首次配置标签页
                    localStorage.setItem('firstTimeGuideShown', 'true');
                }, { once: true });
            }
        }

        // [修改] 调用 showIosWarning，它现在内部会处理后续的 checkAndShowFirstTimeGuide 调用
        showIosWarning();


        // [新增] 监听更新公告标签页的点击
        const updateLogTab = document.querySelector('label[for="help-tab-2"]');
        if (updateLogTab) {
            updateLogTab.addEventListener('click', () => {
                const helpPage = document.getElementById('help-page-2');
                const updateLogIndicator = document.getElementById('update-log-indicator');

                if (helpPage && updateLogIndicator.classList.contains('show')) {
                    // 隐藏标签上的红点
                    if (updateLogIndicator) updateLogIndicator.classList.remove('show');
                    // 隐藏主按钮上的红点
                    document.getElementById('helpBtn').classList.remove('has-update');
                    // 更新“已读”状态到localStorage
                    const currentUpdateHash = simpleHash(helpPage.innerHTML.trim());
                    localStorage.setItem('lastSeenUpdateHash', String(currentUpdateHash));
                }
            });
        }

        /* =============================================================== */
        /* ============== [新增] 拖拽排序功能核心逻辑 V1.0 ============= */
        /* =============================================================== */
        const DragAndSort = (() => {
            let draggedEl = null;      // 正在拖拽的原始元素
            let ghostEl = null;        // 跟随鼠标的虚影元素
            let dropTarget = null;     // 当前的放置目标元素
            let longPressTimer = null; // 长按计时器
            let isDragging = false;    // 是否正在拖拽的标志
            let startPos = { x: 0, y: 0 };
            let offset = { x: 0, y: 0 };

            const LONG_PRESS_DELAY = 300; // 长按 300 毫秒触发
            const DRAG_THRESHOLD = 5;     // 移动超过 5px 则取消长按

            // 当长按计时器触发，开始拖拽
            function startDrag(event) {
                if (!draggedEl) return;
                isDragging = true;
                
                const rect = draggedEl.getBoundingClientRect();

                // 1. 创建虚影
                ghostEl = draggedEl.cloneNode(true);
                ghostEl.classList.add('drag-ghost');
                document.body.appendChild(ghostEl);
                
                // 设置虚影的初始尺寸和位置
                ghostEl.style.width = `${rect.width}px`;
                ghostEl.style.height = `${rect.height}px`;
                ghostEl.style.left = `${rect.left}px`;
                ghostEl.style.top = `${rect.top}px`;

                // 计算鼠标/手指在元素上的偏移
                offset.x = startPos.x - rect.left;
                offset.y = startPos.y - rect.top;

                // 2. 更新原始元素和body的样式
                draggedEl.classList.add('dragging');
                document.body.classList.add('dragging-active');

                // 3. 初始移动一次虚影，确保位置正确
                moveGhost(startPos.x, startPos.y);
            }

            // 移动虚影
            function moveGhost(clientX, clientY) {
                if (!ghostEl) return;
                ghostEl.style.left = `${clientX - offset.x}px`;
                ghostEl.style.top = `${clientY - offset.y}px`;
            }

            // 拖拽过程中的处理
            function onDragMove(event) {
                const a = event.touches ? event.touches[0] : event;
                const { clientX, clientY } = a;

                // 如果还没开始拖拽（长按计时器未触发），检查移动距离
                if (!isDragging) {
                    if (Math.abs(clientX - startPos.x) > DRAG_THRESHOLD || Math.abs(clientY - startPos.y) > DRAG_THRESHOLD) {
                        clearTimeout(longPressTimer); // 移动过大，取消长按
                    }
                    return;
                }

                event.preventDefault(); // 开始拖拽后，阻止默认行为（如滚动）
                moveGhost(clientX, clientY);

                // 隐藏虚影，以便检测其下方的元素
                ghostEl.style.display = 'none';
                const elementBelow = document.elementFromPoint(clientX, clientY);
                ghostEl.style.display = '';

                // 移除上一个目标的高亮
                if (dropTarget) {
                    dropTarget.classList.remove('drag-over');
                    dropTarget = null;
                }
                
                // 检查下方元素是否是有效的放置目标
                const potentialTarget = elementBelow ? elementBelow.closest('.nav-btn, .category-pill, .album-item, .folder-item') : null;
                if (potentialTarget && potentialTarget !== draggedEl && draggedEl.classList[0] === potentialTarget.classList[0]) {
                    dropTarget = potentialTarget;
                    dropTarget.classList.add('drag-over');
                }
            }

             // 拖拽结束
            function onDragEnd(event) {
                clearTimeout(longPressTimer);
                if (!isDragging) return;

                // 如果存在有效的放置目标
                if (dropTarget) {
                    dropTarget.classList.remove('drag-over');
                    
                    // [修改] 实现节点互换逻辑
                    const parent = draggedEl.parentNode;
                    
                    // 创建两个占位节点
                    const draggedPlaceholder = document.createElement('div');
                    const targetPlaceholder = document.createElement('div');
                    
                    // 将占位节点插入到原始节点之前
                    parent.insertBefore(draggedPlaceholder, draggedEl);
                    parent.insertBefore(targetPlaceholder, dropTarget);
                    
                    // 将原始节点移动到对方的占位节点之前
                    parent.insertBefore(draggedEl, targetPlaceholder);
                    parent.insertBefore(dropTarget, draggedPlaceholder);
                    
                    // 移除占位节点
                    parent.removeChild(draggedPlaceholder);
                    parent.removeChild(targetPlaceholder);

                    // 更新数据模型
                    updateDataModel(draggedEl, dropTarget, parent);
                }

                // 清理工作
                draggedEl.classList.remove('dragging');
                document.body.classList.remove('dragging-active');
                if (ghostEl) {
                    ghostEl.remove();
                }
                
                draggedEl = null;
                ghostEl = null;
                dropTarget = null;
                isDragging = false;
                
                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('touchmove', onDragMove);
                document.removeEventListener('mouseup', onDragEnd);
                document.removeEventListener('touchend', onDragEnd);
            }


            // 按下事件（长按的起点）
            function onDragStart(event) {
                // [修改] 同时检查相册和备忘录文件夹的管理模式是否开启
                const isAlbumManageMode = document.querySelector('.album-item.manage-mode');
                const isMemoManageMode = document.querySelector('.folder-item.manage-mode');

                // 如果所有管理模式都没开，则退出
                if (!document.body.classList.contains('management-active') && !isAlbumManageMode && !isMemoManageMode) return;
                
                if (isDragging) return;

                const a = event.touches ? event.touches[0] : event;
                startPos.x = a.clientX;
                startPos.y = a.clientY;

                // 路径1：立即拖拽 (针对相册或备忘录文件夹的排序把手)
                if (event.target.classList.contains('sort-handle')) {
                    // [修改] 让其能找到 .album-item 或 .folder-item
                    draggedEl = event.target.closest('.album-item, .folder-item'); 
                    if (!draggedEl) return;
                    
                    startDrag(event);
                    
                    document.addEventListener('mousemove', onDragMove);
                    document.addEventListener('touchmove', onDragMove, { passive: false });
                    document.addEventListener('mouseup', onDragEnd, { once: true });
                    document.addEventListener('touchend', onDragEnd, { once: true });
                    return; 
                }
                
                // 路径2：长按拖拽 (针对主页项目和分类)
                const target = event.target.closest('.nav-btn, .category-pill');
                if (!target || event.target.classList.contains('delete-icon')) return;

                draggedEl = target;
                longPressTimer = setTimeout(() => startDrag(event), LONG_PRESS_DELAY);

                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('touchmove', onDragMove, { passive: false });
                document.addEventListener('mouseup', onDragEnd, { once: true });
                document.addEventListener('touchend', onDragEnd, { once: true });
            }

            // 更新底层数据结构
            function updateDataModel(el1, el2, parent) {
                // 情况一：对项目按钮排序
                if (parent.id === 'navContainer') {
                    const category = currentConfig.categories.find(c => c.name === currentCategory);
                    if (!category) return;

                    const allButtons = Array.from(parent.querySelectorAll('.nav-btn'));
                    const newButtonOrder = allButtons.map(btn => {
                        return category.buttons.find(b => b.href === btn.dataset.href);
                    }).filter(Boolean);

                    category.buttons = newButtonOrder;
                }
                // 情况二：对相册封面排序
                else if (parent.id === 'album-list-container') {
                    const allAlbums = Array.from(parent.querySelectorAll('.album-item'));
                    const newAlbumOrder = allAlbums.map(albumEl => {
                        const albumId = parseInt(albumEl.dataset.albumId, 10);
                        return memoryCache.album.folders.find(f => f.id === albumId);
                    }).filter(Boolean);

                    memoryCache.album.folders = newAlbumOrder;
                    
                    MemoryApp.scheduleSave();
                    return; 
                }
                // [新增] 情况三：对备忘录文件夹排序
                else if (parent.id === 'folder-list-container') {
                    const allFolders = Array.from(parent.querySelectorAll('.folder-item'));
                    const newFolderOrder = allFolders.map(folderEl => {
                        const folderId = parseInt(folderEl.dataset.folderId, 10);
                        return memoryCache.memo.folders.find(f => f.id === folderId);
                    }).filter(Boolean);

                    memoryCache.memo.folders = newFolderOrder;

                    MemoryApp.scheduleSave();
                    return;
                }
                // 情况四：对分类标签排序
                else if (parent.id === 'categoryNav') {

                    const allPills = Array.from(parent.querySelectorAll('.category-pill'));
                    const newCategoryOrder = allPills.map(pill => {
                        return currentConfig.categories.find(c => c.name === pill.dataset.category);
                    }).filter(Boolean);

                    const allCategory = newCategoryOrder.find(c => c.name === '全部');
                    const otherCategories = newCategoryOrder.filter(c => c.name !== '全部');
                    if (allCategory) {
                        currentConfig.categories = [allCategory, ...otherCategories];
                    } else {
                        currentConfig.categories = newCategoryOrder;
                    }
                }
                
                saveGlobalConfig('Reorder items via drag and drop');
            }

            // 公开的初始化方法
            return {
                init() {
                    console.log("Drag and Sort functionality initialized.");
                    const mainContainer = document.getElementById('navContainer');
                    const categoryContainer = document.getElementById('categoryNav');
                    const albumContainer = document.getElementById('album-list-container');
                    // [新增] 获取备忘录文件夹的容器
                    const memoFolderContainer = document.getElementById('folder-list-container');

                    mainContainer.addEventListener('mousedown', onDragStart);
                    mainContainer.addEventListener('touchstart', onDragStart, { passive: true });
                    
                    categoryContainer.addEventListener('mousedown', onDragStart);
                    categoryContainer.addEventListener('touchstart', onDragStart, { passive: true });

                    albumContainer.addEventListener('mousedown', onDragStart);
                    albumContainer.addEventListener('touchstart', onDragStart, { passive: true });

                    // [新增] 为备忘录文件夹容器也绑定事件
                    memoFolderContainer.addEventListener('mousedown', onDragStart);
                    memoFolderContainer.addEventListener('touchstart', onDragStart, { passive: true });
                }
            };
        })();

        // 初始化拖拽排序功能
        DragAndSort.init();
        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */
        


         /* =============================================================== */
        /* ============== [更新] 手机模式管理逻辑 V5 (功能实现版) ===== */
        /* =============================================================== */

        // [新增] 在 MobileModeManager 外部定义一个渲染函数，方便多处调用
        function showMemoPopup(memoId) {
            const memo = memoryCache.memo.notes.find(n => n.id === memoId);
            if (!memo) return;

            document.querySelector('.memo-popup-overlay')?.remove();

            const overlay = document.createElement('div');
            overlay.className = 'memo-popup-overlay';
            overlay.innerHTML = `
                <div class="memo-popup-content">
                    <div class="memo-popup-title">${memo.title || '无标题'}</div>
                    <div class="memo-popup-body">${memo.content || '没有内容'}</div>
                </div>
            `;
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.classList.remove('show');
                    overlay.addEventListener('transitionend', () => overlay.remove(), { once: true });
                }
            });
            
            document.body.appendChild(overlay);
            setTimeout(() => overlay.classList.add('show'), 10);
        }
        


        const MobileModeManager = (() => {
            let isEnabled = false;
            let currentPickerWindow = null;
            let pendingWidgetContent = null; 
            let ghostEl = null;
            let draggedWidgetInfo = null;
            let dragTargetCell = null;
            let isSwiping = false;
            let startX = 0;
            let currentTranslate = 0;
            let currentPage = 0;

            const ui = {
                toggle: document.getElementById('mobileModeToggle'),
                wrapper: document.getElementById('mainWrapper'),
                slider: document.getElementById('pageSlider'),
                settingsEntry: document.getElementById('lockscreenSettingsEntry'),
                openSettingsBtn: document.getElementById('openLockscreenSettingsBtn'),
            };

            function closeAnyOpenWindow() {
                if (currentPickerWindow) {
                    const windowContainerToClose = currentPickerWindow;

                    // [核心修复] 在移除主窗口前，先检查并移除其关联的“兄弟”窗口
                    const siblingId = windowContainerToClose.dataset.siblingId;
                    if (siblingId) {
                        const siblingElement = document.getElementById(siblingId);
                        if (siblingElement && siblingElement.parentNode) {
                            siblingElement.remove();
                        }
                    }

                    const innerWindow = windowContainerToClose.querySelector('.floating-project-window');
                    if (innerWindow) {
                        innerWindow.classList.remove('visible');
                        innerWindow.addEventListener('transitionend', () => {
                            if (windowContainerToClose.parentNode) {
                                windowContainerToClose.remove();
                            }
                        }, { once: true });
                    } else {
                        if (windowContainerToClose.parentNode) {
                           windowContainerToClose.remove();
                        }
                    }
                    currentPickerWindow = null;
                }
            }

            function createPickerWindow(title, content) {
                closeAnyOpenWindow();
                const container = document.createElement('div');
                container.className = 'picker-window-container';
                const winEl = document.createElement('div');
                winEl.className = 'floating-project-window visible';
                winEl.style.cssText = 'z-index: 2025; width: 340px; height: auto; max-height: 80vh;';
                winEl.innerHTML = `
                    <div class="fpw-header"><span class="fpw-title">${title}</span>
                    <div class="fpw-controls"><button class="fpw-close" title="关闭">×</button></div></div>
                    <div class="fpw-content" style="padding: 15px;"></div>
                `;
                winEl.querySelector('.fpw-content').appendChild(content);

                // [核心修正] 在这里添加联动关闭逻辑
                winEl.querySelector('.fpw-close').addEventListener('click', () => {
                    // 移除主窗口
                    if (container && container.parentNode) {
                        container.remove();
                    }
                    // 查找并移除与之关联的背景选择器窗口
                    const siblingId = container.dataset.siblingId;
                    if (siblingId) {
                        const siblingElement = document.getElementById(siblingId);
                        if (siblingElement && siblingElement.parentNode) {
                            siblingElement.remove();
                        }
                    }
                });

                container.appendChild(winEl);
                document.getElementById('floating-projects-container').appendChild(container);
                currentPickerWindow = container;
                return container;
            }


            function showImagePicker(onSelect) {
                const grid = document.createElement('div');
                grid.className = 'picker-grid';
                const allPhotos = memoryCache.album.items.filter(item => item.type === 'photo' || (item.type === 'photoset' && item.photos.length > 0));
                if (allPhotos.length === 0) grid.textContent = '相册中没有图片。';
                else {
                    allPhotos.forEach(item => {
                        const photoToShow = item.type === 'photo' ? item : item.photos[0];
                        const gridItem = document.createElement('div');
                        gridItem.className = 'picker-grid-item';
                        const img = document.createElement('img');
                        getSecureFileUrl(photoToShow.path).then(url => { if (url) img.src = url; });
                        gridItem.appendChild(img);
                        gridItem.onclick = () => onSelect(photoToShow.path);
                        grid.appendChild(gridItem);
                    });
                }
                createPickerWindow('选择一张图片', grid);
            }

            function showMemoPicker(onSelect) {
                const list = document.createElement('div');
                list.className = 'picker-list';
                if (!memoryCache.memo.notes || memoryCache.memo.notes.length === 0) list.textContent = '没有备忘录。';
                else {
                    memoryCache.memo.notes.forEach(note => {
                        const itemEl = document.createElement('div');
                        itemEl.className = 'picker-item';
                        itemEl.textContent = note.title || '无标题';
                        itemEl.onclick = () => onSelect(note.id);
                        list.appendChild(itemEl);
                    });
                }
                createPickerWindow('选择一个备忘录', list);
            }

             function showContentAndBackgroundPicker(type, onSelect) {
                let listContent;
                let pickerTitle = '';
                let tempSelectedBg = null;

                let bgPickerContainer = null;
                
                const closeBothPickers = () => {
                    closeAnyOpenWindow(); 
                };

                if (type === 'shortcut') {
                    pickerTitle = '选择一个快捷方式';
                    listContent = document.createElement('div');
                    listContent.className = 'picker-list';
                    const allButtons = currentConfig.categories.flatMap(c => c.buttons);
                    if (allButtons.length === 0) {
                        listContent.textContent = '没有已添加的项目。';
                    } else {
                        const uniqueButtons = Array.from(new Map(allButtons.map(item => [item.href, item])).values());
                        uniqueButtons.forEach(btn => {
                            const itemEl = document.createElement('div');
                            itemEl.className = 'picker-item';
                            itemEl.textContent = btn.text;
                            itemEl.onclick = () => onSelect({ content: btn.href, text: btn.text, background: tempSelectedBg });
                            listContent.appendChild(itemEl);
                        });
                    }
                } else if (type === 'memo') {
                    pickerTitle = '选择一个备忘录';
                    listContent = document.createElement('div');
                    listContent.className = 'picker-list';
                    if (!memoryCache.memo.notes || memoryCache.memo.notes.length === 0) {
                        listContent.textContent = '没有备忘录。';
                    } else {
                        memoryCache.memo.notes.forEach(note => {
                            const itemEl = document.createElement('div');
                            itemEl.className = 'picker-item';
                            itemEl.textContent = note.title || '无标题';
                            itemEl.onclick = () => onSelect({ content: note.id, background: tempSelectedBg });
                            listContent.appendChild(itemEl);
                        });
                    }
                }

                const pickerContainer = createPickerWindow(pickerTitle, listContent);
                const pickerWindow = pickerContainer.querySelector('.floating-project-window');
                
                pickerWindow.querySelector('.fpw-close').addEventListener('click', closeBothPickers);

                // 创建并附加背景选择器
                bgPickerContainer = document.createElement('div');
                
                // [核心修正：建立关联]
                const siblingId = 'widget-bg-picker-container-' + Date.now();
                bgPickerContainer.id = siblingId;
                pickerContainer.dataset.siblingId = siblingId; // 将背景选择器的ID存到主窗口上

                bgPickerContainer.style.cssText = `
                    position: fixed;
                    z-index: 2024; 
                    pointer-events: none; 
                    width: auto;
                `;

                const bgPicker = document.createElement('div');
                bgPicker.className = 'widget-bg-picker-popup';
                bgPicker.innerHTML = `
                    <input type="color" id="widgetBgColorPicker" value="#ffffff">
                    <button class="bg-picker-button">导入图片</button>
                    <input type="file" accept="image/*" style="display:none;">
                `;
                bgPickerContainer.appendChild(bgPicker);
                document.body.appendChild(bgPickerContainer);
                
                requestAnimationFrame(() => {
                    const mainRect = pickerWindow.getBoundingClientRect();
                    const bgPickerRect = bgPicker.getBoundingClientRect();
                    
                    bgPickerContainer.style.top = `${mainRect.bottom}px`;
                    bgPickerContainer.style.left = `${mainRect.left + (mainRect.width / 2) - (bgPickerRect.width / 2)}px`;
                });

                const colorInput = bgPicker.querySelector('input[type="color"]');
                const fileInput = bgPicker.querySelector('input[type="file"]');
                const fileButton = bgPicker.querySelector('.bg-picker-button');

                colorInput.addEventListener('input', () => {
                    tempSelectedBg = colorInput.value;
                    fileButton.textContent = '导入图片';
                    fileInput.value = ''; 
                });
                
                fileButton.addEventListener('click', () => fileInput.click());

                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            tempSelectedBg = event.target.result; 
                            fileButton.textContent = '已选择图片';
                            colorInput.value = '#ffffff';
                        };
                        reader.readAsDataURL(file);
                    }
                });
                setTimeout(() => bgPicker.classList.add('show'), 50);
            }



            function showHtmlInputWindow(onSave) {
                const contentWrapper = document.createElement('div');
                contentWrapper.style.display = 'flex';
                contentWrapper.style.flexDirection = 'column';
                contentWrapper.style.gap = '15px';

                const textarea = document.createElement('textarea');
                textarea.className = 'modal-textarea html-editor-textarea';
                textarea.placeholder = '在此输入您的HTML代码...';
                
                const completeButton = document.createElement('button');
                completeButton.className = 'modal-button';
                completeButton.textContent = '完成';
                
                completeButton.onclick = () => {
                    onSave(textarea.value);
                };

                contentWrapper.appendChild(textarea);
                contentWrapper.appendChild(completeButton);
                
                createPickerWindow('输入HTML内容', contentWrapper);
            }





             async function saveWidgetConfig(cellIndex, widgetData, onCompleteCallback) {
                if (!currentConfig.lockscreenWidgets[cellIndex]) {
                    currentConfig.lockscreenWidgets[cellIndex] = [];
                }
                currentConfig.lockscreenWidgets[cellIndex].unshift(widgetData);

                // [V3 修复] 等待保存操作完成
                await saveGlobalConfig(`Add widget to cell ${cellIndex}`);

                // [V3 修复] 在保存完成后，才执行UI更新和回调
                renderLockscreenWidgets();
                const settingsModal = document.getElementById('lockscreen-settings-modal');
                if (settingsModal?.classList.contains('show')) {
                    renderSettingsGrid(settingsModal.querySelector('.settings-grid'));
                }
                
                // [V3 修复] 执行传入的回调，例如关闭选择器窗口
                if (typeof onCompleteCallback === 'function') {
                    onCompleteCallback();
                }
                
                // === 新增：显示成功提示 ===
                showTopToast("小组件已添加", 2000);
            }


            async function deleteWidgetFromCell(cellIndex) {
                delete currentConfig.lockscreenWidgets[cellIndex];
                
                // [V3 修复] 等待删除操作完成
                await saveGlobalConfig(`Delete widget from cell ${cellIndex}`);

                // [V3 修复] 在保存完成后，才执行UI更新
                renderLockscreenWidgets();
                const settingsModal = document.getElementById('lockscreen-settings-modal');
                if (settingsModal?.classList.contains('show')) {
                    renderSettingsGrid(settingsModal.querySelector('.settings-grid'));
                }
                
                // === 新增：显示成功提示 ===
                showTopToast("小组件已删除", 2000);
            }


            function showAlbumPicker(onSelectCallback) {
                const list = document.createElement('div');
                list.className = 'picker-list';

                const folders = memoryCache.album.folders;
                if (!folders || folders.length === 0) {
                    list.textContent = '相册中没有文件夹。';
                } else {
                    folders.forEach(folder => {
                        const itemCount = memoryCache.album.items.filter(p => p.albumId === folder.id).length;
                        const itemEl = document.createElement('div');
                        itemEl.className = 'picker-item';
                        itemEl.innerHTML = `<span>${folder.name}</span><span style="font-size: 0.8em; color: #889; float: right;">${itemCount} ></span>`;
                        itemEl.onclick = () => {
                            showPhotosInAlbumPicker(folder.id, onSelectCallback);
                        };
                        list.appendChild(itemEl);
                    });
                }
                createPickerWindow('选择一个相册', list);
            }

            function showPhotosInAlbumPicker(albumId, onSelectCallback) {
                const grid = document.createElement('div');
                grid.className = 'picker-grid';

                const allItems = memoryCache.album.items.filter(item => item.albumId === albumId);
                const allPhotos = allItems.flatMap(item => item.type === 'photo' ? item : (item.photos || []));

                if (allPhotos.length === 0) {
                    grid.textContent = '此相册中没有图片。';
                } else {
                    allPhotos.forEach(photo => {
                        const gridItem = document.createElement('div');
                        gridItem.className = 'picker-grid-item';
                        const img = document.createElement('img');
                        getSecureFileUrl(photo.path).then(url => { if (url) img.src = url; });
                        gridItem.appendChild(img);

                        gridItem.onclick = () => {
                            const adderContainer = document.getElementById('lockscreen-settings-modal').querySelector('.component-adder');
                            
                            const infoSpan = document.createElement('span');
                            infoSpan.id = 'selection-info';
                            infoSpan.style.fontSize = '12px';
                            infoSpan.style.color = '#889';
                            infoSpan.style.textAlign = 'center';
                            infoSpan.style.display = 'block';
                            infoSpan.style.marginTop = '-10px';
                            infoSpan.style.marginBottom = '10px';
                            const fileName = photo.path.split('/').pop();
                            infoSpan.textContent = `已选择：${photo.title || fileName}`;
                            
                            const confirmBtn = adderContainer.querySelector('#confirm-widget-btn');
                            adderContainer.insertBefore(infoSpan, confirmBtn);

                            closeAnyOpenWindow();
                            onSelectCallback({ path: photo.path, title: photo.title || fileName });
                        };
                        grid.appendChild(gridItem);
                    });
                }
                const folderName = memoryCache.album.folders.find(f => f.id === albumId)?.name || '相册';
                createPickerWindow(folderName, grid);
            }

            
             async function ensureMemoryDataIsLoaded(signal) {
                // 如果内存中已有缓存，直接返回成功
                if (memoryCache && memoryCache.album && memoryCache.memo) {
                    return { success: true };
                }

                const MEMORY_DATA_PATH = 'memory/data.json';

                const getInitialData = () => ({ 
                    memo: { 
                        folders: [{ id: Date.now(), name: "默认文件夹" }], 
                        notes: [] 
                    }, 
                    album: { 
                        folders: [{ id: Date.now() + 1, name: "我的照片" }],
                        items: [] 
                    } 
                });
                
                try {
                    const { data, error, response } = await fetchFromGithub(MEMORY_DATA_PATH, 'GET', null, signal);
                    
                    if (signal?.aborted) {
                        console.log('Data loading cancelled by user.');
                        return { success: false, reason: 'cancelled' };
                    }

                    if (error) {
                        alert(`加载记忆数据失败: ${error}\n\n请检查您的网络连接和GitHub配置。`);
                        return { success: false, reason: 'error' };
                    }
                    
                    let loadedData = null;
                    if ((response && response.status === 404) || !data || !data.content) {
                         console.log('memory/data.json not found or is empty on remote. Using initial data.');
                         loadedData = getInitialData();
                    } else {
                        // 只有在确定内容非空时才尝试解析
                        loadedData = JSON.parse(b64_to_utf8(data.content));
                    }

                    // [核心最终修复] 使用正确的 mergeDeep 顺序
                    // 1. 创建一个全新的空对象 {} 作为安全的目标。
                    // 2. 将 defaultConfig (最新的数据结构) 合并进去作为基础。
                    // 3. 将 loadedData (你的数据) 合并进去，你的数据会覆盖掉默认值，从而被完整保留。
                    const defaultConfig = getInitialData();
                    memoryCache = mergeDeep({}, defaultConfig, loadedData);

                    // 兼容旧版 `photos` 字段到 `items` 的迁移
                    if (memoryCache.album && memoryCache.album.photos && (!memoryCache.album.items || memoryCache.album.items.length === 0)) {
                        console.log("Migrating legacy 'photos' array to 'items'.");
                        memoryCache.album.items = memoryCache.album.photos.map(p => ({...p, type: 'photo'}));
                        delete memoryCache.album.photos;
                    }

                    return { success: true };

                } catch (e) {
                    // 捕获所有致命错误，包括JSON解析失败
                    console.error('Critical error in ensureMemoryDataIsLoaded:', e);
                    alert(`处理记忆数据时发生严重错误: ${e.message}\n\n这可能是因为云端文件格式已损坏。您可以尝试进入“记忆”功能，它会自动尝试修复或重建数据。`);
                    return { success: false, reason: 'critical' };
                }
            }

            function openLockscreenSettingsWindow() {
                const modalId = 'lockscreen-settings-modal';
                // [修复] 移除防止重复创建的判断，因为关闭时元素会被彻底销毁，需要能够重新创建
                // if (document.getElementById(modalId)) return;
                const LoadingIndicator = (() => {
                    let overlay = null;

                    let abortController = null;

                    function show(message, onCancel) {
                        if (overlay) return;
                        abortController = new AbortController();

                        overlay = document.createElement('div');
                        overlay.className = 'loading-indicator-overlay';
                        overlay.innerHTML = `
                            <div class="loading-indicator-box">
                                <div class="loading-indicator-text">${message}</div>
                                <button class="loading-indicator-cancel-btn">取消</button>
                            </div>
                        `;
                        document.body.appendChild(overlay);

                        overlay.querySelector('.loading-indicator-cancel-btn').onclick = () => {
                            abortController.abort();
                            hide();
                            if (onCancel) onCancel();
                        };
                        
                        requestAnimationFrame(() => overlay.classList.add('show'));
                    }

                    function hide() {
                        if (!overlay) return;
                        const overlayToRemove = overlay;
                        overlayToRemove.classList.remove('show');
                        overlayToRemove.addEventListener('transitionend', () => overlayToRemove.remove(), { once: true });
                        overlay = null;
                        abortController = null;
                    }

                    return {
                        show,
                        hide,
                        getSignal: () => abortController?.signal
                    };
                })();
                const modalOverlay = document.createElement('div');
                modalOverlay.id = modalId;
                modalOverlay.className = 'modal-overlay show';
                modalOverlay.style.zIndex = '1001';
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                const settingsContainer = document.createElement('div');
                settingsContainer.style.cssText = 'display: flex; flex-direction: column; height: 100%;';
                const header = document.createElement('div');
                header.className = 'modal-header';
                header.innerHTML = `<div class="modal-title-group"><span>锁屏组件设置</span></div><button class="close-btn">&times;</button>`;
                const body = document.createElement('div');
                body.className = 'modal-body';
                body.style.paddingTop = '10px';
                const phoneScreen = document.createElement('div');
                phoneScreen.className = 'simulated-phone-screen';
                const gridContainer = document.createElement('div');
                gridContainer.className = 'settings-grid';
                phoneScreen.appendChild(gridContainer);
                const adderContainer = document.createElement('div');
                adderContainer.className = 'component-adder';
                adderContainer.innerHTML = `
                    <div class="adder-controls-row">
                        <div class="adder-control-group"> <label>尺寸 (宽x高)</label> <div class="size-selector"> <div class="roller-container"> <button class="roller-btn" data-roller="width" data-dir="-1">-</button> <span class="roller-display" id="width-display">1</span> <button class="roller-btn" data-roller="width" data-dir="1">+</button> </div> <span>&times;</span> <div class="roller-container"> <button class="roller-btn" data-roller="height" data-dir="-1">-</button> <span class="roller-display" id="height-display">1</span> <button class="roller-btn" data-roller="height" data-dir="1">+</button> </div> </div> </div>
                        <div class="adder-control-group"> <label>类型</label> <select id="widget-type-selector" class="modal-select"> <option value="shortcut">快捷按钮</option> <option value="image">图片</option> <option value="memo">备忘录</option> <option value="html">HTML</option> </select> </div>
                    </div>
                    <button id="confirm-widget-btn" class="modal-button">确认并生成</button>
                    <div id="new-widget-preview-area" style="display: flex; justify-content: center; align-items: center; gap: 15px;">将生成的组件拖入上方屏幕</div>
                `;
                body.append(phoneScreen, adderContainer);
                settingsContainer.append(header, body);
                modalContent.appendChild(settingsContainer);
                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);

                const closeModal = () => { closeAnyOpenWindow(); modalOverlay.classList.remove('show'); modalOverlay.addEventListener('transitionend', () => modalOverlay.remove(), { once: true }); };
                header.querySelector('.close-btn').onclick = closeModal;
                modalOverlay.onclick = (e) => { if (e.target === modalOverlay) closeModal(); };
                renderSettingsGrid(gridContainer);
                const widthDisplay = adderContainer.querySelector('#width-display'), heightDisplay = adderContainer.querySelector('#height-display');
                adderContainer.querySelectorAll('.roller-btn').forEach(btn => btn.addEventListener('click', () => { const t = btn.dataset.roller, d = parseInt(btn.dataset.dir, 10), el = t === 'width' ? widthDisplay : heightDisplay, max = t === 'width' ? 4 : 8; let val = parseInt(el.textContent, 10) + d; el.textContent = Math.max(1, Math.min(val, max)); }));
                
                adderContainer.querySelector('#widget-type-selector').addEventListener('change', function() {
                    adderContainer.querySelector('#new-widget-preview-area').innerHTML = '将生成的组件拖入上方屏幕';
                    adderContainer.querySelector('#new-widget-preview-area').classList.remove('has-widget');
                    pendingWidgetContent = null;
                    adderContainer.querySelector('#selection-info')?.remove();
                });

                // ============ [核心修改点 1: "确认并生成" 按钮逻辑] ============
                adderContainer.querySelector('#confirm-widget-btn').addEventListener('click', () => {
                    const type = adderContainer.querySelector('#widget-type-selector').value;
                    const previewArea = adderContainer.querySelector('#new-widget-preview-area');

                    adderContainer.querySelector('#selection-info')?.remove();
                    previewArea.innerHTML = ''; 

                    const size = `${widthDisplay.textContent}x${heightDisplay.textContent}`;
                    const typeTextMap = { 'shortcut': '快捷方式', 'image': '图片', 'memo': '备忘录', 'html': 'HTML' };
                    const descriptiveText = `${size} ${typeTextMap[type] || type}`;
                    
                    // 创建函数，用于生成一个预览项
                    const createPreviewItem = (shape) => {
                        const item = document.createElement('div');
                        item.className = 'widget-preview-item';
                        if (shape === 'circle') {
                            item.classList.add('shape-circle');
                        }
                        Object.assign(item.dataset, { 
                            widgetSize: size, 
                            widgetType: type,
                            widgetShape: shape // [新增] 将形状信息存入 dataset
                        });
                        item.textContent = descriptiveText;
                        item.draggable = true;
                        item.addEventListener('mousedown', handleDragStart);
                        item.addEventListener('touchstart', handleDragStart, { passive: false });
                        return item;
                    };

                    // 创建并添加方形和圆形预览项
                    const squarePreview = createPreviewItem('square');
                    const circlePreview = createPreviewItem('circle');

                    previewArea.appendChild(circlePreview);
                    previewArea.appendChild(squarePreview);
                    
                    previewArea.classList.toggle('has-widget', previewArea.childElementCount > 0);
                });
            }

            async function renderSettingsGrid(gridContainer) {
                if (!gridContainer) return;
                gridContainer.innerHTML = '';
                for (let i = 0; i < 32; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'settings-grid-cell';
                    cell.dataset.cellIndex = i;
                    gridContainer.appendChild(cell);
                }
                const gridRect = gridContainer.getBoundingClientRect();
                const gap = 4;
                const cellWidth = (gridRect.width - (3 * gap)) / 4;
                const cellHeight = (gridRect.height - (7 * gap)) / 8;

                if (cellWidth <= 0 || cellHeight <= 0) {
                    return;
                }

                const widgets = currentConfig.lockscreenWidgets || {};

                for (const startIndexStr in widgets) {
                    const startIndex = parseInt(startIndexStr);
                    const widgetConfig = widgets[startIndex]?.[0];
                    if (!widgetConfig) continue;

                    const [cols, rows] = widgetConfig.size.split('x').map(Number);
                    const startRow_0based = Math.floor(startIndex / 4);
                    const startCol_0based = startIndex % 4;
                    const top = startRow_0based * (cellHeight + gap);
                    const left = startCol_0based * (cellWidth + gap);
                    const width = cols * cellWidth + (cols - 1) * gap;
                    const height = rows * cellHeight + (rows - 1) * gap;

                    const container = document.createElement('div');
                    container.className = 'widget-container-wrapper';
                    Object.assign(container.style, { position: 'absolute', top: `${top}px`, left: `${left}px`, width: `${width}px`, height: `${height}px` });

                    const placeholder = document.createElement('div');
                    placeholder.className = 'widget-placeholder';
                    placeholder.style.position = 'absolute';
                    placeholder.style.inset = '0';

                    switch (widgetConfig.type) {
                        case 'image':
                            placeholder.style.padding = '0';
                            placeholder.style.overflow = 'hidden';
                            const img = document.createElement('img');
                            Object.assign(img.style, { width: '100%', height: '100%', objectFit: 'cover', borderRadius: 'inherit' });
                            img.alt = 'Image Preview';
                            getSecureFileUrl(widgetConfig.content).then(url => { if (url) img.src = url; });
                            placeholder.appendChild(img);
                            break;
                        case 'memo':
                            const memo = memoryCache.memo.notes.find(n => n.id === widgetConfig.content);
                            placeholder.innerHTML = memo ? `<div class="settings-widget-preview-memo-title">${memo.title||'无标题'}</div><div class="settings-widget-preview-memo-content">${memo.content||''}</div>` : '备忘录丢失';
                            break;
                        case 'shortcut':
                            const btnCfg = findButtonConfigByHref(widgetConfig.content);
                            placeholder.textContent = btnCfg ? btnCfg.text : '快捷方式丢失';
                            break;
                        case 'html':
                            placeholder.textContent = 'HTML';
                            break;
                    }

                    const deleteWrapper = document.createElement('div');
                    deleteWrapper.className = 'widget-delete-wrapper';
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'widget-delete-btn-centered';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm('确定要删除这个组件吗？')) {
                            // [V3 修复] 调用修改后的异步函数
                            deleteWidgetFromCell(startIndex);
                        }
                    };
                    deleteWrapper.appendChild(deleteBtn);
                    container.appendChild(placeholder);
                    container.appendChild(deleteWrapper);
                    gridContainer.appendChild(container);
                }
            }


            // ============ [核心修改点 2: 拖拽开始时捕获形状信息] ============
            function handleDragStart(e) {
                e.preventDefault();
                const item = e.currentTarget;
                draggedWidgetInfo = { 
                    size: item.dataset.widgetSize, 
                    type: item.dataset.widgetType,
                    shape: item.dataset.widgetShape, // [新增] 捕获形状
                    content: item.dataset.widgetContent
                };
                ghostEl = document.createElement('div');
                ghostEl.className = 'widget-ghost';
                if (draggedWidgetInfo.shape === 'circle') { // [新增] 让拖拽虚影也变成圆形
                    ghostEl.style.borderRadius = '50%';
                }
                ghostEl.textContent = item.textContent;
                document.body.appendChild(ghostEl);
                
                const gridEl = document.querySelector('#lockscreen-settings-modal .settings-grid');
                if (!gridEl) return;
                
                const gridRect = gridEl.getBoundingClientRect();
                const singleCellWidth = (gridRect.width - (3 * 5)) / 4;
                const singleCellHeight = (gridRect.height - (7 * 5)) / 8;
                const gap = 5;

                const [cols, rows] = draggedWidgetInfo.size.split('x').map(Number);

                ghostEl.style.width = `${cols * singleCellWidth + (cols - 1) * gap}px`;
                ghostEl.style.height = `${rows * singleCellHeight + (rows - 1) * gap}px`;

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                ghostEl.style.left = `${clientX - ghostEl.offsetWidth / 2}px`;
                ghostEl.style.top = `${clientY - ghostEl.offsetHeight / 2}px`;
                ghostEl.style.zIndex = '9999';
                document.addEventListener('mousemove', handleDragMove);
                document.addEventListener('mouseup', handleDragEnd, { once: true });
                document.addEventListener('touchmove', handleDragMove, { passive: false });
                document.addEventListener('touchend', handleDragEnd, { once: true });
            }


            function isPlacementValid(startCell, size) {
                const occupied = new Set();
                Object.keys(currentConfig.lockscreenWidgets || {}).forEach(iStr => {
                     const i = parseInt(iStr);
                     const w = currentConfig.lockscreenWidgets[i][0];
                     const [c, r] = w.size.split('x').map(Number);
                     for(let y=0; y<r; y++) for(let x=0; x<c; x++) occupied.add(i + y*4 + x);
                });

                const startIndex = parseInt(startCell.dataset.cellIndex, 10);
                const [cols, rows] = size.split('x').map(Number);

                if ((startIndex % 4) + cols > 4) return false;
                if (Math.floor(startIndex/4) + rows > 8) return false;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (occupied.has(startIndex + r * 4 + c)) return false;
                    }
                }
                return true;
            }

            function handleDragMove(e) {
                if (!ghostEl) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                ghostEl.style.left = `${clientX - ghostEl.offsetWidth / 2}px`;
                ghostEl.style.top = `${clientY - ghostEl.offsetHeight / 2}px`;
                if (dragTargetCell) dragTargetCell.classList.remove('drag-over');
                ghostEl.style.display = 'none';
                const elBelow = document.elementFromPoint(clientX, clientY);
                ghostEl.style.display = 'flex';
                const cell = elBelow ? elBelow.closest('.settings-grid-cell') : null;
                if (cell && isPlacementValid(cell, draggedWidgetInfo.size)) {
                    dragTargetCell = cell;
                    dragTargetCell.classList.add('drag-over');
                } else {
                    dragTargetCell = null;
                }
            }
            
              async function handleDragEnd() {
                if (dragTargetCell) {
                    dragTargetCell.classList.remove('drag-over');
                    const cellIndex = parseInt(dragTargetCell.dataset.cellIndex, 10);
                    const newWidget = { id: Date.now(), ...draggedWidgetInfo };

                    // [V3 修复] onSelectContent 现在调用带回调的 saveWidgetConfig
                    const onSelectContent = (data) => {
                        newWidget.content = data.content;
                        if (data.text) newWidget.text = data.text;
                        if (data.background) newWidget.background = data.background;
                        
                        // 传入 closeAnyOpenWindow 作为保存成功后的回调函数
                        saveWidgetConfig(cellIndex, newWidget, closeAnyOpenWindow);
                    };

                    if (['memo', 'image', 'shortcut'].includes(newWidget.type)) {
                        const { success } = await ensureMemoryDataIsLoaded();
                        if (success) {
                            if (newWidget.type === 'image') {
                                showAlbumPicker(photoData => onSelectContent({ content: photoData.path }));
                            } else {
                                showContentAndBackgroundPicker(newWidget.type, onSelectContent);
                            }
                        }
                    } else if (newWidget.type === 'html') {
                        showHtmlInputWindow(htmlContent => onSelectContent({ content: htmlContent }));
                    }
                }

                if (ghostEl) ghostEl.remove();
                ghostEl = null; draggedWidgetInfo = null; dragTargetCell = null;
                document.removeEventListener('mousemove', handleDragMove);
                document.removeEventListener('touchmove', handleDragMove);
            }



            async function applyMode(enable) {
                const homeScreenPage = document.getElementById('homeScreenPage');
                const mainWrapper = document.getElementById('mainWrapper');
                const elementsToMove = [document.getElementById('pageOverlay'), document.getElementById('titleCard'), document.getElementById('categoryNavContainer'), document.querySelector('.scrollable-nav-wrapper')].filter(Boolean);
                isEnabled = enable;
                document.body.classList.toggle('mobile-mode', enable);
                ui.settingsEntry.style.display = enable ? 'block' : 'none';
                
                if (enable) {
                    // 确保记忆数据已加载，以便锁屏组件能获取信息
                    const { success } = await ensureMemoryDataIsLoaded();
                    if (!success) {
                        alert("加载锁屏组件数据失败，部分组件可能无法显示。请检查网络后刷新重试。");
                    }
                    
                    // 将主页元素移动到手机模式的 home-screen-page 中
                    elementsToMove.forEach(el => homeScreenPage.appendChild(el));
                    currentPage = 0; currentTranslate = 0;
                    ui.slider.style.transition = 'none';
                    ui.slider.style.transform = `translateX(0px)`;
                    ui.slider.classList.remove('show-home-screen');
                    renderLockscreenWidgets();
                    attachSwipeListeners();
                } else {
                    // 当关闭手机模式时，将元素移回 body
                    elementsToMove.forEach(el => {
                        // fab-container 是一个很好的参照点，我们将元素插到它前面
                        const fabContainer = document.getElementById('fabContainer');
                        if (fabContainer) {
                             document.body.insertBefore(el, fabContainer);
                        } else {
                             document.body.appendChild(el); // 兜底方案
                        }
                    });
                    detachSwipeListeners();
                    ui.slider.style.transition = 'none';
                    ui.slider.style.transform = `translateX(0px)`;
                    ui.slider.classList.remove('show-home-screen');
                    document.body.classList.remove('mobile-home-screen-active');
                }
                
                if (!currentConfig.settings.mobileMode) currentConfig.settings.mobileMode = {};
                currentConfig.settings.mobileMode.enabled = enable;
                saveGlobalConfig('Toggle mobile mode');
            }



            // [V3 终极修复] 重构滑动逻辑，解决事件冲突
            let startY = 0, diffX = 0, diffY = 0, swipeIntention = null; // null, 'horizontal', 'vertical'

            function handleTouchStart(e) {
                // 如果正在滑动中，或者目标是组件等，则忽略新的触摸
                if (isSwiping || !isEnabled || e.target.closest('.widget, .widget-placeholder, .component-adder')) return;
                
                // 重置所有状态
                swipeIntention = null;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                diffX = 0;
                diffY = 0;

                ui.slider.style.transition = 'none';
                const transformMatrix = window.getComputedStyle(ui.slider).transform;
                currentTranslate = (transformMatrix !== 'none') ? parseFloat(transformMatrix.split(',')[4]) : 0;
                
                // 标记触摸 sequence 开始
                isSwiping = true; 
            }

            function handleTouchMove(e) {
                if (!isSwiping || !isEnabled) return;

                diffX = e.touches[0].clientX - startX;
                diffY = e.touches[0].clientY - startY;

                // 首次移动时，判断用户的意图
                if (swipeIntention === null) {
                    // 水平移动大于垂直移动，且超过阈值，判定为页面滑动
                    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                        swipeIntention = 'horizontal';
                    } 
                    // 垂直移动大于水平移动，判定为页面滚动 (或长按前的微小抖动)
                    else if (Math.abs(diffY) > Math.abs(diffX)) {
                        swipeIntention = 'vertical';
                    }
                }
                
                // 只有明确是水平滑动意图时，才阻止默认行为并移动页面
                if (swipeIntention === 'horizontal') {
                    e.preventDefault();
                    const pageWidth = ui.slider.offsetWidth / 2;
                    const limitedTranslate = Math.max(-pageWidth, Math.min(0, currentTranslate + diffX));
                    ui.slider.style.transform = `translateX(${limitedTranslate}px)`;
                } 
                // 如果是垂直意图，或者意图未定（移动太小），则什么都不做
                // 这允许了垂直滚动、点击和长按的正常触发
            }
            
            function handleTouchEnd(e) {
                if (!isSwiping || !isEnabled) return;
                
                // 只有当意图是水平滑动时，才处理页面切换逻辑
                if (swipeIntention === 'horizontal') {
                    const threshold = window.innerWidth / 4;
                    if (Math.abs(diffX) > threshold) {
                        if (diffX < 0 && currentPage === 0) currentPage = 1;
                        else if (diffX > 0 && currentPage === 1) currentPage = 0;
                    }
                    snapToPage();
                }

                // 重置状态，准备下一次触摸
                isSwiping = false;
                swipeIntention = null;
            }


            function snapToPage() {
                const pageWidth = ui.slider.offsetWidth / 2;
                const targetTranslate = currentPage === 1 ? -pageWidth : 0;
                ui.slider.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1)';
                ui.slider.style.transform = `translateX(${targetTranslate}px)`;
                currentTranslate = targetTranslate;
                ui.slider.classList.toggle('show-home-screen', currentPage === 1);
                document.body.classList.toggle('mobile-home-screen-active', currentPage === 1);
            }

            function attachSwipeListeners() {
                const options = { passive: false };
                ui.wrapper.addEventListener('touchstart', handleTouchStart, options);
                ui.wrapper.addEventListener('touchmove', handleTouchMove, options);
                ui.wrapper.addEventListener('touchend', handleTouchEnd, { passive: true });
            }

            function detachSwipeListeners() {
                const options = { passive: false };
                ui.wrapper.removeEventListener('touchstart', handleTouchStart, options);
                ui.wrapper.removeEventListener('touchmove', handleTouchMove, options);
                ui.wrapper.removeEventListener('touchend', handleTouchEnd, { passive: true });
            }

            return {
                init() {
                    if (!currentConfig.settings) currentConfig.settings = {};
                    const mobileSettings = currentConfig.settings.mobileMode || { enabled: false };
                    ui.toggle.checked = mobileSettings.enabled;
                    if (!currentConfig.lockscreenWidgets) currentConfig.lockscreenWidgets = {};
                    if (mobileSettings.enabled) applyMode(true);
                    ui.toggle.addEventListener('change', (e) => applyMode(e.target.checked));
                    ui.openSettingsBtn.addEventListener('click', openLockscreenSettingsWindow);
                }
            };
        })();

        function renderLockscreenWidgets() {
            const grid = document.getElementById('lockscreenGrid');
            if (!grid) return;
            grid.innerHTML = '';

            // [V3 最终修复] 
            // 采用 title-card 模式，直接读取 grid 自身的渲染宽度
            
            // 1. 获取 grid 元素当前的实际宽度 (由 CSS 'width: calc(100% - 40px)' 决定)
            const gridRect = grid.getBoundingClientRect();
            const actualGridWidth = gridRect.width;

            if (actualGridWidth <= 0) { // 如果元素不可见，则延迟执行
                setTimeout(renderLockscreenWidgets, 50);
                return;
            }

            const gap = 15;

            // 2. 根据 grid 的实际宽度，计算出完美的1:1单元格尺寸
            const cellSize = (actualGridWidth - (3 * gap)) / 4;
            
            if (cellSize <= 0) return; // 防止无效计算

            // 3. 根据单元格尺寸，反向计算出网格容器应有的总高度
            const requiredGridHeight = (8 * cellSize) + (7 * gap);
            
            // 4. 关键：只强制设置高度，宽度由CSS类控制
            grid.style.height = `${requiredGridHeight}px`;

            const widgetsData = currentConfig.lockscreenWidgets || {};
            
            Object.keys(widgetsData).forEach(startIndexStr => {
                const startIndex = parseInt(startIndexStr, 10);
                const widgetConfig = widgetsData[startIndex]?.[0];

                if (!widgetConfig) return;

                const startRow_0based = Math.floor(startIndex / 4);
                const startCol_0based = startIndex % 4;
                const [cols, rows] = widgetConfig.size.split('x').map(Number);
                
                // 5. 使用统一的 cellSize 进行所有位置和尺寸的计算
                const top = startRow_0based * (cellSize + gap);
                const left = startCol_0based * (cellSize + gap);
                const width = (cols * cellSize) + ((cols - 1) * gap);
                const height = (rows * cellSize) + ((rows - 1) * gap);

                const componentContainer = document.createElement('div');
                componentContainer.style.position = 'absolute';
                Object.assign(componentContainer.style, { top: `${top}px`, left: `${left}px`, width: `${width}px`, height: `${height}px` });

                if (widgetConfig.type === 'html') componentContainer.classList.add('html-widget-container');
                
                const widgetEl = document.createElement('div');
                widgetEl.className = 'widget';

                if (widgetConfig.shape === 'circle') {
                    widgetEl.classList.add(cols === rows ? 'widget-shape-circle' : 'widget-shape-capsule');
                } else {
                    widgetEl.classList.add('widget-shape-square');
                }

                if (widgetConfig.background) {
                    if (widgetConfig.background.startsWith('data:image')) {
                        widgetEl.style.backgroundImage = `url(${widgetConfig.background})`;
                        widgetEl.style.backgroundSize = 'cover';
                        widgetEl.style.backgroundPosition = 'center';
                        if (widgetConfig.type === 'shortcut') {
                           widgetEl.style.color = 'transparent';
                           widgetEl.style.textIndent = '9999px';
                           widgetEl.style.overflow = 'hidden';
                        }
                    } else {
                        widgetEl.style.backgroundColor = widgetConfig.background;
                        widgetEl.style.backgroundImage = 'none';
                    }
                }

                switch (widgetConfig.type) {
                    case 'image':
                        widgetEl.classList.add('widget-image');
                        const img = document.createElement('img');
                        img.alt = 'Image Widget';
                        getSecureFileUrl(widgetConfig.content).then(url => { if (url) img.src = url; });
                        widgetEl.appendChild(img);
                        break;
                    case 'memo':
                        const memo = memoryCache.memo.notes.find(n => n.id === widgetConfig.content);
                        widgetEl.classList.add('widget-memo');
                        if (memo) {
                            if (widgetConfig.size === '1x1') {
                                widgetEl.innerHTML = '&#9993;';
                                widgetEl.style.fontSize = '2em';
                            } else {
                                widgetEl.classList.remove('widget-shape-circle', 'widget-shape-capsule');
                                widgetEl.classList.add('widget-shape-square');
                                
                                const titleEl = document.createElement('div');
                                titleEl.className = 'widget-memo-title';
                                titleEl.textContent = memo.title || '无标题';
                                
                                const contentEl = document.createElement('div');
                                contentEl.className = 'widget-memo-content';
                                contentEl.innerHTML = memo.content || '无内容';
                                
                                // [V2 修复] 计算并应用 line-clamp
                                const heightInUnits = parseInt(rows, 10);
                                if (heightInUnits > 0) {
                                    const lineClampValue = 1 + (heightInUnits - 1) * 2;
                                    contentEl.style.webkitLineClamp = lineClampValue;
                                    contentEl.style.setProperty('-webkit-line-clamp', lineClampValue); // 确保生效
                                }

                                widgetEl.append(titleEl, contentEl);
                            }
                            widgetEl.style.cursor = 'pointer';
                            widgetEl.onclick = () => showMemoPopup(widgetConfig.content);
                        } else {
                            widgetEl.textContent = '备忘录未找到';
                        }
                        break;
                    case 'shortcut':
                        const buttonConfig = findButtonConfigByHref(widgetConfig.content);
                        widgetEl.classList.add('widget-shortcut');
                        widgetEl.textContent = buttonConfig ? buttonConfig.text : '快捷方式';
                        widgetEl.dataset.href = widgetConfig.content;
                        widgetEl.addEventListener('click', function (e) {
                            e.stopPropagation();
                            const href = this.dataset.href;
                            const config = findButtonConfigByHref(href);
                            if (config && config.openExternally) {
                                window.open(href, '_blank', 'noopener,noreferrer');
                            } else {
                                openIframeModal(href);
                            }
                        });
                        break;
                    case 'html':
                        Object.assign(widgetEl.style, { padding: '0', overflow: 'hidden' });
                        const iframe = document.createElement('iframe');
                        iframe.className = 'widget-html-iframe';
                        iframe.srcdoc = widgetConfig.content || '<p style="color: inherit; opacity: 0.6;">未提供HTML内容</p>';
                        iframe.scrolling = 'no';
                        widgetEl.appendChild(iframe);
                        break;
                }
                
                componentContainer.appendChild(widgetEl);
                grid.appendChild(componentContainer);
            });
        }


        // 初始化手机模式管理器
        MobileModeManager.init();
        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */
        // ★★★ 新增：通过 GitHub GraphQL API 获取 Giscus 统计数据的函数
        async function fetchGiscusStats(phoneId, phoneName) {
            // 检查 GitHub 配置是否完整
            if (!GITHUB_CONFIG.owner || !GITHUB_CONFIG.repo || !GITHUB_CONFIG.token) {
                console.warn("GitHub config is incomplete. Cannot fetch Giscus stats.");
                return null;
            }
            // [核心修改] 硬编码为社区评论仓库，而不是使用用户的个人数据仓库
            const repoOwner = 'Yeexein';
            const repoName = 'Jellyfish-Comments';
            // Giscus 讨论区的固定 ID，从你的 HTML 配置中获取
            const categoryId = "DIC_kwDOQBfb-84CwlT0";
            // Giscus 用来唯一标识帖子的标题
            const discussionTitle = `手机安利区: ${phoneName} (${phoneId})`;

            // 构造 GraphQL 查询语句
            const query = `
                query DiscussionStats($repoOwner: String!, $repoName: String!, $categoryId: ID!, $discussionTitle: String!) {
                  repository(owner: $repoOwner, name: $repoName) {
                    discussions(categoryId: $categoryId, first: 1, filterBy: {discussionTitle: $discussionTitle}) {
                      nodes {
                        comments {
                          totalCount
                        }
                        reactions {
                          totalCount
                        }
                        reactionGroups {
                          content
                          users {
                            totalCount
                          }
                        }
                      }
                    }
                  }
                }
            `;

            try {
                const response = await fetch('https://api.github.com/graphql', {
                    method: 'POST',
                    headers: {
                        'Authorization': `bearer ${GITHUB_CONFIG.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query,
                        variables: {
                            repoOwner: repoOwner, // [核心修改] 使用硬编码的 owner
                            repoName: repoName,   // [核心修改] 使用硬编码的 repo name
                            categoryId,
                            discussionTitle
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`GitHub API Error: ${response.status}`);
                }

                const json = await response.json();
                const discussion = json.data?.repository?.discussions?.nodes[0];
                
                if (!discussion) {
                    return { reactions: [], comments: 0 }; // 讨论还未创建
                }

                // Giscus 支持的表情和顺序
                const reactionOrder = ['THUMBS_UP', 'THUMBS_DOWN', 'LAUGH', 'HOORAY', 'CONFUSED', 'HEART', 'ROCKET', 'EYES'];
                const emojiMap = { 'THUMBS_UP': '👍', 'THUMBS_DOWN': '👎', 'LAUGH': '😄', 'HOORAY': '🎉', 'CONFUSED': '😕', 'HEART': '❤️', 'ROCKET': '🚀', 'EYES': '👀' };

                const reactions = reactionOrder.map(content => {
                    const group = discussion.reactionGroups.find(g => g.content === content);
                    return {
                        emoji: emojiMap[content],
                        count: group ? group.users.totalCount : 0
                    };
                }).filter(r => r.count > 0); // 只保留有计数的表情

                return {
                    reactions,
                    comments: discussion.comments.totalCount
                };
            } catch (error) {
                console.error('Failed to fetch Giscus stats:', error);
                return null;
            }
        }

        /* =============================================================== */
        /* ================== [重构] 手机收藏馆逻辑 v2 (支持筛选) ========== */
        /* =============================================================== */
        const PhoneCollectionManager = (() => {
            // 数据源保持不变
            const phoneData = [
                { id: 'eve-phone', name: 'EVE', authorId: '7551854600', acquisition: 'QQ群购买', price: '19.9元', status: '暂时停售' },
                { id: 'jrsy-phone', name: 'jrsy小手机', authorId: '6536602273', acquisition: 'QQ群', price: '5.2元', status: '在售' },
                { id: 'threeseven-phone', name: '37 Chat', authorId: '26299019345', acquisition: '小红书购买', price: '21.14元', status: '内测' },
                { id: 'fruit-phone', name: '果咩机', authorId: '26962794223', acquisition: '小红书进群', price: '无偿', status: '开放' },
                { id: 'bubble-phone', name: '气泡机', authorId: '26962794223', acquisition: '小红书进群', price: '无偿', status: '开放' },
                { id: 'glutinousrice-phone', name: '糯米机', authorId: '933580405', acquisition: 'QQ群', price: '无偿', status: '开放' },
                { id: 'whale-phone', name: 'WhaleLLT', authorId: '42944921236', acquisition: 'QQ群', price: '无偿', status: '获取版权，暂关闭' },
                { id: 'koko-phone', name: 'koko小手机', authorId: '970432882', acquisition: 'QQ群', price: '14.9元', status: '在售' },
                { id: 'mumu-phone', name: '慕慕小手机', authorId: '26211349174', acquisition: 'QQ群', price: '19.9元', status: '内测，在售' },
                { id: 'raven-phone', name: 'RavenPhone', authorId: '999988424', acquisition: 'DC专属社区，需审核', price: '无偿', status: '开放' },
                { id: 'threethree-phone', name: '33聊天室', authorId: '124491716', acquisition: '小红书购买', price: '9.9元', status: '已停售' },
                { id: 'mujian-phone', name: '幕间小手机', authorId: '9240783072', acquisition: 'QQ群', price: '无偿', status: '2.0内测中' },
                { id: 'tuk-phone', name: 'EPhone-兔K', authorId: 'glacier1024', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'maomaoning-phone', name: 'EPhone-猫猫宁', authorId: '94903121580', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'yique-phone', name: 'EPhone-以雀', authorId: '571856738', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'threethreezero-phone', name: 'EPhone-330', authorId: '（没找到）', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'jcy-phone', name: 'EPhone-JCY', authorId: '（没找到）', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'youzi-phone', name: '柚子机', authorId: '5007799940', acquisition: 'QQ群', price: '无偿', status: '开放测试' },
                { id: 'jing-phone', name: '镜', authorId: 'il_057', acquisition: 'QQ群', price: '无偿', status: '开放' },
            ];

            const ui = {
                collectionModal: document.getElementById('phoneCollectionModal'),
                detailModal: document.getElementById('phoneDetailModal'),
                listContainer: document.getElementById('phone-list-container'),
                detailContainer: document.getElementById('phone-detail-content'),
                detailTitle: document.getElementById('phone-detail-title'),
                searchInput: document.getElementById('phoneSearchInput'),
                // 新增筛选相关UI元素
                filterBtn: document.getElementById('phoneFilterBtn'),
                filterModal: document.getElementById('phoneFilterModal'),
                selectedFiltersContainer: document.getElementById('selected-filters-container'),
                applyFiltersBtn: document.getElementById('apply-filters-btn'),
                clearFiltersBtn: document.getElementById('clear-filters-btn'),
            };

            const filterOptions = {
                status: [ '开放', '在售', '停售', '内测', '关闭' ],
                price: [ '有偿', '无偿' ],
                user: [
                    { text: '已拥有', value: 'owned' },
                    { text: '愿望单', value: 'wishlist' },
                    { text: '未拥有', value: 'not_owned' }
                ]
            };
            
            let activeFilters = []; // 存储结构: { group: 'status', value: '在售' }

            // 状态管理函数保持不变
            function getCollectionStatus() { try { return JSON.parse(localStorage.getItem('phoneCollectionStatus') || '{}'); } catch (e) { return {}; } }
            function saveCollectionStatus(statusData) { localStorage.setItem('phoneCollectionStatus', JSON.stringify(statusData)); }
            function getRandomMacaronColor() { const p = ['#FFD1DC','#C5E0F2','#D9C7F5','#D5ECD9','#FFEDCC','#FBBEAD','#FFF4F4','#D6F0E6','#F0D6E8','#E5F2BC','#A5E1D4','#F8F5F0','#F7E0B3']; const u = new Set(Object.values(getCollectionStatus()).map(s=>s.color)); const a = p.filter(c=>!u.has(c)); return a.length>0?a[Math.floor(Math.random()*a.length)]:p[Math.floor(Math.random()*p.length)]; }
            function getPinnedPhones() { try { return JSON.parse(localStorage.getItem('pinnedPhones') || '[]'); } catch (e) { return []; } }
            function savePinnedPhones(pinnedIds) { localStorage.setItem('pinnedPhones', JSON.stringify(pinnedIds)); }
            // Giscus 相关函数保持不变
            function getGiscusTheme() { const i=document.body.classList.contains('dark-mode'),g=document.body.classList.contains('theme-glass'); return g?(i?'transparent_dark':'light'):(i?'dark':'light'); }
            function showGiscusComments(phoneId, phoneName) { const m=document.getElementById('phoneCommentsModal'),c=m.querySelector('.giscus');c.innerHTML='';const s=document.createElement('script'),a={'src':'https://giscus.app/client.js','data-repo':'Yeexein/Jellyfish-Comments','data-repo-id':'R_kgDOQBfb-w','data-category':'Announcements','data-category-id':'DIC_kwDOQBfb-84CwlT0','data-mapping':'specific','data-term':`手机安利区: ${phoneName} (${phoneId})`,'data-strict':'0','data-reactions-enabled':'1','data-emit-metadata':'0','data-input-position':'top','data-theme':getGiscusTheme(),'data-lang':'zh-CN','crossorigin':'anonymous','async':''};Object.entries(a).forEach(([k,v])=>s.setAttribute(k,v));c.appendChild(s);document.getElementById('phone-comments-title').textContent=`${phoneName} - 安利区`;m.classList.add('show');}

            
            // ★★★ 新增：核心标签映射逻辑 ★★★
            function getPhoneTags(phone) {
                const tags = [];
                // 价格标签
                if (phone.price.includes('无偿') || phone.price.includes('免费')) {
                    tags.push({ group: 'price', value: '无偿' });
                } else {
                    tags.push({ group: 'price', value: '有偿' });
                }
                // 状态标签 (简化逻辑)
                if (phone.status.includes('开放')) tags.push({ group: 'status', value: '开放' });
                else if (phone.status.includes('在售')) tags.push({ group: 'status', value: '在售'});
                else if (phone.status.includes('停售')) tags.push({ group: 'status', value: '停售' });
                else if (phone.status.includes('内测')) tags.push({ group: 'status', value: '内测' });
                else tags.push({ group: 'status', value: '关闭' });
                
                return tags;
            }

            // ★★★ 新增：检查手机是否匹配筛选条件的函数 ★★★
            function checkPhoneFilter(phone, filter) {
                switch(filter.group) {
                    case 'status':
                    case 'price':
                        return getPhoneTags(phone).some(tag => tag.group === filter.group && tag.value === filter.value);
                    case 'user':
                        const userStatusData = getCollectionStatus()[phone.id];
                        const userStatus = userStatusData ? userStatusData.status : 'not_owned';
                        return userStatus === filter.value;
                    default:
                        return true;
                }
            }
            
            // ★★★ 新增：填充筛选模态框的选项 ★★★
            function populateFilterOptions() {
                Object.keys(filterOptions).forEach(group => {
                    const container = document.getElementById(`filter-options-${group}`);
                    if (!container) return;
                    container.innerHTML = '';
                    filterOptions[group].forEach(option => {
                        const text = typeof option === 'string' ? option : option.text;
                        const value = typeof option === 'string' ? option : option.value;
                        const optionEl = document.createElement('button');
                        optionEl.className = 'filter-tag-option';
                        optionEl.textContent = text;
                        optionEl.dataset.group = group;
                        optionEl.dataset.value = value;
                        container.appendChild(optionEl);
                    });
                });
            }

            // ★★★ 新增：更新筛选器UI的函数 ★★★
            function updateFilterSelectionUI() {
                // 更新已选中的标签区域
                ui.selectedFiltersContainer.innerHTML = '';
                activeFilters.forEach(filter => {
                    const text = filterOptions[filter.group].find(opt => (typeof opt === 'string' ? opt : opt.value) === filter.value)?.text || filter.value;
                    const tagEl = document.createElement('div');
                    tagEl.className = 'selected-filter-tag';
                    tagEl.innerHTML = `<span>${text}</span><span class="remove-tag-btn" data-group="${filter.group}" data-value="${filter.value}">&times;</span>`;
                    ui.selectedFiltersContainer.appendChild(tagEl);
                });

                // 更新可选标签的 .selected 状态
                ui.filterModal.querySelectorAll('.filter-tag-option').forEach(optionEl => {
                    const isSelected = activeFilters.some(f => f.group === optionEl.dataset.group && f.value === optionEl.dataset.value);
                    optionEl.classList.toggle('selected', isSelected);
                });
            }
            
            // ★★★ 重构：主列表渲染函数 ★★★
            function displayPhoneList() {
                const searchTerm = ui.searchInput.value.toLowerCase().trim();
                const pinnedIds = getPinnedPhones();

                // 1. 文本搜索过滤
                let filteredPhones = phoneData.filter(phone => 
                    phone.name.toLowerCase().includes(searchTerm) ||
                    phone.authorId.toLowerCase().includes(searchTerm)
                );

                // 2. 标签筛选
                if (activeFilters.length > 0) {
                    const groupedFilters = activeFilters.reduce((acc, filter) => {
                        if (!acc[filter.group]) acc[filter.group] = [];
                        acc[filter.group].push(filter);
                        return acc;
                    }, {});

                    filteredPhones = filteredPhones.filter(phone => {
                        // AND logic between groups
                        return Object.values(groupedFilters).every(group => {
                            // OR logic within a group
                            return group.some(filter => checkPhoneFilter(phone, filter));
                        });
                    });
                }
                
                // 3. 置顶和排序逻辑 (保持不变)
                const pinnedPhones = [];
                const unpinnedPhones = [];
                filteredPhones.forEach(phone => {
                    if (pinnedIds.includes(phone.id)) {
                        pinnedPhones.push(phone);
                    } else {
                        unpinnedPhones.push(phone);
                    }
                });
                for (let i = unpinnedPhones.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [unpinnedPhones[i], unpinnedPhones[j]] = [unpinnedPhones[j], unpinnedPhones[i]];
                }
                
                renderPhoneList([...pinnedPhones, ...unpinnedPhones]);
            }

            // ★★★ 重构：列表项渲染函数 (保持不变，因为状态是在CSS中应用的) ★★★
             function renderPhoneList(phonesToRender) {
                ui.listContainer.innerHTML = '';
                if (phonesToRender.length === 0) {
                    ui.listContainer.innerHTML = '<p class="empty-list-placeholder" style="grid-column: 1 / -1;">未找到匹配的手机</p>';
                    return;
                }
                const allStatuses = getCollectionStatus();
                phonesToRender.forEach(phone => {
                    const item = document.createElement('div');
                    item.className = 'phone-partition-item';
                    item.dataset.phoneId = phone.id;
                    item.innerHTML = `<div class="phone-partition-icon">${phone.icon || ''}</div><div class="phone-partition-name">${phone.name}</div>`;
                    item.style.animationDelay = `${Math.random() * -6}s`;
                    const statusData = allStatuses[phone.id];
                    if (statusData) {
                        item.classList.add(`status-${statusData.status}`);
                        item.style.setProperty('--status-color', statusData.color);
                    }
                    item.addEventListener('click', () => renderPhoneDetail(phone.id));
                    ui.listContainer.appendChild(item);
                });
            }

            // ★★★ 重构：详情页渲染函数 v2 (恢复独立售价和状态) ★★★
            function renderPhoneDetail(phoneId) {
                const phone = phoneData.find(p => p.id === phoneId);
                if (!phone) return;

                const statusBtn = document.getElementById('phoneStatusBtn');
                const statusMenu = document.getElementById('phoneStatusMenu');

                // 核心：更新状态按钮的UI
                function updateStatusButtonUI() {
                    const currentStatus = getCollectionStatus()[phoneId];
                    if (!currentStatus) {
                        statusBtn.innerHTML = '◌';
                        statusBtn.style.color = 'inherit';
                    } else if (currentStatus.status === 'owned') {
                        statusBtn.innerHTML = '★';
                        statusBtn.style.color = '#ffc107'; // 黄色
                    } else if (currentStatus.status === 'wishlist') {
                        statusBtn.innerHTML = '♥';
                        statusBtn.style.color = '#ff85a2'; // 粉色
                    }
                }
                
                ui.detailTitle.textContent = phone.name;
                updateStatusButtonUI();

                // 移除并重新绑定事件，防止重复监听
                if (statusMenu.handler) statusMenu.removeEventListener('click', statusMenu.handler);
                if (statusBtn.handler) statusBtn.removeEventListener('click', statusBtn.handler);
                if (window.currentHideMenuHandler) document.body.removeEventListener('click', window.currentHideMenuHandler);

                statusBtn.handler = (e) => { e.stopPropagation(); statusMenu.classList.toggle('show'); };
                statusBtn.addEventListener('click', statusBtn.handler);

                statusMenu.handler = (e) => {
                    const button = e.target.closest('.status-option-btn');
                    if (button) {
                        const newStatus = button.dataset.status;
                        const allStatuses = getCollectionStatus();
                        if (newStatus === 'none') {
                            delete allStatuses[phoneId];
                            showTopToast(`已将 "${phone.name}" 恢复为未拥有`, 2000);
                        } else {
                            const currentColor = allStatuses[phoneId]?.color || getRandomMacaronColor();
                            allStatuses[phoneId] = { status: newStatus, color: currentColor };
                            const statusText = newStatus === 'owned' ? '已拥有' : '已加入愿望单';
                            showTopToast(`已将 "${phone.name}" 标记为 ${statusText}`, 2000);
                        }
                        saveCollectionStatus(allStatuses);
                        statusMenu.classList.remove('show');
                        updateStatusButtonUI();
                        displayPhoneList(); // 刷新主列表以同步状态颜色
                    }
                };
                statusMenu.addEventListener('click', statusMenu.handler);

                window.currentHideMenuHandler = (e) => {
                    if (!statusBtn.contains(e.target) && !statusMenu.contains(e.target)) {
                        statusMenu.classList.remove('show');
                    }
                };
                document.body.addEventListener('click', window.currentHideMenuHandler);
                
                // ★★★ 核心修改：恢复独立的售价和状态展示 ★★★
                ui.detailContainer.innerHTML = `
                    <div class="detail-info-group">
                        <label>作者ID</label>
                        <div class="detail-info-value copyable" data-id="${phone.authorId}">
                            <span>${phone.authorId}</span>
                            <span>❏</span>
                        </div>
                    </div>
                    <div class="detail-info-group">
                        <label>获取方式</label>
                        <div class="detail-info-value">${phone.acquisition}</div>
                    </div>
                    <div class="detail-info-group">
                        <label>售价</label>
                        <div class="detail-info-value">${phone.price}</div>
                    </div>
                    <div class="detail-info-group">
                        <label>状态</label>
                        <div class="detail-info-value">${phone.status}</div>
                    </div>
                    <button id="enterCommentsBtn" class="modal-button" data-phone-id="${phone.id}" style="margin-top: 10px;">进入安利区</button>
                    `;
                
                // 为复制和评论按钮绑定事件
                ui.detailContainer.querySelector('.copyable').addEventListener('click', function() {
                    navigator.clipboard.writeText(this.dataset.id).then(() => showTopToast(`已复制作者ID: ${this.dataset.id}`, 2000));
                });
                
                ui.detailContainer.querySelector('#enterCommentsBtn').addEventListener('click', function() {
                    const phoneForComment = phoneData.find(p => p.id === this.dataset.phoneId);
                    if (!phoneForComment) return;
                    const hasSeenNotice = localStorage.getItem('communityNoticeSeen') === 'true';
                    if (hasSeenNotice) {
                        ui.detailModal.classList.remove('show');
                        setTimeout(() => showGiscusComments(phoneForComment.id, phoneForComment.name), 200);
                    } else {
                        const noticeModal = document.getElementById('communityNoticeModal');
                        noticeModal.classList.add('show');
                        const confirmBtn = document.getElementById('confirmNoticeBtn');
                        const newConfirmBtn = confirmBtn.cloneNode(true);
                        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                        newConfirmBtn.addEventListener('click', () => {
                            if (document.getElementById('dontRemindCheckbox').checked) {
                                localStorage.setItem('communityNoticeSeen', 'true');
                                document.getElementById('showNoticeBell').style.display = 'block';
                            }
                            noticeModal.classList.remove('show');
                            ui.detailModal.classList.remove('show');
                            setTimeout(() => showGiscusComments(phoneForComment.id, phoneForComment.name), 200);
                        });
                    }
                });

                ui.detailModal.classList.add('show');
            }


             return {
                init() {
                    // ★★★ 新增：清除筛选条件的函数 ★★★
                    const clearAllFilters = () => {
                        activeFilters = [];
                        ui.searchInput.value = '';
                        updateFilterSelectionUI();
                    };

                    document.getElementById('phoneCollectionBtn').addEventListener('click', () => {
                        clearAllFilters(); // 打开时先清除旧的
                        displayPhoneList(); 
                        ui.collectionModal.classList.add('show'); 
                        toggleFabMenu(false);
                        document.getElementById('showNoticeBell').style.display = localStorage.getItem('communityNoticeSeen') === 'true' ? 'block' : 'none';
                    });

                    // ★★★ 新增：为主模态框的关闭按钮和背景点击添加清除筛选的逻辑 ★★★
                    const closeBtn = ui.collectionModal.querySelector('.close-btn');
                    if(closeBtn) closeBtn.addEventListener('click', clearAllFilters);
                    ui.collectionModal.addEventListener('click', (e) => {
                        if (e.target === ui.collectionModal) {
                            clearAllFilters();
                        }
                    });

                    document.getElementById('showNoticeBell').addEventListener('click', () => document.getElementById('communityNoticeModal').classList.add('show'));
                    ui.searchInput.addEventListener('input', displayPhoneList);
                    
                    // 初始化筛选器
                    populateFilterOptions();
                    
                    ui.filterBtn.addEventListener('click', () => ui.filterModal.classList.add('show'));
                    ui.applyFiltersBtn.addEventListener('click', () => { displayPhoneList(); ui.filterModal.classList.remove('show'); });
                    ui.clearFiltersBtn.addEventListener('click', () => { activeFilters = []; updateFilterSelectionUI(); });
                    
                    // 筛选模态框内的点击事件委托
                    ui.filterModal.addEventListener('click', (e) => {
                        const option = e.target.closest('.filter-tag-option');
                        const removeBtn = e.target.closest('.remove-tag-btn');
                        
                        if (option && !option.classList.contains('selected')) {
                            // 增加 text 属性，方便在“已选”区域显示
                            activeFilters.push({ group: option.dataset.group, value: option.dataset.value, text: option.textContent });
                        } else if (removeBtn) {
                            activeFilters = activeFilters.filter(f => !(f.group === removeBtn.dataset.group && f.value === removeBtn.dataset.value));
                        } else {
                            return;
                        }
                        updateFilterSelectionUI();
                    });
                },
                getGiscusTheme: getGiscusTheme
            };
        })();

        // 初始化手机收藏馆
        PhoneCollectionManager.init();
        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */
        
        /* =============================================================== */
        /* ================== [新增] 全局字体管理逻辑 (V2) =================== */
        /* =============================================================== */
        const FontManager = (() => {
            const FONT_FAMILY_NAME = 'GlobalCustomFont'; // 使用一个固定的内部字体族名

            const ui = {
                styleTag: document.getElementById('global-font-style'),
                urlInput: document.getElementById('fontUrlInput'),
                applyBtn: document.getElementById('applyFontBtn'),
                clearBtn: document.getElementById('clearFontBtn'),
                presetSelector: document.getElementById('fontPresetSelector'),
                addPresetBtn: document.getElementById('addFontPresetBtn'),
                updatePresetBtn: document.getElementById('updateFontPresetBtn'),
                deletePresetBtn: document.getElementById('deleteFontPresetBtn'),
            };

            function applyFont(fontUrl) {
                if (fontUrl) {
                    const fontFaceRule = `@font-face {
                        font-family: '${FONT_FAMILY_NAME}';
                        src: url('${fontUrl}');
                        font-display: swap;
                    }`;
                    const globalRule = `* {
                        font-family: '${FONT_FAMILY_NAME}', Arial, -apple-system, BlinkMacSystemFont, sans-serif !important;
                    }`;
                    ui.styleTag.innerHTML = fontFaceRule + '\n' + globalRule;
                } else {
                    ui.styleTag.innerHTML = ''; // 清空样式以恢复默认
                }
            }

            function populatePresetDropdown() {
                const currentVal = ui.presetSelector.value;
                ui.presetSelector.innerHTML = '<option value="">选择或管理预设...</option>';
                if (!currentConfig.settings.fontPresets) {
                    currentConfig.settings.fontPresets = [];
                }
                currentConfig.settings.fontPresets.forEach((preset, index) => {
                    ui.presetSelector.innerHTML += `<option value="${index}">${preset.name}</option>`;
                });
                if (currentVal) ui.presetSelector.value = currentVal;
            }

            function loadCurrentSettings() {
                const fontSettings = currentConfig.settings.globalFont || { url: '' };
                ui.urlInput.value = fontSettings.url;
                applyFont(fontSettings.url);
                populatePresetDropdown();
            }

            function setupEventListeners() {
                ui.applyBtn.addEventListener('click', () => {
                    const fontUrl = ui.urlInput.value.trim();
                    if (!fontUrl) {
                        alert('字体链接不能为空！');
                        return;
                    }
                    applyFont(fontUrl);
                    currentConfig.settings.globalFont = { name: FONT_FAMILY_NAME, url: fontUrl };
                    saveGlobalConfig('Apply global font');
                    showTopToast('全局字体已应用！', 2000);
                });

                ui.clearBtn.addEventListener('click', () => {
                    ui.urlInput.value = '';
                    applyFont('');
                    currentConfig.settings.globalFont = { name: '', url: '' };
                    saveGlobalConfig('Clear global font');
                    showTopToast('已恢复默认字体。', 2000);
                });

                ui.presetSelector.addEventListener('change', () => {
                    const index = ui.presetSelector.value;
                    if (index === '') {
                        // 如果选择 "选择预设"，则恢复到当前非预设状态
                        const currentFont = currentConfig.settings.globalFont;
                        ui.urlInput.value = currentFont.url;
                        applyFont(currentFont.url);
                        return;
                    }
                    const preset = currentConfig.settings.fontPresets[index];
                    if (preset) {
                        ui.urlInput.value = preset.url;
                        applyFont(preset.url);
                        currentConfig.settings.globalFont = { name: FONT_FAMILY_NAME, url: preset.url };
                        saveGlobalConfig('Apply font preset');
                    }
                });

                ui.addPresetBtn.addEventListener('click', () => {
                    const presetName = prompt('请输入新预设的名称：');
                    if (!presetName || presetName.trim() === '') return;
                    
                    const fontUrl = ui.urlInput.value.trim();
                    if (!fontUrl) {
                        alert('字体链接不能为空，无法保存预设。');
                        return;
                    }
                    if (currentConfig.settings.fontPresets.some(p => p.name === presetName.trim())) {
                        alert('该预设名称已存在！');
                        return;
                    }
                    
                    currentConfig.settings.fontPresets.push({
                        name: presetName.trim(),
                        url: fontUrl
                    });
                    saveGlobalConfig(`Save font preset: ${presetName.trim()}`);
                    populatePresetDropdown();
                    ui.presetSelector.value = currentConfig.settings.fontPresets.length - 1;
                    showTopToast('预设已保存！', 2000);
                });

                ui.updatePresetBtn.addEventListener('click', () => {
                    const index = ui.presetSelector.value;
                    if (index === '') {
                        alert('请先从下拉框中选择一个要修改的预设。');
                        return;
                    }

                    const presetToUpdate = currentConfig.settings.fontPresets[index];
                    const newName = prompt('请输入新的预设名称：', presetToUpdate.name);

                    if (!newName || newName.trim() === '') {
                        return; // 用户取消或输入为空
                    }
                    
                    const trimmedNewName = newName.trim();
                    
                    // 检查新名称是否与自身相同（大小写不敏感）
                    if (trimmedNewName.toLowerCase() === presetToUpdate.name.toLowerCase()) {
                        return; // 名称未改变
                    }

                    // 检查新名称是否与其他预设冲突（排除自身）
                    const isDuplicate = currentConfig.settings.fontPresets.some((p, i) => 
                        i !== parseInt(index) && p.name.toLowerCase() === trimmedNewName.toLowerCase()
                    );

                    if (isDuplicate) {
                        alert('该预设名称已存在，请换一个名称。');
                        return;
                    }

                    const oldName = presetToUpdate.name;
                    presetToUpdate.name = trimmedNewName;
                    
                    saveGlobalConfig(`Rename font preset from "${oldName}" to "${trimmedNewName}"`);
                    // 刷新下拉列表以显示新名称，并保持选中状态
                    populatePresetDropdown();
                    ui.presetSelector.value = index; 
                    
                    showTopToast(`预设已重命名为 "${trimmedNewName}"！`, 2000);
                });


                ui.deletePresetBtn.addEventListener('click', () => {
                    const index = ui.presetSelector.value;
                    if (index === '') {
                        alert('请先从下拉框中选择一个要删除的预设。');
                        return;
                    }
                    
                    const presetName = currentConfig.settings.fontPresets[index].name;
                    if (confirm(`确定要删除预设 "${presetName}" 吗？`)) {
                        currentConfig.settings.fontPresets.splice(index, 1);
                        saveGlobalConfig(`Delete font preset: ${presetName}`);
                        populatePresetDropdown();
                        // 删除后，将输入框和应用状态恢复到当前保存的全局设置
                        const currentFont = currentConfig.settings.globalFont;
                        ui.urlInput.value = currentFont.url;
                        applyFont(currentFont.url);
                        showTopToast('预设已删除。', 2000);
                    }
                });
            }

            return {
                init() {
                    loadCurrentSettings();
                    setupEventListeners();
                }
            };
        })();


        // 初始化字体管理器
        FontManager.init();
        CodebergManager.init(); // [新增] 初始化 Codeberg 管理器

        
        // [核心修正] 初始化备份提醒管理器
        // 1. 先调用 initUI() 找到所有HTML元素
        BackupReminderManager.initUI();
        // 2. 再调用 init() 为这些元素绑定事件
        BackupReminderManager.init();

        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */
    });



            // [新增] 锁屏组件交互事件监听
            document.getElementById('lockscreenGrid').addEventListener('click', (e) => {
                const li = e.target.closest('li[data-note-id]');
                if (!li) return;

                const noteId = parseInt(li.dataset.noteId, 10);
                const lineIndex = parseInt(li.dataset.lineIndex, 10);

                const note = memoryCache.memo.notes.find(n => n.id === noteId);
                if (!note) return;
                
                // 解析 note.content 为一个临时的DOM结构
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = note.content;

                const targetLi = tempDiv.querySelectorAll('li')[lineIndex];
                if (targetLi) {
                    // 切换完成状态
                    targetLi.classList.toggle('completed');

                    // 将修改后的 HTML 写回数据模型
                    note.content = tempDiv.innerHTML;

                    // 立即重新渲染锁屏以提供即时反馈
                    renderLockscreenWidgets();

                    // 安排云同步
                    MemoryApp.scheduleSave(); // 复用 MemoryApp 的保存逻辑
                }
            });
    </script>
    <!-- ★★★ 新增：社区须知弹窗 ★★★ -->
    <div class="modal-overlay" id="communityNoticeModal">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header">
                <div class="modal-title-group">社区须知</div>
                <button class="close-btn" data-modal-id="communityNoticeModal">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-top: 0;">为维护一个友好、互相尊重的交流环境，请遵守以下规范：</p>
                <!-- 使用你已经润色好的文字 -->
                <ul style="padding-left: 20px; line-height: 1.8;">
                    <li><b>尊重原创</b>：禁止分享作者不允许公开的网址链接和文件。</li>
                    <li><b>友好交流</b>：禁止拉踩对比。</li>
                    <li><b>文明发言</b>：禁止辱骂、阴阳、交换私下联系方式。</li>
                </ul>
                <p>有以上行为可截图私信群内管理员进行删除和拉黑。</p>
                <p><b>小提示</b>：想要删除评论，添加图片、链接等可以点击账号旁边的时间，进入github界面进行操作。</p>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center; padding: 15px 20px 20px; flex-shrink: 0;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 14px; color: #889;">
                    <input type="checkbox" id="dontRemindCheckbox"> 不再提醒
                </label>
                <button id="confirmNoticeBtn" class="modal-button" style="width: auto; padding: 10px 20px;">我已阅读并同意</button>
            </div>
        </div>
    </div>
    <!-- [新增] 数据恢复确认模态框 V2 -->
    <div class="modal-overlay" id="dataRecoveryModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title-group">
                    <span>🛡️ 选择要恢复的版本</span>
                </div>
            </div>
            <div class="modal-body">
                <p>检测到云端数据为空！我们在您的历史记录中找到了以下几个最近的有效版本：</p>
                
                <div id="recovery-versions-list">
                    <!-- JS 动态填充版本列表 -->
                </div>
                
                <p style="margin-top: 15px;"><strong>请选择一个版本进行恢复。</strong></p>
                <div class="important-note" style="font-size: 13px; padding: 8px 12px; margin-top: 5px;">
                    <p>此操作将恢复您的主配置和“记忆”功能的数据，并覆盖云端的空数据。操作不可撤销。</p>
                </div>
            </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button id="cancelRecoveryBtn" class="modal-button">取消</button>
                <button id="confirmRecoveryBtn" class="modal-button primary" disabled>恢复选中版本</button>
            </div>
        </div>
    </div>
        <!-- [新增] 首次使用引导模态框 -->
    <div class="modal-overlay" id="firstTimeGuideModal">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header">
                <div class="modal-title-group">欢迎使用 Jellyfish Island</div>
            </div>
            <div class="modal-body" id="welcome-modal-content">
                <p>为了同步和备份您的所有个性化数据，您需要先完成一个简单的云端配置。</p>
                <p>配置步骤：</p>
                <ul>
                    <li>✔ 创建一个安全的GitHub“钥匙”</li>
                    <li>✔ 创建一个私密的云端“仓库”</li>
                    <li>✔ 在本应用中填入信息</li>
                </ul>
                <p>我们将引导您完成每一步。</p>
                <button id="startConfigGuideBtn" class="modal-button" style="margin-top: 15px;">开始配置</button>
            </div>
        </div>
    </div>

    <!-- [CORE-ADD] 自定义备份提醒设置弹窗 V2 -->
    <div class="modal-overlay" id="backupReminderSettingsModal">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>备份提醒设置</span></div>
                <button class="close-btn" data-modal-id="backupReminderSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- [MODIFIED] 提醒文字移到顶部并作为标题 -->
                <div class="form-section">
                    <h4 style="margin-bottom: 8px; text-align: left; font-size: 1em; color: #5a6778;">自定义提醒弹窗文字</h4>
                    <textarea id="backupMessageTextarea" class="modal-textarea" rows="2" placeholder="例如：该备份啦！"></textarea>
                </div>

                <!-- [MODIFIED] 自定义提醒时间部分重构 -->
                <div class="toggle-section" style="margin-top:20px; flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
                        <span>启用定时提醒</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="backupTimeBasedToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="backupTimeContainer" style="width: 100%; display: none; flex-direction: column; gap: 10px; margin-top: 10px;">
                        <!-- JS动态增加时间输入行 -->
                        <div id="backupTimeListContainer"></div>
                    </div>
                </div>

                <!-- [UNCHANGED] 关闭项目时提醒部分 -->
                <div class="toggle-section" style="margin-top: 15px;">
                    <span>退出项目时弹出提醒</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="backupOnExitToggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <!-- [UNCHANGED] 选择需要提醒的项目 (条件显示) -->
                <div id="backupProjectsSection" class="form-section" style="display: none; border-top: 1px solid rgba(128,128,128,0.1); padding-top: 15px; margin-top: 15px;">
                    <label>选择需要提醒的项目 (不选则全部提醒)</label>
                    <div id="backupProjectList" style="max-height: 150px; overflow-y: auto; display:flex; flex-direction:column; gap:8px; padding: 10px; border-radius: 10px; background:var(--bg-day-element); box-shadow: inset 2px 2px 4px var(--shadow-dark-day), inset -2px -2px 4px var(--shadow-light-day);">
                        <!-- JS动态填充项目列表 -->
                    </div>
                </div>
                
                <button id="saveBackupSettingsBtn" class="modal-button" style="margin-top: 20px;">保存设置</button>
            </div>
        </div>
    </div>
    <!-- ============ [新增] Codeberg 大文件存储设置模态框 ============ -->
    <div class="modal-overlay" id="codebergSettingsModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <div class="modal-title-group">Codeberg 大文件存储</div>
                <button class="close-btn" data-modal-id="codebergSettingsModal">&times;</button>
            </div>
            <div class="modal-body" style="gap: 25px;">
                <!-- 当前活动账户 -->
                <div class="form-section">
                    <label>当前活动账户</label>
                    <div id="codeberg-active-account-display" class="codeberg-account-display inactive">
                        未连接
                    </div>
                </div>

                <!-- 已授权账户列表 -->
                <div class="form-section">
                    <label>已授权账户列表</label>
                    <div id="codeberg-authorized-list" class="codeberg-account-list-container">
                        <!-- JS 动态填充 -->
                        <div class="codeberg-empty-list">暂无已授权的账户</div>
                    </div>
                </div>

                <!-- 操作按钮 -->
                <div class="form-section" style="margin-top: 10px;">
                    <a id="add-codeberg-account-btn" class="modal-button codeberg-auth-button" href="#" style="text-align: center; text-decoration: none; display: block;">
                        + 添加或切换 Codeberg 账户
                    </a>
                </div>
                
                <!-- 引导注册 -->
                <div class="codeberg-guidance-section">
                    <p>没有 Codeberg 账户？
                        <a href="https://codeberg.org/user/sign_up" target="_blank" rel="noopener noreferrer">点此免费注册</a>
                    </p>
                    <p>此功能用于存储大于 50MB 的文件。</p>
                </div>
            </div>
        </div>
    </div>
    <!-- ============ [新增结束] ============ -->
    <!-- [CORE-ADD END] -->
</body>
</html>
