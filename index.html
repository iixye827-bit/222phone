<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0"> -->
<!-- <meta http-equiv="Pragma" content="no-cache"> -->
<!-- <meta http-equiv="Expires" content="0"> -->

    <!-- PWA & Mobile App Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#16213e">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">

    <title>Jellyfish Island</title>
    <style>
        /* [CSS - V12.5.0 "Cascade Select"] */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Arial', -apple-system, BlinkMacSystemFont, sans-serif; }
        :root {
            --day-color1: #f5f7fa; --day-color2: #e4eaf5;
            --night-color1: #1f2a40; --night-color2: #16213e;
            --hold-border: #5B99E2; --text-day: #2d3748; --text-night: #e0e6f0;
            --handle-color-day: #5a6778; --handle-color-night: #ffffff;
            --bg-day-element: linear-gradient(135deg, var(--day-color2), var(--day-color1));
            --bg-night-element: linear-gradient(135deg, var(--night-color2), var(--night-color1));
            --shadow-light-day: rgba(255, 255, 255, 0.9); --shadow-dark-day: rgba(174, 190, 212, 0.4);
            --shadow-light-night: rgba(40, 52, 79, 0.9); --shadow-dark-night: rgba(0, 0, 0, 0.3);
        }
        body { 
            height: 100vh; /* 使用vh确保占满屏幕高度 */
            background-color: var(--day-color1);
            background-image: linear-gradient(135deg, var(--day-color1) 0%, var(--day-color2) 100%); 
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            padding: 0; /* [核心修改] 移除所有padding，让子元素可以触及屏幕边缘 */
            display: flex; flex-direction: column; align-items: center; 
            transition: background 0.5s ease; 
            touch-action: manipulation; 
            overflow: hidden; /* 禁止body本身滚动 */
        }
        body.dark-mode { 
            background-color: var(--night-color1);
            background-image: linear-gradient(135deg, var(--night-color1) 0%, var(--night-color2) 100%); 
            --hold-border: #63b3ed; color: var(--text-night); 
            --shadow-dark-night: rgba(0, 0, 0, 0.3);
        }
        body.dark-mode .nav-btn {
            box-shadow: 12px 12px 24px var(--shadow-dark-night), -12px -12px 24px var(--shadow-light-night);
        }
        body.dark-mode.theme-glass .nav-btn {
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
        }
        .title-card { 
            width: 100%; max-width: 800px; padding: 40px 20px; margin: 20px; /* [核心修改] 将左右margin设为20px来替代body的padding */
            box-sizing: border-box; /* [新增] 确保padding和border包含在width内 */
            border-radius: 16px; 
            box-shadow: 12px 12px 24px var(--shadow-dark-day), -12px -12px 24px var(--shadow-light-day); 
            background: var(--bg-day-element); backdrop-filter: blur(8px); text-align: center; 
            transition: all 0.5s ease; background-size: cover; background-position: center;
            flex-shrink: 0; /* 防止此元素在Flex布局中被压缩 */
        }

        body.dark-mode .title-card { box-shadow: 12px 12px 24px var(--shadow-dark-night), -12px -12px 24px var(--shadow-light-night); background: var(--bg-night-element); }
        .editable-title, .editable-subtitle { opacity: 0; transition: opacity 0.5s ease; background-color: rgba(255,255,255,0.1); backdrop-filter: blur(4px); } /* FOUC Fix */
        .editable-title { font-size: 36px; font-weight: 700; color: var(--text-day); margin-bottom: 20px; cursor: pointer; padding: 6px 12px; border-radius: 8px; display: block; width: fit-content; margin: 0 auto 20px auto; user-select: none; }
        body.dark-mode .editable-title { color: var(--text-night); background-color: rgba(0,0,0,0.1); }
        .editable-title:hover { background-color: rgba(255, 255, 255, 0.8); } body.dark-mode .editable-title:hover { background-color: rgba(50, 55, 75, 0.8); }
        .editable-subtitle { font-size: 16px; color: #5a6778; cursor: pointer; padding: 4px 8px; border-radius: 6px; display: block; width: fit-content; margin: 0 auto; line-height: 1.5; user-select: none; }
        body.dark-mode .editable-subtitle { color: #c0c6cc; background-color: rgba(0,0,0,0.1); }
        .editable-subtitle:hover { background-color: rgba(255, 255, 255, 0.8); color: var(--text-day); } body.dark-mode .editable-subtitle:hover { background-color: rgba(50, 55, 75, 0.8); color: var(--text-night); }
        
        .category-nav-container { 
            width: 100%; max-width: 1200px; overflow-x: auto; -webkit-overflow-scrolling: touch; 
            scrollbar-width: none; padding: 10px 20px; /* [核心修改] 增加左右padding */
            margin-bottom: 10px;
            box-sizing: border-box; /* [新增] 确保padding和border包含在width内 */
            flex-shrink: 0; /* 防止此元素在Flex布局中被压缩 */
        }

        .category-nav-container::-webkit-scrollbar { display: none; }
        .category-nav { display: flex; flex-wrap: nowrap; gap: 12px; padding: 0 20px; }
        .category-pill { flex-shrink: 0; padding: 8px 18px; border: none; border-radius: 20px; background: var(--bg-day-element); box-shadow: none; color: var(--text-day); font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; opacity: 0.6; }
        body.dark-mode .category-pill { background: var(--bg-night-element); color: var(--text-night); }
        body:not(.theme-glass) .category-pill.active { background: var(--bg-day-element); color: var(--text-day); font-weight: 700; box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); opacity: 1; }
        body.dark-mode:not(.theme-glass) .category-pill.active { background: #000000; color: var(--text-night); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        body.theme-glass .category-pill.active { background: rgba(255, 255, 255, 0.4); border-color: rgba(255, 255, 255, 0.6); opacity: 1; transform: scale(1.05); color: #000; }
        body.dark-mode.theme-glass .category-pill.active { color: #fff; background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.3); }

        /* ===== [新增] 包裹和滚动容器的样式 (V2 - 无感边界) ===== */
        .scrollable-nav-wrapper {
            width: 100%;
            flex-grow: 1; /* 让此容器占据所有剩余的垂直空间 */
            overflow-y: auto; /* 当内容超出时，只在此容器内显示垂直滚动条 */
            min-height: 0; /* Flex布局中的重要技巧，防止内容撑开容器 */
            padding-bottom: 30px; /* 保留底部空间，避免按钮紧贴屏幕边缘 */
            position: relative; /* [新增] 为伪元素的绝对定位提供基准 */
        }
        
        /* [新增] 使用伪元素创建无冲突的渐变遮罩 */
        .scrollable-nav-wrapper::before {
            content: '';
            position: absolute; /* 或使用 sticky 定位，取决于具体滚动效果需求 */
            top: 0;
            left: 0;
            right: 0;
            height: 15px; /* 渐变的高度 */
            background-image: linear-gradient(to bottom, var(--day-color1), transparent);
            z-index: 10; /* 确保在按钮内容之上 */
            pointer-events: none; /* 关键：让鼠标可以穿透此渐变层点击下方的按钮 */
            transition: background-image 0.5s ease; /* 跟随主题切换的过渡 */
        }

        /* [新增] 夜间模式适配 */
        body.dark-mode .scrollable-nav-wrapper::before {
            background-image: linear-gradient(to bottom, var(--night-color1), transparent);
        }

        /* [新增] 磨砂玻璃主题适配：隐藏分界线 */
        body.theme-glass .scrollable-nav-wrapper::before {
            background-image: none; /* 或者 background-image: linear-gradient(to bottom, transparent, transparent); */
        }

        /* 美化滚动条 (可选，但推荐) */
        .scrollable-nav-wrapper::-webkit-scrollbar {
            width: 5px;
        }
        .scrollable-nav-wrapper::-webkit-scrollbar-thumb {
            background: rgba(128, 128, 128, 0.3);
            border-radius: 3px;
        }
        /* ===== [新增结束] ===== */


        .nav-container { 
            width: 100%; max-width: 1200px; margin: 0 auto; /* [修改] 移除垂直margin，改为水平居中 */
            display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
            gap: 25px; padding: 10px 20px; /* [修改] 调整内边距 */
            position: relative; z-index: 10; touch-action: pan-y; 
        }

        .nav-btn { position: relative; padding: 22px 16px; border: none; border-radius: 14px; box-shadow: 10px 10px 20px var(--shadow-dark-day), -10px -10px 20px var(--shadow-light-day); background: var(--bg-day-element); backdrop-filter: blur(8px); font-size: 17px; font-weight: 600; color: var(--text-day); cursor: pointer; transition: all 0.3s ease; text-align: center; user-select: none; -webkit-tap-highlight-color: transparent; }
        .nav-btn.hold { border: 2px solid var(--hold-border); transform: scale(1.02); z-index: 5; box-shadow: 8px 8px 16px rgba(174, 190, 212, 0.5), -8px -8px 16px rgba(255, 255, 255, 0.8), 0 0 0 2px rgba(91, 153, 226, 0.3); }
        body.dark-mode .nav-btn { box-shadow: 10px 10px 20px var(--shadow-dark-night), -10px -10px 20px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        body.dark-mode .nav-btn:active { box-shadow: inset 6px 6px 12px rgba(0, 0, 0, 0.25), inset -6px -6px 12px var(--shadow-dark-night); }
        body.dark-mode .nav-btn.hold { box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.4), -8px -8px 16px rgba(40, 52, 79, 0.8), 0 0 0 2px rgba(99, 179, 237, 0.3); }
        .nav-btn:hover { transform: translateY(-3px); filter: brightness(1.05); }
        .nav-btn:active { box-shadow: inset 6px 6px 12px var(--shadow-dark-day), inset -6px -6px 12px var(--shadow-light-day); transform: translateY(0); }
        body.dark-mode .nav-btn:active { box-shadow: inset 6px 6px 12px rgba(0, 0, 0, 0.25), inset -6px -6px 12px rgba(40, 52, 79, 0.8); }
        .delete-icon { display: none; position: absolute; top: -5px; right: -5px; width: 24px; height: 24px; background-color: #f56565; color: white; border-radius: 50%; border: 2px solid white; font-size: 16px; font-weight: bold; line-height: 20px; text-align: center; cursor: pointer; z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .page-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(2px); z-index: 99; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .page-overlay.show { opacity: 1; pointer-events: auto; }
        .page-overlay.management-overlay { background: transparent; backdrop-filter: none; z-index: 5; }
        .management-active .nav-btn { animation: wiggle 0.2s ease-in-out infinite alternate; pointer-events: auto !important; -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; }
        .management-active .nav-btn > .delete-icon { display: block; }
        @keyframes wiggle { from { transform: rotate(-0.5deg); } to { transform: rotate(0.5deg); } }
        .fab-container { position: fixed; right: 30px; bottom: 30px; z-index: 100; }
        .fab-main, .fab-drawer-item { position: relative; width: 50px; height: 50px; border-radius: 50%; border: none; cursor: pointer; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day); background: var(--bg-day-element); color: var(--text-day); font-size: 22px; display: flex; align-items: center; justify-content: center; user-select: none; -webkit-tap-highlight-color: transparent; }
        body.dark-mode .fab-main, body.dark-mode .fab-drawer-item { box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        .fab-main:active, .fab-drawer-item:active { transform: scale(0.95); }
        .fab-container.active .fab-main { transform: rotate(45deg); }
        .fab-drawer { position: absolute; bottom: 65px; left: 0; display: flex; flex-direction: column; gap: 15px; opacity: 0; transform: translateY(20px); transition: opacity 0.2s ease-out, transform 0.2s ease-out; pointer-events: none; }
        .fab-container.active .fab-drawer { opacity: 1; transform: translateY(0); pointer-events: auto; }
        #sync-status-indicator { position: absolute; right: 5px; top: 5px; width: 10px; height: 10px; border-radius: 50%; background-color: transparent; transition: all 0.3s ease; box-shadow: 0 0 5px rgba(0,0,0,0.2); }
        #sync-status-indicator.synced { background-color: #28a745; } #sync-status-indicator.syncing { background-color: #ffc107; animation: pulse 1.5s infinite; } #sync-status-indicator.error { background-color: #dc3545; animation: none; }
        @keyframes pulse { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.3); opacity: 0.7; } 100% { transform: scale(1); opacity: 1; } }
        .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);backdrop-filter:blur(5px);display:none;align-items:center;justify-content:center;z-index:1000;opacity:0;transition:opacity .3s ease}.modal-overlay.show{display:flex;opacity:1}.modal-content{width:90%;background:var(--bg-day-element);color:var(--text-day);border-radius:16px;box-shadow:12px 12px 24px var(--shadow-dark-day),-12px -12px 24px var(--shadow-light-day);padding:12px;transition:transform .3s ease,background .5s ease,box-shadow .5s ease;transform:scale(.95);display:flex;flex-direction:column;max-height:90vh}.modal-overlay.show .modal-content{transform:scale(1)}body.dark-mode .modal-content{background:var(--bg-night-element);color:var(--text-night);box-shadow:12px 12px 24px var(--shadow-dark-night),-12px -12px 24px var(--shadow-light-night)}.modal-header{display:flex;justify-content:space-between;align-items:center;font-size:20px;font-weight:600;margin-bottom:20px;flex-shrink:0; padding: 0 3px;}.modal-title-group{display:flex;align-items:center;gap:8px}.modal-header .close-btn,.modal-header .settings-btn{cursor:pointer;border:none;background:transparent;color:inherit;padding:5px;border-radius:50%;display:flex;align-items:center;justify-content:center;transition:background .2s ease}.modal-header .close-btn{font-size:24px;font-weight:bold;width:36px;height:36px}.modal-header .settings-btn{font-size:20px;width:32px;height:32px}.modal-header .close-btn:hover,.modal-header .settings-btn:hover{background:rgba(0,0,0,0.05)}body.dark-mode .modal-header .close-btn:hover,body.dark-mode .modal-header .settings-btn:hover{background:rgba(255,255,255,0.08)}
                .modal-body { overflow-y: auto; overflow-x: hidden; flex-grow: 1; display:flex; flex-direction:column; gap: 15px; margin-right: -5px; padding-right: 5px; scrollbar-width: none; -ms-overflow-style: none; -webkit-mask-image: linear-gradient(to bottom, black 95%, transparent 100%); mask-image: linear-gradient(to bottom, black 95%, transparent 100%); }


        .modal-body > * { margin-left: 3px; margin-right: 3px; width: calc(100% - 6px); }
        .modal-body::-webkit-scrollbar { width: 0; background: transparent; }
        .modal-input,.modal-select,.modal-textarea{padding:12px 15px;border:none;border-radius:10px;font-size:16px;background:var(--bg-day-element);color:var(--text-day);box-shadow:inset 4px 4px 8px var(--shadow-dark-day),inset -4px -4px 8px var(--shadow-light-day);transition:all .3s ease;caret-color:var(--hold-border)}body.dark-mode .modal-input,body.dark-mode .modal-select,body.dark-mode .modal-textarea{background:var(--bg-night-element);color:var(--text-night);box-shadow:inset 4px 4px 8px var(--shadow-dark-night),inset -4px -4px 8px var(--shadow-light-night)}.modal-input:focus,.modal-select:focus,.modal-textarea:focus{outline:none;box-shadow:inset 4px 4px 8px var(--shadow-dark-day),inset -4px -4px 8px var(--shadow-light-day),0 0 0 2px var(--hold-border)}body.dark-mode .modal-input:focus,body.dark-mode .modal-select:focus,body.dark-mode .modal-textarea:focus{box-shadow:inset 4px 4px 8px var(--shadow-dark-night),inset -4px -4px 8px var(--shadow-light-night),0 0 0 2px var(--hold-border)} .modal-textarea{resize:vertical;min-height:80px;}
        .modal-button{padding:14px;border:none;border-radius:12px;font-size:16px;font-weight:600;cursor:pointer;color:var(--hold-border);background:var(--bg-day-element);box-shadow:4px 4px 8px var(--shadow-dark-day),-4px -4px 8px var(--shadow-light-day);transition:all .2s ease}body.dark-mode .modal-button{color:var(--hold-border);background:var(--bg-night-element);box-shadow:4px 4px 8px var(--shadow-dark-night),-4px -4px 8px var(--shadow-light-night)}.modal-button:active{box-shadow:inset 4px 4px 8px var(--shadow-dark-day),inset -4px -4px 8px var(--shadow-light-day)}body.dark-mode .modal-button:active{box-shadow:inset 4px 4px 8px var(--shadow-dark-night),inset -4px -4px 8px var(--shadow-light-night)}.modal-button:disabled{color:#9db2c2;cursor:not-allowed;box-shadow:none;}
        #nukeDataBtn { background: #e53e3e !important; color: white !important; box-shadow: 4px 4px 8px rgba(229, 62, 62, 0.5), -4px -4px 8px rgba(255, 255, 255, 0.9) !important; }
        #nukeDataBtn:active { background: #c53030 !important; box-shadow: inset 4px 4px 8px rgba(155, 37, 37, 0.7) !important; }
        #settingsModal .modal-body .nuke-section { margin: 15px 0 10px; border-top: 1px solid rgba(128,128,128,0.3); padding-top: 15px; display: flex; justify-content: center; }
        #syncErrorModal .modal-content { max-width: 450px; } #sync-error-message { padding: 12px; border-radius: 8px; background: rgba(255, 0, 0, 0.1); border: 1px solid rgba(255, 0, 0, 0.2); font-family: monospace; font-size: 14px; word-wrap: break-word; user-select: text; } body.dark-mode #sync-error-message { background: rgba(252, 129, 129, 0.1); border-color: rgba(252, 129, 129, 0.2); }
        #colorPaletteModal .modal-content, #helpModal .modal-content { max-width: 500px; } 
        .theme-style-selector { border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 20px; margin-bottom: 20px; } body.dark-mode .theme-style-selector { border-color: rgba(255,255,255,0.1); }
        .theme-style-selector label { font-size: 14px; color: #5a6778; display: block; margin-bottom: 8px; } body.dark-mode .theme-style-selector label { color: #c0c6cc; }
        #pneumorphism-settings.hidden { display: none; }
        #colorPaletteModal .modal-body { gap: 20px; padding-bottom: 15px; }
        .color-picker-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; } .color-picker-group { display: flex; flex-direction: column; gap: 8px; }
        .color-picker-group label { font-size: 14px; color: #5a6778; } body.dark-mode .color-picker-group label { color: #c0c6cc; }
        .color-input-wrapper { display: flex; align-items: center; border-radius: 10px; padding: 5px; background:var(--bg-day-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); } body.dark-mode .color-input-wrapper { background:var(--bg-night-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        input[type="color"] { width: 36px; height: 30px; border: none; background: transparent; cursor: pointer; -webkit-appearance: none; padding: 0; flex-shrink: 0; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; } input[type="color"]::-webkit-color-swatch { border-radius: 6px; border: none; }
               .hex-display { 
            flex-grow: 0; /* 核心修改：禁止输入框拉伸 */
            flex-shrink: 0; /* 禁止输入框收缩 */
            width: 4.5em; /* 核心修改：设置一个刚好容纳7个字符的宽度 (em单位相对于字体大小) */
            text-align: center; /* 文本居中更美观 */
            padding: 0; /* 移除内部左右边距 */
            font-family: monospace; 
            font-size: 16px; 
            color: #889;
             /* 覆盖 .modal-input 带来的额外内边距 */
            padding-left: 5px !important;
            padding-right: 5px !important;
        }
        .color-input-wrapper { 
            display: flex; 
            align-items: center; 
            gap: 8px; /* 新增：在颜色面板和输入框之间设置一个固定的8px间距 */
            border-radius: 10px; 
            padding: 5px 8px; /* 优化：稍微减少容器的左右内边距 */
            background:var(--bg-day-element); 
            box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); 
        } 
        body.dark-mode .color-input-wrapper { 
            background:var(--bg-night-element); 
            box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); 
        }

        .preview-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; } .preview-box { height: 40px; border-radius: 8px; position: relative; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .preview-box::before { content: attr(data-label); } #dayPreview { border: 2px solid var(--bg-day-element); color: var(--text-day); } body.dark-mode #dayPreview { border-color: rgba(255,255,255,0.1); }
        #nightPreview { border: 2px solid var(--bg-night-element); color: var(--text-night); } body.dark-mode #nightPreview { border-color: rgba(255,255,255,0.2); }
        .preset-manager, .background-image-manager { border-top: 1px solid rgba(0,0,0,0.1); padding-top: 20px; display: flex; flex-direction: column; gap: 15px; }
        body.dark-mode .preset-manager, body.dark-mode .background-image-manager { border-color: rgba(255,255,255,0.1); } 
        .preset-row, .background-image-row { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            /* [新增] 核心修复：确保容器不会因为内容溢出而被撑开 */
            min-width: 0; 
        }
        
        /* [新增] 针对 preset-row 内部输入框的特殊处理 */
        .preset-row .modal-input {
            /* [新增] 确保输入框本身不会被内容无限撑大 */
            min-width: 0;
            /* [新增] 当文本溢出时，用省略号显示 */
            text-overflow: ellipsis;
            /* [新增] 防止文本换行，与 ellipsis 配合使用 */
            white-space: nowrap;
            overflow: hidden;
        }

        .preset-row .modal-input, .preset-row .modal-select { flex-grow: 1; }
        .preset-row .modal-button, .background-image-row .modal-button { width: auto; padding: 12px 15px; flex-shrink: 0; font-size: 14px; }
        .preset-row .modal-button.save { color: #28a745; } .preset-row .modal-button.delete, .background-image-row .modal-button.delete { color: #dc3545; }
        .background-image-row .status { flex-grow: 1; font-size: 12px; color: #889; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .toggle-section { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-radius: 12px; background:var(--bg-day-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); }
        body.dark-mode .toggle-section { background:var(--bg-night-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; } .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 22px; } .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--hold-border); } input:checked + .slider:before { transform: translateX(18px); }
        
        #projectSelector.hidden { display: none; }
        #settingsModal .modal-content,#addNavModal .modal-content, #musicSettingsModal .modal-content {max-width:400px}
        #settingsModal .modal-body .form-section,#addNavModal .modal-body .form-section{display:flex;flex-direction:column;gap:8px}#settingsModal label,#addNavModal label{font-size:14px;color:#5a6778}body.dark-mode #settingsModal label,body.dark-mode #addNavModal label{color:#c0c6cc}
        .segmented-control { position: relative; display: flex; border-radius: 12px; padding: 5px; background:var(--bg-day-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); }
        body.dark-mode .segmented-control { background:var(--bg-night-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        .segmented-control label { position: relative; z-index: 1; flex: 1; text-align: center; padding: 10px; border-radius: 8px; cursor: pointer; transition: color .3s ease; font-weight: 600; }
        .segmented-control .slider-indicator { position: absolute; top: 5px; left: 5px; bottom: 5px; background: var(--bg-day-element); box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day); border-radius: 8px; transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); z-index: 0; }
        body.dark-mode .segmented-control .slider-indicator { background: var(--bg-night-element); box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night); }
        #addNavModal input[type="radio"]:checked + label, #helpModal input[type="radio"]:checked + label, #colorPaletteModal input[type="radio"]:checked + label { color: var(--hold-border); }
        #type-upload:checked ~ .slider-indicator { transform: translateX(100%); }
        #theme-style-glass:checked ~ .slider-indicator { transform: translateX(100%); }
        .segmented-control.two-segments .slider-indicator { width: calc(50% - 5px); }
        .segmented-control.three-segments .slider-indicator { width: calc(33.33% - 4px); }
        #addNavModal .status-text{text-align:center;font-size:14px;color:#889;min-height:20px} #addNavModal .modal-header { gap: 10px; } #addNavModal .modal-title-group { flex-grow: 1; }
        .header-toggle-group { display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: normal; color: #5a6778; } body.dark-mode .header-toggle-group { color: #c0c6cc; }
        .file-select-wrapper { display: flex; align-items: center; gap: 10px; width: 100%; } .file-select-wrapper .modal-button { flex-shrink: 0; width: auto; padding: 10px 15px; font-size: 14px; }
        .file-select-wrapper .status-text { flex-grow: 1; font-size: 14px; color: #889; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .file-upload-section { display: flex; flex-direction: column; gap: 10px; flex-shrink: 0; } input[type="file"] { display: none; }
.progress-container { 
    display: none; /* 初始隐藏 */
    align-items: center; 
    gap: 10px; /* 进度条和按钮的间距 */
    height: 36px; /* 增加容器高度以容纳按钮 */
} 
.progress-bar-wrapper {
    flex-grow: 1; /* 让进度条容器占据大部分空间 */
    height: 12px; 
    background: var(--bg-day-element); 
    border-radius: 6px; 
    box-shadow: inset 2px 2px 4px var(--shadow-dark-day), inset -2px -2px 4px var(--shadow-light-day); 
    padding: 2px;
}
body.dark-mode .progress-bar-wrapper { 
    box-shadow: inset 2px 2px 4px var(--shadow-dark-night), inset -2px -2px 4px var(--shadow-light-night); 
}
.progress-bar { 
    width: 0%; 
    height: 100%; 
    border-radius: 4px; 
    background-color: var(--hold-border); /* 使用主题高亮色 */ 
    transition: width 0.2s linear; 
}
#upload-cancel-btn {
    flex-shrink: 0; /* 防止按钮被压缩 */
    background: transparent;
    border: none;
    font-size: 20px;
    color: #aaa;
    cursor: pointer;
    padding: 5px;
    line-height: 1;
    transition: color 0.2s;
}
#upload-cancel-btn:hover {
    color: #e53e3e;
}

        #helpModal .modal-body { gap: 0; padding-top: 15px; } #helpModal .modal-body > input[name="help-tab"] { display: none; } 
      .help-page-content { display: none; padding: 15px 5px 40px 5px; overflow-x: hidden; } /* 修改点：底部内边距调整为 40px */


        .help-page-content h3 { font-size: 1.3em; margin: 20px 0 10px 0; padding-bottom: 5px; border-bottom: 1px solid rgba(128,128,128,0.3); } .help-page-content h4 { font-size: 1.1em; margin: 18px 0 8px 0; }
        .help-page-content p, .help-page-content li, .help-page-content a { line-height: 1.7; color: #4a5568; margin-bottom: 8px; word-wrap: break-word; }
        body.dark-mode .help-page-content p, body.dark-mode .help-page-content li, body.dark-mode .help-page-content a { color: #a0aec0; }
        .help-page-content ul, .help-page-content ol { padding-left: 25px; } .help-page-content ol li { margin-bottom: 12px; }
        .help-page-content strong { color: var(--hold-border); font-weight: 600; } .help-page-content code { background-color: rgba(128,128,128,0.15); padding: 2px 5px; border-radius: 4px; font-family: monospace; word-wrap: break-word; }
        .help-page-content a { color: var(--hold-border); text-decoration: none; font-weight: 600; } .help-page-content a:hover { text-decoration: underline; }
        .help-page-content .warning { background-color: rgba(229, 62, 62, 0.1); border-left: 4px solid #e53e3e; padding: 10px 15px; margin: 15px 0; border-radius: 0 8px 8px 0; }
        .help-page-content .important-note { background-color: rgba(91, 153, 226, 0.1); border-left: 4px solid var(--hold-border); padding: 10px 15px; margin: 15px 0; border-radius: 0 8px 8px 0; }
        /* == Iframe Modal & Confirmation Toast Styles == */
        .iframe-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000; transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        .iframe-modal-overlay.active { transform: translateX(0); }
        .iframe-modal-content { width: 100%; height: 100%; background: #fff; box-shadow: -5px 0 15px rgba(0,0,0,0.2); transition: transform 0.3s ease-out; }
        .iframe-modal-content.dragging { transition: none; }
        .iframe-modal-content iframe { width: 100%; height: 100%; border: none; }
        .swipe-hint { position: fixed; left: 0; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; background: rgba(0,0,0,0.6); color: white; padding: 15px 8px; border-radius: 0 8px 8px 0; z-index: 2001; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
        .swipe-hint.show { opacity: 1; }
        .swipe-hint .arrow { width: 16px; height: 16px; border-right: 3px solid white; border-bottom: 3px solid white; transform: rotate(-45deg); animation: hint-pulse 1.5s infinite; margin-bottom: 10px; }
        .swipe-hint span { writing-mode: vertical-rl; }
        @keyframes hint-pulse { 0% { opacity: 0.3; } 50% { opacity: 1; transform: rotate(-45deg) scale(1.1); } 100% { opacity: 0.3; } }
        #gestureCaptureZone { position: fixed; top: 50%; left: 0; width: 20px; height: 200px; transform: translateY(-50%); z-index: 2002; } /* REFINED: Gesture Area */
        #returnConfirmationToast { position: fixed; top: 0; left: 50%; transform: translate(-50%, -120%); width: calc(100% - 30px); max-width: 400px; background: var(--bg-night-element); color: var(--text-night); padding: 12px 16px; border-radius: 0 0 12px 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 2003; display: flex; justify-content: space-between; align-items: center; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); user-select: none; }
        #returnConfirmationToast.show { transform: translate(-50%, 0); }
        .toast-btn { background: transparent; border: none; color: white; font-size: 15px; font-weight: 600; padding: 8px 12px; border-radius: 8px; cursor: pointer; transition: background 0.2s; }
        .toast-btn-confirm { background-color: rgba(99, 179, 237, 0.8); } .toast-btn-confirm:hover { background-color: rgba(99, 179, 237, 1); }
        .toast-btn-cancel { background-color: rgba(255, 255, 255, 0.2); } .toast-btn-cancel:hover { background-color: rgba(255, 255, 255, 0.3); }
        @media (max-width: 480px) { .editable-title { font-size: 28px; } .editable-subtitle { font-size: 14px; } .title-card { padding: 30px 15px; } .nav-container { grid-template-columns: 1fr 1fr; gap: 18px; padding: 10px; } .nav-btn { padding: 18px 10px; font-size: 15px; } .fab-container { right: 20px; bottom: 20px; } .fab-main, .fab-drawer-item { width: 44px; height: 44px; font-size: 20px; } .fab-drawer { bottom: 55px; } .segmented-control label { font-size: 13px; padding: 8px 5px; } .category-nav { padding: 0 15px; } }
        
        /* ===== [START] MEMORY MODAL STYLES ===== */
        #memoryModal .modal-content { max-width: 800px; height: calc(100vh - 40px); padding: 0; display: flex; flex-direction: column; overflow: hidden; }
        #memoryModal .modal-header { padding: 0 15px; margin-top: 15px; margin-bottom: 10px; }
        #memoryModal .app-container { width: 100%; flex-grow: 1; display: flex; flex-direction: column; position: relative; overflow: hidden; }
        #memoryModal .page { width: 100%; height: 100%; display: none; flex-direction: column; position: absolute; top: 0; left: 0; opacity: 0; transform: scale(0.98); transition: opacity 0.3s ease, transform 0.3s ease; pointer-events: none; }
        #memoryModal .page.active { display: flex; opacity: 1; transform: scale(1); pointer-events: auto; z-index: 10; }
        #memoryModal .page-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; flex-shrink: 0; position: relative; }
        #memoryModal .page-header .title { position: absolute; left: 50%; transform: translateX(-50%); font-size: 20px; font-weight: 700; white-space: nowrap; }
        #memoryModal .header-btn { font-size: 16px; font-weight: 600; cursor: pointer; padding: 8px 12px; border-radius: 10px; transition: background-color 0.2s; border: none; background: transparent; color: inherit; z-index: 5; }
        #memoryModal .header-btn:hover { background-color: rgba(0,0,0,0.05); } body.dark-mode #memoryModal .header-btn:hover { background-color: rgba(255,255,255,0.1); }
        #memoryModal .header-btn.back-btn { font-size: 24px; padding: 5px 10px; }
        #memoryModal .header-btn.manage-btn { color: var(--hold-border); }
        #memoryModal .header-btn.wander-btn { font-size: 20px; padding: 6px; }
        #memoryModal .header-controls { display: flex; gap: 8px; align-items:center; }
.memo-search-input {
    display: none;
    flex-grow: 1;
    border: none;
    background: transparent;
    font-size: 16px;
    padding: 8px 12px;
    margin: 0 10px;
    color: inherit;
    outline: none;
    border-bottom: 2px solid var(--hold-border);
    min-width: 0; /* [核心新增] 允许输入框在Flex布局中被压缩，防止溢出 */
}

/* [新增] 微调搜索按钮内的SVG图标，使其垂直居中 */
#memoryModal .header-btn svg {
    transform: translateY(3px);
}

#memoryModal .list-container { flex-grow: 1; overflow-y: auto; padding: 0 15px 80px 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 20px; align-content: flex-start; min-height: 0; /* [核心修复] 允许Flex容器在内容溢出时正确收缩 */ }
        #memoryModal #hub-view-content { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 30px; }
        #memoryModal .hub-btn { width: 80%; max-width: 300px; padding: 40px 20px; border: none; border-radius: 20px; box-shadow: 10px 10px 20px var(--shadow-dark-day), -10px -10px 20px var(--shadow-light-day); background: var(--bg-day-element); color: var(--text-day); font-size: 24px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        body.dark-mode #memoryModal .hub-btn { box-shadow: 10px 10px 20px var(--shadow-dark-night), -10px -10px 20px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        #memoryModal .hub-btn:active { box-shadow: inset 6px 6px 12px var(--shadow-dark-day), inset -6px -6px 12px var(--shadow-light-day); } body.dark-mode #memoryModal .hub-btn:active { box-shadow: inset 6px 6px 12px var(--shadow-dark-night), inset -6px -6px 12px var(--shadow-light-night); }
        #memoryModal #notes-list-container { grid-template-columns: 1fr; }
        #memoryModal .folder-item, #memoryModal .album-item { margin-bottom: 10px; position: relative; padding: 20px 15px; border: none; border-radius: 14px; box-shadow: 8px 8px 16px var(--shadow-dark-day), -8px -8px 16px var(--shadow-light-day); background: var(--bg-day-element); font-size: 16px; font-weight: 600; color: var(--text-day); cursor: pointer; transition: all 0.3s ease; user-select: none; -webkit-tap-highlight-color: transparent; text-align: left; }
#memoryModal .note-item { position: relative; padding: 20px 15px; border: none; border-radius: 14px; box-shadow: 8px 8px 16px var(--shadow-dark-day), -8px -8px 16px var(--shadow-light-day); background: var(--bg-day-element); font-size: 16px; color: var(--text-day); cursor: pointer; transition: all 0.3s ease; user-select: none; -webkit-tap-highlight-color: transparent; text-align: left; min-width: 0; /* <<< [核心修复] 新增此行 */ }
        body.dark-mode #memoryModal .folder-item, body.dark-mode #memoryModal .note-item, body.dark-mode #memoryModal .album-item { box-shadow: 8px 8px 16px var(--shadow-dark-night), -8px -8px 16px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        #memoryModal .folder-item:active, #memoryModal .note-item:active, #memoryModal .album-item:active { box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); transform: translateY(0); }
        body.dark-mode #memoryModal .folder-item:active, body.dark-mode #memoryModal .note-item:active, body.dark-mode #memoryModal .album-item:active { box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        #memoryModal .folder-icon { font-size: 24px; margin-bottom: 10px; }
#memoryModal .note-title { font-size: 18px; font-weight: bold; margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; /* [优化] 移除无效的 word-break: break-all; */ }
        #memoryModal .note-preview { font-size: 14px; font-weight: normal; color: #6a7889; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; word-break: break-all; }
        body.dark-mode #memoryModal .note-preview { color: #a0aec0; }
        #memoryModal .note-timestamp { font-size: 12px; font-weight: 300; color: #9A86A4; margin-top: 12px; }
        #memoryModal .album-item { aspect-ratio: 1 / 1; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-start; }
        #memoryModal .album-item .folder-icon { font-size: 32px; }
        #memoryModal .album-info { font-size: 12px; color: #889; margin-top: 6px; /* 新增此行 */ }

#memoryModal #photo-list-container {
    display: flex;          /* 1. 声明为 Flexbox 弹性布局 */
    flex-wrap: wrap;        /* 2. 允许项目自动换行 */
    justify-content: flex-start; /* 3. 核心：实现从左到右排列 */
    min-height: 0;
    gap: 10px;              /* 4. 使用 gap 属性创建统一的 10px 间隙 */
}

        #memoryModal .photo-item, .photo-item-set {
    /* 核心：计算项目宽度，减去 gap 的空间，实现每行完美的3列 */
    width: calc(33.333% - 6.7px); 
    
    /* 你可以调整这里的百分比和减去的值来改变列数，例如 4 列：
       width: calc(25% - 7.5px);
       5 列：
       width: calc(20% - 8px);
    */
    
    aspect-ratio: 1 / 1;
    position: relative;
    overflow: hidden;
    border-radius: 25px;
    background-color: var(--item-bg-color);
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    
    /* 删除了所有旧的 display, vertical-align, width, margin 属性 */
}


        #memoryModal .photo-item img, #memoryModal .photo-item video, #memoryModal .photo-item-set img, #memoryModal .photo-item-set video { width: 100%; height: 100%; object-fit: cover; transition: transform 0.3s ease; }
        .photo-item-set .photo-stack-img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 12px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); transition: transform 0.3s ease; border: 2px solid var(--bg-day-element); }
        body.dark-mode .photo-item-set .photo-stack-img { border-color: var(--bg-night-element); }
        .photo-item-set .photo-stack-img:nth-child(1) { transform: translate(6px, 6px); z-index: 1; }
        .photo-item-set .photo-stack-img:nth-child(2) { transform: translate(3px, 3px); z-index: 2; }
        .photo-item-set .photo-stack-img:nth-child(3) { transform: translate(0, 0); z-index: 3; }
        .photo-item-set:hover .photo-stack-img:nth-child(1) { transform: translate(10px, 10px); }
        .photo-item-set:hover .photo-stack-img:nth-child(2) { transform: translate(5px, 5px); }
        #memoryModal .photo-title-overlay { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.6), transparent); color: white; font-size: 12px; padding: 12px 8px 4px 8px; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; z-index: 5; }
        .photo-item-set .count-overlay { position: absolute; bottom: 5px; right: 8px; background: rgba(0,0,0,0.5); color: white; padding: 2px 6px; font-size: 10px; font-weight: bold; border-radius: 4px; z-index: 5; }
        #memoryPhotoViewerOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 5000; display: flex; flex-direction: column; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        #memoryPhotoViewerOverlay.active { opacity: 1; pointer-events: auto; }
        #memoryPhotoViewerOverlay .viewer-header { flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; padding: 20px; color: white; background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent); z-index: 10;}
        #memoryPhotoViewerOverlay .viewer-header .counter { font-size: 16px; font-weight: bold; }
        #memoryPhotoViewerOverlay .viewer-btn { background: rgba(40,40,40,0.5); border: none; color: white; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; transition: background-color 0.2s; }
        #memoryPhotoViewerOverlay .viewer-btn:hover { background: rgba(60,60,60,0.7); }
        #memoryPhotoViewerOverlay .viewer-content { flex-grow: 1; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; }
        #viewer-img-container { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: padding 0.3s ease; }
        #memoryPhotoViewerOverlay #viewer-img { max-width: 100%; max-height: 100%; object-fit: contain; }
        #memoryPhotoViewerOverlay .nav-arrow { position: absolute; top: 50%; transform: translateY(-50%); width: 44px; height: 44px; font-size: 24px; opacity: 0.6; display: flex; align-items: center; justify-content: center; }
        #memoryPhotoViewerOverlay .nav-arrow:hover { opacity: 1; }
        #prev-photo-btn { left: 15px; } #next-photo-btn { right: 15px; }
        #memoryPhotoViewerOverlay .viewer-footer { flex-shrink: 0; padding: 20px; color: white; text-align: center; background: linear-gradient(to top, rgba(0,0,0,0.5), transparent); z-index: 10;}
        #viewer-title { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        #viewer-description { font-size: 14px; margin-bottom: 8px; }
        #viewer-timestamp { font-size: 12px; color: #ccc; }
        #memoryModal .empty-list-placeholder { grid-column: 1 / -1; text-align: center; color: #889; margin-top: 50px; }
        #memoryModal .fab { position: absolute; right: 25px; bottom: 25px; width: 50px; height: 50px; border-radius: 50%; border: none; cursor: pointer; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day); background: var(--bg-day-element); color: var(--text-day); font-size: 28px; display: flex; align-items: center; justify-content: center; user-select: none; z-index: 100; }
        body.dark-mode #memoryModal .fab { box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night); background: var(--bg-night-element); color: var(--text-night); }
        #memoryModal .fab:active { transform: scale(0.95); }
        #memoryModal #note-editor-view { background: var(--bg-day-element); z-index: 200; padding: 10px; transform: translateY(100%); }
        body.dark-mode #memoryModal #note-editor-view { background: var(--bg-night-element); }
        body.theme-glass #memoryModal #note-editor-view, body.theme-glass.dark-mode #memoryModal #note-editor-view { background: transparent; }
        #memoryModal #note-editor-view.active { transform: translateY(0); }
        #memoryModal .editor-header{display:flex;justify-content:space-between;align-items:center;padding:10px 5px;flex-shrink:0}
        #memoryModal .editor-btn{padding:10px 18px;border:none;border-radius:12px;font-size:16px;font-weight:600;cursor:pointer;color:var(--hold-border);background:var(--bg-day-element);box-shadow:4px 4px 8px var(--shadow-dark-day),-4px -4px 8px var(--shadow-light-day);transition:all .2s ease}body.dark-mode #memoryModal .editor-btn{color:var(--hold-border);background:var(--bg-night-element);box-shadow:4px 4px 8px var(--shadow-dark-night),-4px -4px 8px var(--shadow-light-night)}
        #memoryModal .editor-btn:active{box-shadow:inset 4px 4px 8px var(--shadow-dark-day),inset -4px -4px 8px var(--shadow-light-day)}body.dark-mode #memoryModal .editor-btn:active{box-shadow:inset 4px 4px 8px var(--shadow-dark-night),inset -4px -4px 8px var(--shadow-light-night)}
        #memoryModal #delete-note-btn{color:#f56565}
        #memoryModal .editor-content{flex-grow:1;display:flex;flex-direction:column;gap:10px;padding:10px 5px; overflow-y: auto; min-height: 0;}
        #memoryModal #note-title-input,#memoryModal #note-content-textarea{width:100%;border:none;background:transparent;color:inherit;font-size:18px;padding:10px}
        #memoryModal #note-title-input{font-size:24px;font-weight:bold;flex-shrink:0}
       #memoryModal #note-content-textarea{resize:none;line-height:1.6}
        #memoryModal #note-title-input:focus,#memoryModal #note-content-textarea:focus{outline:none}
        #memoryFolderModal .modal-content, #memoryPhotoDetailsModal .modal-content { max-width: 400px; }
        #memoryPhotoDetailsModal #upload-thumbnail { max-width: 100px; max-height: 100px; border-radius: 8px; margin: 10px auto; object-fit: cover; }
        #memoryPhotoDetailsModal #photoset-toggle-container { display: none; padding: 10px; border-bottom: 1px solid rgba(128,128,128,0.2); }
        #memoryPhotoDetailsModal .modal-footer { display:flex; justify-content:flex-end; gap:10px; margin-top:20px; }
        #memoryPhotoDetailsModal .modal-button.primary { color: var(--hold-border); }
        #memoryModal .pin-btn { position: absolute; top: 10px; right: 10px; background: transparent; border: none; font-size: 13px; font-weight: 600; cursor: pointer; opacity: 0.3; transition: opacity 0.2s, transform 0.2s; z-index: 5; border-radius: 4px; padding: 2px 5px; }
        #memoryModal .note-item.pinned .pin-btn { opacity: 1; color: var(--hold-border); }
        #memoryModal .pin-btn:hover { transform: scale(1.2); }
        .management-controls { display: none; position: absolute; bottom: 0; left: 0; right: 0; padding: 15px; background: var(--bg-day-element); box-shadow: 0 -4px 12px rgba(0,0,0,0.1); z-index: 101; flex-direction: row; justify-content: space-between; gap: 10px; border-radius: 16px 16px 0 0;}
        body.dark-mode .management-controls { background: var(--bg-night-element); }
        .management-controls.active { display: flex; }
        .management-controls .modal-button { flex-grow: 1; margin: 0; padding: 12px; }
.folder-item.manage-mode, .album-item.manage-mode, .photo-item.manage-mode, .photo-item-set.manage-mode, .note-item.manage-mode { cursor: pointer; }
.folder-item .manage-checkbox, .album-item .manage-checkbox, .photo-item .manage-checkbox, .photo-item-set .manage-checkbox, .note-item .manage-checkbox { display: none; position: absolute; top: 10px; left: 10px; width: 22px; height: 22px; z-index: 5; }
.folder-item.manage-mode .manage-checkbox, .album-item.manage-mode .manage-checkbox, .photo-item.manage-mode .manage-checkbox, .photo-item-set.manage-mode .manage-checkbox, .note-item.manage-mode .manage-checkbox { display: block; }
.folder-item.manage-selected, .album-item.manage-selected, .photo-item.manage-selected, .photo-item-set.manage-selected, .note-item.manage-selected { border: 2px solid var(--hold-border); box-shadow: 0 0 0 2px var(--hold-border), 8px 8px 16px var(--shadow-dark-day), -8px -8px 16px var(--shadow-light-day) !important; }
body.dark-mode .folder-item.manage-selected, body.dark-mode .album-item.manage-selected, body.dark-mode .photo-item.manage-selected, body.dark-mode .photo-item-set.manage-selected, body.dark-mode .note-item.manage-selected { box-shadow: 0 0 0 2px var(--hold-border), 8px 8px 16px var(--shadow-dark-night), -8px -8px 16px var(--shadow-light-night) !important; }
        #cloud-drive-section .list-container { display: flex; flex-direction: column; gap: 15px; padding: 15px; overflow-y: hidden; min-height: 0; }
        #file-list-container { flex-shrink: 1; flex-grow: 1; min-height: 100px; overflow-y: auto; border-radius: 10px; padding: 5px; background:var(--bg-day-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); display: flex; flex-direction: column; }
        body.dark-mode #file-list-container { background:var(--bg-night-element); box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        #file-list-container ul { list-style:none; padding: 5px; }
        #file-list-container li { padding: 8px 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; transition: background .2s; gap: 10px; position: relative; }
        #file-list-container li:hover { background-color: rgba(0,0,0,0.05); } body.dark-mode #file-list-container li:hover { background-color:rgba(255,255,255,0.08); }
        #fileListStatus { flex-grow: 1; text-align: center; color: #a0aec0; display: flex; align-items: center; justify-content: center; min-height: 50px; } body.dark-mode #fileListStatus { color:#889; }
        .file-info { flex-grow: 1; cursor: pointer; min-width: 0; }
        .file-name { display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 16px; }
                .file-meta { 
            font-size: 12px; 
            font-weight: 300; 
            color: #9A86A4; 
            flex-shrink: 0; /* [新增] 防止此元素在flex布局中被过度压缩 */
            margin-left: 10px; /* [新增] 与文件名保持一点间距 */
            white-space: nowrap; /* [新增] 确保大小和日期不换行 */
        }
        .delete-btn { background:transparent; border:none; cursor:pointer; padding:0; flex-shrink:0; width:28px; height:28px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:background .2s,color .2s; color:#bbb; font-size:22px; font-weight:bold; line-height:1; }
        .delete-btn:hover { background:#f0f0f0; color:#e53e3e; } body.dark-mode .delete-btn { color:#889; } body.dark-mode .delete-btn:hover { background:rgba(255,255,255,0.1); color:#fc8181; }

        /* ===== [END] MEMORY MODAL STYLES ===== */
        
        /* ===== [START] WANDER VIEW 4.0 STYLES (Architecture) ===== */
        @keyframes breathing-glow {
            0% { box-shadow: 0 0 8px 1px var(--handle-color); }
            50% { box-shadow: 0 0 16px 4px var(--handle-color); }
            100% { box-shadow: 0 0 8px 1px var(--handle-color); }
        }
        #wanderViewOverlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 6000; background: var(--bg-day-element); color: var(--text-day); display: none; flex-direction: column; opacity: 0; transition: opacity 0.4s ease; }
        body.dark-mode #wanderViewOverlay { background: var(--bg-night-element); color: var(--text-night); }
        #wanderViewOverlay.active { display: flex; opacity: 1; }
        .wander-header { display: flex; justify-content: flex-end; padding: 5px; flex-shrink: 0; position: absolute; top: 0; right: 0; z-index: 10001; }
        .wander-header .close-btn { font-size: 24px; font-weight: bold; width: 36px; height: 36px; cursor: pointer; border: none; background: transparent; color: inherit; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background .2s ease; }
        .wander-header .close-btn:hover { background: rgba(0,0,0,0.05); } body.dark-mode .wander-header .close-btn:hover { background: rgba(255,255,255,0.08); }
        .wander-main-content { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 10px 20px; overflow: hidden; min-height: 0; transition: transform 0.4s ease; }
        .wander-photo-container { position: relative; width: 100%; max-width: 500px; aspect-ratio: 0.85; display: flex; align-items: center; justify-content: center; transition: all 0.4s ease; margin: auto 0;
            background: white; box-shadow: 0 10px 25px rgba(0,0,0,0.1); border-radius: 4px; padding: 15px 15px 80px 15px;
        }
        #wander-img { cursor: pointer; width:100%; height:100%; object-fit: cover; }
        .wander-info-container { position: absolute; bottom: 15px; left: 15px; right: 15px; text-align: center; }
        #wander-title { font-size: 18px; font-weight: 700; margin-bottom: 5px; color: #333; }
        #wander-description { font-size: 14px; color: #777; line-height: 1.5; }
        .wander-photo-container.fullscreen { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; max-width: none; z-index: 10000; padding: 0; background: transparent; box-shadow: none; border-radius: 0; }
        .wander-photo-container.fullscreen::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: var(--blur-bg); background-size: cover; background-position: center; filter: blur(20px); transform: scale(1.1); opacity: 0.8; z-index: -1; }
        .wander-photo-container.fullscreen #wander-img { padding: 0; background: transparent; box-shadow: none; border-radius: 0; width: 100%; height: 100%; object-fit: contain; }
        .wander-photo-container.fullscreen .wander-info-container { display: none; }
        .wander-music-player { position: relative; flex-shrink: 0; width: calc(100% - 20px); max-width: 400px; margin: 0 auto 15px auto; z-index: 15; transition: transform 0.4s ease; }
        .wander-music-player.hidden { display: none; }
        .player-handle-container { padding: 10px 0 5px; cursor: pointer; }
        .player-handle { width: 40px; height: 5px; border-radius: 2.5px; background: #ccc; margin: 0 auto; } body.dark-mode .player-handle { background: #555; }
        .wander-music-player.collapsed { transform: translateY(calc(100% - 30px)); }
        .wander-music-player.collapsed .player-content { box-shadow: none; background: transparent; }
        .wander-music-player.collapsed > *:not(.player-handle-container) { display: none; }
        .player-content { padding: 15px; border-radius: 24px; background: var(--bg-day-element); box-shadow: 8px 8px 16px var(--shadow-dark-day), -8px -8px 16px var(--shadow-light-day); }
        body.dark-mode .player-content { background: var(--bg-night-element); box-shadow: 8px 8px 16px var(--shadow-dark-night), -8px -8px 16px var(--shadow-light-night); }
        .player-controls { display: flex; justify-content: space-between; align-items: center; gap: 5px; margin-top: 10px; }
        .player-btn { width: 44px; height: 44px; border-radius: 50%; border: none; background: var(--bg-day-element); box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day); color: var(--text-day); font-size: 18px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .player-btn svg { width: 1em; height: 1em; fill: currentColor; }
        body.dark-mode .player-btn { background: var(--bg-night-element); box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night); color: var(--text-night); }
        .player-btn:active { box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day); }
        body.dark-mode .player-btn:active { box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night); }
        .player-btn#play-pause-btn { width: 52px; height: 52px; font-size: 22px; }
        .player-display { margin: 10px 0; height: 1.5em; text-align: center; font-size: 14px; overflow: hidden; display: flex; flex-direction: column; justify-content: center; position: relative; }
        .song-title-display { display: flex; align-items: center; justify-content: center; height: 100%; font-weight: 600; }
        #lyrics-container { position: absolute; width: 100%; height: 1.5em; top: 0; left: 0; overflow: hidden; }
        #lyrics-ul { list-style: none; transition: transform 0.5s ease; padding: 0; margin: 0;}
        #lyrics-ul li { line-height: 1.5em; opacity: 0.5; transition: opacity 0.5s ease; }
        #lyrics-ul li.current-lyric { opacity: 1; font-weight: bold; }
        .player-progress-track { position: relative; height: 16px; margin: 10px 0 0 0; cursor: pointer; --handle-color: var(--handle-color-day); }
        body.dark-mode .player-progress-track { --handle-color: var(--handle-color-night); }
        .player-progress-bar-bg { position: absolute; top: 50%; transform: translateY(-50%); left:0; right: 0; height: 3px; background-color: rgba(128,128,128,0.2); border-radius: 1.5px; }
        #player-progress-bar { position: absolute; top: 50%; transform: translateY(-50%); left:0; height: 3px; background-color: var(--handle-color); border-radius: 1.5px; width: 0; }
        #player-progress-handle { position: absolute; top: 50%; left: 0; width: 14px; height: 14px; transform: translate(-50%, -50%); background-color: var(--handle-color); border-radius: 50%; box-shadow: 0 0 8px 1px var(--handle-color); transition: box-shadow 0.3s ease; }
        #player-progress-handle.playing { animation: breathing-glow 2s ease-in-out infinite; }
        .player-progress-track:hover #player-progress-handle { box-shadow: 0 0 12px 3px var(--handle-color); }
        .player-popover { display: none; position: absolute; bottom: calc(100% + 10px); left: 15px; width: 250px; background: var(--bg-day-element); border-radius: 12px; box-shadow: 0 -5px 20px rgba(0,0,0,0.1); padding: 10px; border: 1px solid rgba(0,0,0,0.05); z-index: 20; }
        .player-popover.active { display: block; }
        body.dark-mode .player-popover { background: var(--bg-night-element); border-color: rgba(255,255,255,0.1); }
        .player-popover .popover-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 0 5px; }
        .player-popover h4 { font-size: 16px; flex-grow: 1; }
        .player-popover .settings-btn { width: 32px; height: 32px; font-size: 20px; flex-shrink: 0; }
        .player-popover ul { list-style: none; max-height: 150px; overflow-y: auto; padding: 0; }
        .player-popover li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; }
        .player-popover li:hover { background: rgba(0,0,0,0.05); } body.dark-mode .player-popover li:hover { background: rgba(255,255,255,0.08); }
        .player-popover li.playing { color: var(--hold-border); font-weight: bold; }
        .player-popover .playlist-item-name { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #musicSettingsModal.modal-overlay { z-index: 15000; }
        #musicSettingsModal .modal-body { gap: 20px; }
        .music-upload-section, .music-playlist-section { border-top: 1px solid rgba(0,0,0,0.1); padding-top: 20px; display: flex; flex-direction: column; gap: 15px; }
        .music-upload-section .confirm-upload-wrapper { display: flex; justify-content: center; padding-top: 5px; }
        body.dark-mode .music-upload-section, body.dark-mode .music-playlist-section { border-color: rgba(255,255,255,0.1); }
        #music-playlist-container { max-height: 200px; overflow-y: auto; list-style: none; padding: 0; margin: 0; }
        #music-playlist-container li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-radius: 6px; }
        #music-playlist-container li:hover { background: rgba(0,0,0,0.05); } body.dark-mode #music-playlist-container li:hover { background: rgba(255,255,255,0.08); }
        #music-playlist-container li.playing { color: var(--hold-border); font-weight: bold; }
        #music-playlist-container .song-name { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; }
        #music-playlist-container .delete-song-btn { width: 28px; height: 28px; color: #aaa; } #music-playlist-container .delete-song-btn:hover { color: #f56565; background: rgba(229, 62, 62, 0.1); }
        .music-loader{width:1.2em;height:1.2em;border:2px solid rgba(128,128,128,0.3);border-top-color:var(--hold-border);border-radius:50%;animation:spin 1s linear infinite;margin:0 auto}
        @keyframes spin{to{transform:rotate(360deg)}}
        /* ===== [END] WANDER VIEW STYLES ===== */
        
        /* ===== [START] HELP MODAL UPDATE STYLES ===== */
        .segmented-control.four-segments .slider-indicator { width: calc(25% - 4px); }
        #help-tab-0:checked ~ .segmented-control .slider-indicator { transform: translateX(0%); }
        #help-tab-1:checked ~ .segmented-control .slider-indicator { transform: translateX(100%); }
        #help-tab-2:checked ~ .segmented-control .slider-indicator { transform: translateX(200%); }
        #help-tab-3:checked ~ .segmented-control .slider-indicator { transform: translateX(300%); }

        #help-tab-0:checked ~ .help-content-wrapper > #help-page-0,
        #help-tab-1:checked ~ .help-content-wrapper > #help-page-1,
        #help-tab-2:checked ~ .help-content-wrapper > #help-page-2,
        #help-tab-3:checked ~ .help-content-wrapper > #help-page-3 { display: block; }
        
        details { border: 1px solid rgba(128,128,128,0.2); border-radius: 8px; margin-bottom: 12px; }
        summary { cursor: pointer; padding: 12px 15px; font-weight: bold; font-size: 1.1em; list-style: none; }
        summary::-webkit-details-marker { display: none; }
        summary::before { content: '▶'; margin-right: 8px; display: inline-block; transition: transform 0.2s; }
        details[open] > summary::before { transform: rotate(90deg); }
        .details-content { padding: 0 15px 15px 15px; border-top: 1px solid rgba(128,128,128,0.2); }
        .details-content p, .details-content ul, .details-content div { margin-top: 10px; }
        .details-content ul { padding-left: 20px; }
        .details-content .sub-note { font-size: 0.9em; color: #889; }

        .update-header-info {
            padding: 10px 15px;
            background-color: rgba(128,128,128,0.1);
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 14px;
        }
        .update-header-info p { margin: 5px 0; color: inherit; }
        .update-log-entry {
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(128,128,128,0.2);
        }
        .update-log-entry:last-of-type { border-bottom: none; }
        .update-log-entry h4 { font-size: 1.2em; margin: 0 0 10px 0; }
        .update-date { font-size: 0.8em; font-weight: normal; color: #889; }
        .update-log-entry ul { list-style: none; padding-left: 5px; }
        .update-log-entry li { margin-bottom: 8px; display: flex; align-items: flex-start; }
        .tag {
            flex-shrink: 0;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 10px;
            color: white;
        }
        .tag.new { background-color: #769fcd; } /* Morandi Blue */
        .tag.fix { background-color: #93b5b3; } /* Morandi Green */
        .tag.opt { background-color: #d1a787; } /* Morandi Orange/Brown */
        .tag.release { background-color: #b091a2; }
         .update-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            color: #888; /* 修改点：加深日间模式的文字颜色 */
            padding: 8px 0 15px 0;
            background: transparent;
            border-top: none;
            margin: 0;
            pointer-events: none;
            /* 核心修改：添加文字阴影以增强可读性 */
            text-shadow: 0 0 5px rgba(255, 255, 255, 1), 0 0 10px rgba(255, 255, 255, 0.8);
        }
        body.dark-mode .update-footer {
             color: #a0aec0; /* 修改点：为夜间模式设置一个合适的亮色 */
             /* 核心修改：为夜间模式添加更强的黑色阴影 */
             text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5), 0 0 10px rgba(0, 0, 0, 0.4);
        }



        body.dark-mode .update-footer { background: var(--bg-night-element); }

        .fab-drawer-item#helpBtn { position: relative; }
        .fab-drawer-item.has-update::after {
            content: '';
            position: absolute;
            top: 6px;
            right: 6px;
            width: 8px;
            height: 8px;
            background-color: #e53e3e;
            border-radius: 50%;
            border: 1px solid white;
            box-shadow: 0 0 5px #e53e3e;
        }
        /* ===== [END] HELP MODAL UPDATE STYLES ===== */

        /* ... 你现有的其他 CSS ... */
        .fab-drawer-item.has-update::after {
            /* ... */
        }
        /* ===== [END] HELP MODAL UPDATE STYLES ===== */


        /* =============================================================== */
        /* ============ [新增] iOS 提示模态框的微调样式 ============ */
        /* =============================================================== */
        #iosWarningModal .modal-body p {
            line-height: 1.6;
            margin-bottom: 12px;
        }
        #iosWarningModal .modal-body strong {
            color: var(--hold-border);
            font-weight: 600;
        }
        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */




        /* ===== [START] FROSTED GLASS THEME ===== */
        body.theme-glass .modal-overlay,
        body.theme-glass #memoryPhotoViewerOverlay {
            background: transparent;
        }

        body.theme-glass .nav-btn,
        body.theme-glass .title-card,
        body.theme-glass .fab-main,
        body.theme-glass .fab-drawer-item,
        body.theme-glass .modal-content,
        body.theme-glass .category-pill,
        body.theme-glass .player-content,
        body.theme-glass .player-popover,
        body.theme-glass #memoryModal .hub-btn,
        body.theme-glass #memoryModal .folder-item,
        body.theme-glass #memoryModal .note-item,
        body.theme-glass #memoryModal .album-item,
        body.theme-glass #memoryModal .fab,
        body.theme-glass #memoryModal .editor-btn,
        body.theme-glass #memoryModal #note-editor-view,
        body.theme-glass .management-controls,
        body.theme-glass #returnConfirmationToast {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
        }
        
        /* [兼容性修复] 将text-btn的样式覆盖单独出来，防止因其他特殊选择器导致整个规则块失效 */
        body.theme-glass .nav-btn.text-btn {
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border: none;
            box-shadow: none;
        }

        body.theme-glass.dark-mode .nav-btn,
        body.theme-glass.dark-mode .title-card,
        body.theme-glass.dark-mode .fab-main,
        body.theme-glass.dark-mode .fab-drawer-item,
        body.theme-glass.dark-mode .modal-content,
        body.theme-glass.dark-mode .category-pill,
        body.theme-glass.dark-mode .player-content,
        body.theme-glass.dark-mode .player-popover,
        body.theme-glass.dark-mode #memoryModal .hub-btn,
        body.theme-glass.dark-mode #memoryModal .folder-item,
        body.theme-glass.dark-mode #memoryModal .note-item,
        body.theme-glass.dark-mode #memoryModal .album-item,
        body.theme-glass.dark-mode #memoryModal .fab,
        body.theme-glass.dark-mode #memoryModal .editor-btn,
        body.theme-glass.dark-mode #memoryModal #note-editor-view,
        body.theme-glass.dark-mode .management-controls,
        body.theme-glass.dark-mode #returnConfirmationToast {
            background: rgba(20, 20, 20, 0.25);
            border-color: rgba(255, 255, 255, 0.1);
        }

        body.theme-glass .modal-input,
        body.theme-glass .modal-select,
        body.theme-glass .modal-textarea,
        body.theme-glass .segmented-control,
        body.theme-glass .toggle-section,
        body.theme-glass #file-list-container,
        body.theme-glass .color-input-wrapper {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: none;
        }
        body.theme-glass.dark-mode .modal-input,
        body.theme-glass.dark-mode .modal-select,
        body.theme-glass.dark-mode .modal-textarea,
        body.theme-glass.dark-mode .segmented-control,
        body.theme-glass.dark-mode .toggle-section,
        body.theme-glass.dark-mode #file-list-container,
        body.theme-glass.dark-mode .color-input-wrapper {
            background: rgba(10, 10, 10, 0.2);
            border-color: rgba(255, 255, 255, 0.1);
        }

        body.theme-glass .modal-button {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        body.theme-glass.dark-mode .modal-button {
             background: rgba(30, 30, 30, 0.4);
        }

        body.theme-glass .nav-btn:active,
        body.theme-glass .modal-button:active,
        body.theme-glass .fab-main:active,
        body.theme-glass .fab-drawer-item:active {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transform: translateY(1px);
        }

        body.theme-glass .segmented-control .slider-indicator {
            background: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.6);
        }
        body.theme-glass.dark-mode .segmented-control .slider-indicator {
             background: rgba(200, 200, 200, 0.25);
             border-color: rgba(255, 255, 255, 0.15);
        }
        /* ===== [END] FROSTED GLASS THEME ===== */

        /* [新增] 为“已确认”的十六进制代码添加变淡的样式 */
        .hex-display.modal-input.confirmed-color {
            color: #a0aec0; /* 一个比默认文字更淡的灰色 */
            opacity: 0.8; /* 稍微降低不透明度 */
            transition: color 0.3s ease, opacity 0.3s ease; /* 添加平滑过渡效果 */
        }
        body.dark-mode .hex-display.modal-input.confirmed-color {
            color: #718096; /* 夜间模式下对应的淡灰色 */
        }

        /* ===== [START] FLOATING JELLYFISH BALL STYLES (MODIFIED) ===== */
        .jelly-ball-wrapper { /* MODIFICATION: New wrapper for custom CSS support */
            position: fixed;
            z-index: 2005;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease, transform 0.3s ease, left 0.2s ease-out, top 0.2s ease-out;
            pointer-events: none; /* MODIFICATION: Wrapper is non-interactive */
        }
        .jelly-ball-wrapper .jelly-ball-glow { /* MODIFICATION: New glow element */
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            animation: jelly-glow 2.5s infinite ease-in-out;
            filter: drop-shadow(0 0 2px rgba(91, 153, 226, 0.7));
        }

        @keyframes jelly-glow {
            0% { filter: drop-shadow(0 0 2px var(--hold-border, rgba(91, 153, 226, 0.7))); }
            50% { filter: drop-shadow(0 0 8px var(--hold-border, rgba(91, 153, 226, 1))); }
            100% { filter: drop-shadow(0 0 2px var(--hold-border, rgba(91, 153, 226, 0.7))); }
        }
        #floating-jellyfish-ball {
            position: relative; /* MODIFICATION: Changed from fixed */
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: grab;
            user-select: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: transform 0.3s ease; /* MODIFICATION: Removed other transitions */
            pointer-events: auto; /* MODIFICATION: Ball itself is interactive */
        }
        body.dark-mode #floating-jellyfish-ball {
            background: rgba(30, 30, 30, 0.6);
            border-color: rgba(255, 255, 255, 0.15);
        }
        .jelly-ball-wrapper.dragging { /* MODIFICATION: Dragging class on wrapper */
            transition: none;
        }
        #floating-jellyfish-ball.dragging {
            cursor: grabbing;
            transform: scale(1.1);
        }
        .jelly-ball-wrapper.idle { /* MODIFICATION: Idle class on wrapper */
            opacity: 0.5;
        }
        .jelly-ball-wrapper.idle.snap-right {
            transform: translateX(66.67%); /* MODIFICATION: Hide 2/3 of the ball */
        }
        .jelly-ball-wrapper.idle.snap-left {
            transform: translateX(-66.67%); /* MODIFICATION: Hide 2/3 of the ball */
        }
        .jelly-menu {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .jelly-menu-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 38px;
            height: 38px;
            margin: -19px 0 0 -19px;
            background: inherit;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            box-shadow: inherit;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
        }
        #floating-jellyfish-ball.menu-open .jelly-menu-btn {
            transform: var(--transform-end);
            opacity: 1;
            pointer-events: auto;
        }
        .jelly-menu-btn.hovered {
            transform: var(--transform-end) scale(1.15) !important;
            filter: brightness(1.1);
        }
        /* ===== [END] FLOATING JELLYFISH BALL STYLES ===== */

        /* ===== [START] MEMO LIST ITEM COPY BUTTON STYLES ===== */
        .note-item {
            position: relative; /* 确保子元素能够绝对定位 */
        }

        /* 复制按钮在备忘录列表项中的样式 */
        .note-item-copy-btn {
            position: absolute;
            bottom: 8px; /* 距离底部 */
            right: 8px; /* 距离右侧 */
            width: 24px;   /* 按钮宽度 */
            height: 24px;  /* 按钮高度 */
            padding: 4px;  /* 增加点击区域 */
            background: transparent;
            border: none;
            cursor: pointer;
            color: #ADB5BD; /* 浅灰色 */
            opacity: 0.5; /* 默认半透明 */
            transition: opacity 0.2s, transform 0.2s;
            z-index: 2; /* 确保在备忘录内容之上 */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%; /* 圆形 */
        }
        
        /* 鼠标悬停时 */
        .note-item-copy-btn:hover {
            opacity: 1;
            transform: scale(1.1); /* 稍微放大 */
            background-color: rgba(128,128,128,0.1); /* 浅色背景 */
        }

        /* 夜间模式 */
        body.dark-mode .note-item-copy-btn {
            color: #718096; /* 夜间模式下的浅灰色 */
        }
        body.dark-mode .note-item-copy-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }

        /* 磨砂玻璃主题 */
        body.theme-glass .note-item-copy-btn {
            background: rgba(255, 255, 255, 0.1); /* 半透明背景 */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            color: #333;
        }
        body.theme-glass.dark-mode .note-item-copy-btn {
             background: rgba(50, 50, 50, 0.25);
             border-color: rgba(255, 255, 255, 0.1);
             color: #CCC;
        }

        /* 调整图标尺寸，以便更好地适应24px的按钮 */
        .note-item-copy-btn svg {
            width: 16px; /* SVG图标的实际大小 */
            height: 16px;
        }

        /* 隐藏复制按钮在管理模式下，避免干扰 */
        .note-item.manage-mode .note-item-copy-btn {
            display: none;
        }
        /* ===== [END] MEMO LIST ITEM COPY BUTTON STYLES ===== */


        /* ===== [START] FLOATING PROJECT WINDOW STYLES ===== */
        .floating-project-window {
            position: fixed;
            z-index: 2010;
            width: 350px;
            height: 500px;
            background: var(--bg-day-element);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* resize: both;  */ /* Using custom resizer */
            min-width: 250px;
            min-height: 300px;
            transition: opacity 0.3s ease, transform 0.3s ease;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            opacity: 0;
        }
        .floating-project-window.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        body.dark-mode .floating-project-window {
            background: var(--bg-night-element);
        }
        body.theme-glass .floating-project-window {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
        }
        body.theme-glass.dark-mode .floating-project-window {
            background: rgba(20, 20, 20, 0.25);
            border-color: rgba(255, 255, 255, 0.1);
        }
        .fpw-header {
            flex-shrink: 0;
            padding: 8px 12px;
            background: rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        body.dark-mode .fpw-header { background: rgba(255,255,255,0.05); }
        .fpw-header:active { cursor: grabbing; }
        .fpw-title {
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .fpw-controls { display: flex; align-items: center; gap: 4px; }
        .fpw-controls button {
            background: transparent;
            border: none;
            color: inherit;
            font-size: 18px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.2s;
            line-height: 28px;
        }
        .fpw-controls button:hover { background: rgba(0,0,0,0.1); }
        .fpw-content {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }
        .fpw-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .fpw-resizer {
            position: absolute;
            width: 20px;
            height: 20px;
            right: 0;
            bottom: 0;
            cursor: se-resize;
            z-index: 10;
        }
        
                .fpw-hide-handle {
            position: fixed;
            z-index: 2009;
            padding: 10px 8px;
            background: var(--bg-day-element);
            color: var(--text-day);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            cursor: pointer;
            transition: opacity 0.3s ease, top 0.3s ease; /* 修改点：增加了 top 属性的过渡效果 */
            font-size: 12px;
            font-weight: 600;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
        }

        .fpw-hide-handle.visible {
            opacity: 1;
            pointer-events: auto;
        }
        body.dark-mode .fpw-hide-handle { background: var(--bg-night-element); color: var(--text-night); }
        /* ===== [END] FLOATING PROJECT WINDOW STYLES ===== */

        /* ===== [START] CSS HELP MODAL STYLES ===== */
        #jelly-css-help-modal .modal-content { max-width: 600px; }
        #jelly-css-help-modal .modal-body { gap: 10px; }
        .css-help-section { padding: 12px 15px; border-radius: 10px; background: rgba(0,0,0,0.03); }
        body.dark-mode .css-help-section { background: rgba(255,255,255,0.03); }
        .css-help-section h3 { font-size: 1.25em; margin-bottom: 10px; color: var(--hold-border); text-align: center; border-bottom: 1px solid rgba(128,128,128,0.2); padding-bottom: 8px;}
        .css-help-section h4 { font-size: 1.1em; margin-top: 15px; margin-bottom: 5px; }
        .css-help-section p, .css-help-section li { line-height: 1.6; font-size: 0.95em; }
        .css-help-text-block { background-color: rgba(128,128,128,0.1); padding: 12px; border-radius: 8px; margin-top: 5px; font-family: monospace; white-space: pre-wrap; word-break: break-all; font-size: 13px; position:relative;}
        .css-help-text-block .copy-btn { position: absolute; top: 8px; right: 8px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: inherit; padding: 4px 8px; border-radius: 5px; font-size: 12px; cursor: pointer; transition: background 0.2s; }
        .css-help-text-block .copy-btn:hover { background: rgba(255,255,255,0.4); }

/* 你可以把这段 CSS 放在 <style> 标签的末尾 */
#iosPwaWarningModal .modal-header {
    justify-content: center; /* 让标题居中 */
}
#iosPwaWarningModal .important-note {
    border-left-color: #e53e3e; /* 强化警告区域的边框颜色 */
    background-color: rgba(229, 62, 62, 0.1);
}

        /* ===== [END] CSS HELP MODAL STYLES ===== */

/* =============================================================== */
/* ============= [新增] 拖拽排序功能专属样式 V1.0 ============= */
/* =============================================================== */

/* 当拖拽发生时，给 body 添加此类，以防止意外的文本选择 */
body.dragging-active {
    user-select: none;
    -webkit-user-select: none;
    cursor: grabbing !important;
}

/* 正在被拖拽的原始按钮的样式，让它“占位”但视觉上弱化 */
.nav-btn.dragging,
.category-pill.dragging {
    opacity: 0.4;
    animation: none !important; /* 拖拽时停止抖动动画 */
    transform: none !important;
}

/* 跟随手指移动的半透明虚影的样式 */
.drag-ghost {
    position: fixed; /* 使用 fixed 定位，使其可以在全屏自由移动 */
    pointer-events: none; /* 让鼠标事件可以穿透虚影，检测到下方的元素 */
    z-index: 9999;
    opacity: 0.8;
    transform: scale(1.08); /* 拖拽时微微放大，有被“拿起”的感觉 */
    transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

/* 当一个按钮成为有效的放置目标时的样式 */
.nav-btn.drag-over,
.category-pill.drag-over {
    transform: scale(1.05) !important; /* 目标位置微微放大 */
    animation: none !important; /* 悬停时也停止抖动 */
    box-shadow: 0 0 18px 4px var(--hold-border, #63b3ed) !important; /* 关键的蓝色光晕特效 */
    transition: all 0.2s ease-in-out;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 非阻塞式顶部提示框样式 ============ */
/* =============================================================== */
.top-toast {
    position: fixed;
    top: 0;
    left: 50%;
    transform: translate(-50%, -150%); /* 初始位置在屏幕外 */
    padding: 12px 20px;
    background: var(--bg-day-element); /* 适配主题背景 */
    color: #6c757d; /* 设置为清晰的灰色字体 */
    border-radius: 0 0 12px 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), inset 0 -1px 0 rgba(0,0,0,0.05); /* 适配主题的阴影 */
    z-index: 9999;
    font-size: 15px;
    font-weight: 600;
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
    pointer-events: none; /* 不会阻挡鼠标点击 */
    text-align: center;
    max-width: 90%;
}
/* 新增：夜间模式适配 */
body.dark-mode .top-toast {
    background: var(--bg-night-element);
    color: #a0aec0; /* 夜间模式使用更亮的灰色 */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}
/* 新增：磨砂玻璃主题适配 */
body.theme-glass .top-toast {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-top: none;
    color: #343a40;
}
body.theme-glass.dark-mode .top-toast {
    background: rgba(30, 30, 30, 0.4);
    border-color: rgba(255, 255, 255, 0.15);
    color: #e9ecef;
}

.top-toast.show {
    transform: translate(-50%, 0); /* 移动到屏幕内 */
    opacity: 1;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ============== [修正] 手机模式专属样式 V3 ================= */
/* =============================================================== */

/* 默认状态下，滑动容器是完全不存在的 */
.main-wrapper {
    display: none;
}

/* 仅当手机模式开启时，应用以下所有样式 */
body.mobile-mode {
    /* 1. 强制 body 停止原有的 flex 布局，并禁止滚动 */
    display: block !important;
    overflow: hidden !important;
}

body.mobile-mode .main-wrapper {
    /* 2. 显示滑动容器并使其铺满整个屏幕 */
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

/* 3. 原始的主页元素在手机模式下需要被隐藏，以避免冲突 */
body.mobile-mode > .title-card,
body.mobile-mode > .category-nav-container,
body.mobile-mode > .nav-container {
    display: none !important;
}

body.mobile-mode .page-slider {
    display: flex;
    width: 200%;
    height: 100%;
    transform: translateX(0); /* 默认展示锁屏 */
    transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
}

body.mobile-mode .page-slider.show-home-screen {
    transform: translateX(-50%); /* 滑动到主屏幕 */
}

/* [修改] 默认隐藏右下角按钮，并添加过渡动画 */
body.mobile-mode .fab-container {
    opacity: 0;
    transform: scale(0.8);
    pointer-events: none;
    transition: opacity 0.3s ease, transform 0.3s ease;
}

/* [修改] 当 body 具有 .mobile-home-screen-active 类时，显示按钮 */
body.mobile-mode.mobile-home-screen-active .fab-container {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}

body.mobile-mode .lock-screen-page,
body.mobile-mode .home-screen-page {
    width: 50%;
    height: 100%;
    flex-shrink: 0;
    overflow: hidden; /* 页面本身不滚动，这是正确的 */
    padding: 4vh 0 2vh 0; /* 修改：移除左右内边距，给底部留一点空间 */
    display: flex;
    flex-direction: column;
    align-items: center; /* [核心修改] 新增此行，使其内部元素水平居中 */
    justify-content: center; /* [核心修改] 新增此行，使其内部元素垂直居中 */
}


/* ===== [新增] 手机模式下，主屏幕内部元素的布局控制 ===== */

/* 手机模式下，标题卡片的自适应宽度和间距 (新版本) */
body.mobile-mode .home-screen-page > .title-card {
    width: 90%;          /* 关键：设定一个相对于父容器的固定百分比宽度 */
    max-width: 450px;      /* 可选：在非常宽的屏幕上（如平板）限制最大宽度 */
    margin-left: auto;   /* 关键：让浏览器自动计算左边距 */
    margin-right: auto;  /* 关键：让浏览器自动计算右边距 */
    flex-shrink: 0;      
}

/* 如果分类导航也需要修改，可以采用类似的方法 */
body.mobile-mode .home-screen-page > .category-nav-container {
    flex-shrink: 0;
    /* 保持原样或根据需要调整，目前分类导航占满宽度左右滑动是比较常见的体验 */
    width: 100%; 
    padding-left: 20px;
    padding-right: 20px;
}


/* 2. 可滚动元素 (按钮区域) 填满所有剩余空间并开启内部滚动 */
body.mobile-mode .home-screen-page > .scrollable-nav-wrapper {
    flex-grow: 1;         /* 关键：占据所有剩余的垂直空间 */
    overflow-y: auto;     /* 关键：当内容超出时，只在这个容器内显示垂直滚动条 */
    min-height: 0;        /* 关键：Flex布局中的重要技巧，防止内容撑开容器 */
    width: 100%;          /* 确保占满容器宽度 */
    padding-left: 10px;   /* 将水平内边距应用到子元素上 */
    padding-right: 10px;
    padding-bottom: 80px; /* 为底部留出额外空间，避免按钮紧贴屏幕边缘 */
}



.lock-screen-page {
    padding-top: 2vh;
    padding-bottom: 2vh;
    overflow: hidden; /* 确保页面本身不滚动 */
    /* [核心修改] 父容器只负责垂直布局和水平居中其子元素 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
.lockscreen-grid {
    /* [核心修改] 模仿 title-card 的布局模式 */
    width: calc(100% - 40px); /* 关键：自身宽度为父容器宽度减去两侧边距 */
    max-width: 500px;
    /* [移除] margin: 0 auto; 和 flex-grow: 1; 由JS动态控制高度 */
    position: relative; 
    min-height: 0;
    --widget-gap: 15px;
}


.home-screen-page .title-card,
.home-screen-page .category-nav-container,
.home-screen-page .nav-container {
    transition: transform 0.4s ease-out, opacity 0.3s ease-out;
}

body.mobile-mode .page-slider:not(.show-home-screen) .home-screen-page > * {
    transform: translateX(100px);
    opacity: 0;
}
/* =============================================================== */
/* ========================= [修正结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ============= [重构] 锁屏组件及设置相关样式 V2 ============ */
/* =============================================================== */

/* 组件基础样式 */
.widget {
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-day);
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    padding: 8px;
    box-sizing: border-box;
    text-align: center;
    overflow: hidden;
    /* [核心修复] 允许flex容器收缩至小于其内容尺寸，防止iframe撑开布局 */
    min-height: 0; 
}

body.dark-mode .widget {
    background: rgba(20, 20, 20, 0.25);
    border-color: rgba(255, 255, 255, 0.1);
    color: var(--text-night);
}

/* 新的组件尺寸系统 */
.widget-size-2x2 { grid-column: span 2; grid-row: span 2; }
.widget-size-4x2 { grid-column: span 4; grid-row: span 2; }
/* 1x1 是默认，无需特殊样式 */

/* 设置界面专属 */
#fpw-lockscreen-settings .settings-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 8px;
    height: 100%;
    padding: 10px;
    background: rgba(128,128,128,0.05);
    border-radius: 12px;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.1);
}
#fpw-lockscreen-settings .settings-grid-cell {
    border: 1px dashed rgba(128,128,128,0.3);
    border-radius: 12px;
    transition: all 0.2s ease;
    display: flex; /* 用于定位内部元素 */
    position: relative;
    background-size: cover;
    background-position: center;
}
#fpw-lockscreen-settings .settings-grid-cell.drag-over {
    border-style: solid;
    border-color: var(--hold-border);
    background-color: rgba(91, 153, 226, 0.1);
    transform: scale(1.05);
}
#fpw-lockscreen-settings .widget-placeholder {
    position: absolute; /* 绝对定位，覆盖在格子之上 */
    border: 1px solid var(--hold-border);
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    padding: 5px;
    color: inherit;
    pointer-events: none; /* 自身不响应鼠标事件 */
}
#fpw-lockscreen-settings .widget-placeholder-delete {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 20px;
    height: 20px;
    background-color: #f56565;
    color: white;
    border: 1px solid white;
    border-radius: 50%;
    font-size: 14px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    cursor: pointer;
    z-index: 10;
    pointer-events: all; /* 删除按钮需要响应鼠标事件 */
    transition: transform 0.2s;
}
#fpw-lockscreen-settings .widget-placeholder-delete:hover {
    transform: scale(1.1);
}

/* 组件添加区 */
.component-palette {
    padding: 15px 10px;
    border-top: 1px solid rgba(128,128,128,0.2);
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.component-palette-title {
    font-size: 14px;
    font-weight: 600;
    color: #889;
    text-align: center;
}
.component-palette-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
}
.palette-item {
    padding: 10px;
    border: 1px dashed rgba(128,128,128,0.4);
    border-radius: 10px;
    text-align: center;
    cursor: grab;
    transition: all 0.2s ease;
    font-size: 13px;
    background: rgba(128,128,128,0.05);
}
.palette-item:hover {
    border-color: var(--hold-border);
    background: rgba(91, 153, 226, 0.1);
}
.palette-item:active {
    cursor: grabbing;
    transform: scale(0.95);
}

/* 拖拽虚影 */
.widget-ghost {
    position: fixed;
    z-index: 9999;
    pointer-events: none;
    opacity: 0.75;
    transition: opacity 0.2s, transform 0.2s;
    background: var(--bg-day-element);
    border: 2px solid var(--hold-border);
    backdrop-filter: blur(8px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    border-radius: 16px; /* 匹配真实组件 */
}
body.dark-mode .widget-ghost {
    background: var(--bg-night-element);
}


/* 组件选择弹窗 (上下文菜单) */
.component-selection-popup {
    position: fixed; /* 使用 fixed 定位，确保在最上层 */
    z-index: 9999;
    background: var(--bg-day-element);
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    opacity: 0;
    transform: scale(0.95);
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none;
}
.component-selection-popup.show {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}
body.dark-mode .component-selection-popup {
    background: var(--bg-night-element);
}
body.theme-glass .component-selection-popup {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}
body.theme-glass.dark-mode .component-selection-popup {
    background: rgba(30, 30, 30, 0.4);
    border-color: rgba(255, 255, 255, 0.15);
}
.component-popup-title {
    font-size: 13px;
    font-weight: 600;
    text-align: center;
    padding: 4px 8px;
    color: #889;
    border-bottom: 1px solid rgba(128,128,128,0.2);
    margin-bottom: 4px;
}
.component-popup-button {
    width: 100%;
    padding: 10px 20px;
    border: none;
    background: transparent;
    border-radius: 8px;
    text-align: left;
    font-size: 15px;
    font-weight: 500;
    color: inherit;
    cursor: pointer;
    transition: background-color 0.2s;
}
.component-popup-button:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .component-popup-button:hover {
    background-color: rgba(255,255,255,0.08);
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] V2 组件功能实现样式 ================== */
/* =============================================================== */

/* HTML 组件内的 iframe 样式 */
.widget-html-iframe {
    width: 100%;
    height: 100%;
    border: none;
    border-radius: 10px; /* 继承父元素圆角 */
    background-color: transparent;
}

/* 快捷方式组件 (小组件) */
.widget-shortcut {
    width: 100%;
    height: 100%;
    border-radius: 50%; /* 关键：圆形按钮 */
    font-size: 11px;
    padding: 4px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}
.widget-shortcut:hover {
    transform: scale(1.05);
}
.widget-shortcut:active {
    transform: scale(0.95);
    box-shadow: inset 2px 2px 4px rgba(0,0,0,0.15), inset -2px -2px 4px rgba(255,255,255,0.7);
}
body.dark-mode .widget-shortcut:active {
    box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -2px -2px 4px rgba(255,255,255,0.1);
}

/* --- 备忘录小组件样式 --- */
.widget-memo {
    /* [V2 修复] 改为 Flex 布局以精确控制子元素 */
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: flex-start;
    padding: 12px;
    text-align: left;
    color: var(--widget-text-color);
    background-color: var(--widget-background-color);
}

.widget-memo .widget-memo-title {
    /* [V2 修复] 确保标题不会被压缩 */
    flex-shrink: 0; 
    font-weight: 700;
    font-size: 1em;
    margin-bottom: 6px; /* 稍微增加与内容的间距 */
    width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.widget-memo .widget-memo-content {
    /* [V2 修复] 让内容区域填满剩余空间并应用截断 */
    flex-grow: 1; 
    min-height: 0; /* 允许 flex item 收缩 */
    font-weight: 400; /* [优化] 调整字重以提高可读性 */
    font-size: 0.9em;
    opacity: 0.85;
    width: 100%;
    line-height: 1.5;
    
    /* 核心截断逻辑 */
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    /* line-clamp 将由 JS 动态设置 */
}



/* 图片组件样式 */
.widget-image {
    padding: 0; /* 图片组件不需要内边距 */
    overflow: hidden; /* 确保图片不溢出圆角 */
}
.widget-image img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 关键：自动裁剪并填充 */
}

/* 组件设置窗口内，已有组件的样式 */
.settings-widget-item {
    position: absolute;
    border: 1px dashed var(--hold-border);
    transition: all 0.2s ease;
}
.settings-widget-item:hover {
    background: rgba(91, 153, 226, 0.1);
}
.settings-widget-delete-btn {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 20px;
    height: 20px;
    background-color: #f56565;
    color: white;
    border: 1px solid white;
    border-radius: 50%;
    font-size: 14px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    cursor: pointer;
    z-index: 10;
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.2s ease;
}
.settings-widget-item:hover .settings-widget-delete-btn {
    opacity: 1;
    transform: scale(1);
}

/* 通用选择器浮动窗口样式 */
.picker-window-container {
    position: fixed;
    z-index: 2025; /* 比设置窗口高一级 */
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

.picker-list {
    max-height: 300px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.picker-item {
    padding: 12px 15px;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    background-color: rgba(0,0,0,0.02);
}
.picker-item:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .picker-item:hover {
    background-color: rgba(255,255,255,0.08);
}
/* 图片选择器网格 */
.picker-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    max-height: 300px;
    overflow-y: auto;
}
.picker-grid-item {
    aspect-ratio: 1 / 1;
    border-radius: 8px;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.2s;
}
.picker-grid-item:hover {
    transform: scale(1.05);
}
.picker-grid-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
/* HTML 编辑器 */
.html-editor-textarea {
    width: 100%;
    min-height: 150px;
    resize: vertical;
}

/* =============================================================== */
/* ============= [新增] V3 备忘录悬浮窗样式 ================= */
/* =============================================================== */
.memo-popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(5px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3000;
    opacity: 0;
    transition: opacity .3s ease;
}
.memo-popup-overlay.show {
    opacity: 1;
}
.memo-popup-content {
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    background: var(--bg-day-element);
    color: var(--text-day);
    border-radius: 16px;
    box-shadow: 12px 12px 24px var(--shadow-dark-day), -12px -12px 24px var(--shadow-light-day);
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    transform: scale(0.95);
    transition: transform .3s ease;
}
.memo-popup-overlay.show .memo-popup-content {
    transform: scale(1);
}
body.dark-mode .memo-popup-content {
    background: var(--bg-night-element);
    color: var(--text-night);
    box-shadow: 12px 12px 24px var(--shadow-dark-night), -12px -12px 24px var(--shadow-light-night);
}
.memo-popup-title {
    font-size: 22px;
    font-weight: 700;
    border-bottom: 1px solid rgba(128,128,128,0.2);
    padding-bottom: 10px;
}
.memo-popup-body {
    font-size: 16px;
    line-height: 1.7;
    white-space: pre-wrap; /* 保留换行和空格 */
    overflow-y: auto;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 锁屏设置 V3 交互样式 ================ */
/* =============================================================== */
/* 整体添加器布局 */
.component-adder {
    padding: 15px 10px;
    border-top: 1px solid rgba(128,128,128,0.2);
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.component-adder label {
    font-size: 14px;
    font-weight: 600;
    color: #889;
    padding-left: 5px;
}

/* 尺寸选择器 */
.size-selector {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    padding: 10px;
    border-radius: 12px;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}
body.dark-mode .size-selector {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}
.roller-container {
    display: flex;
    align-items: center;
    gap: 10px;
}
.roller-btn {
    width: 32px;
    height: 32px;
    border: none;
    border-radius: 50%;
    background: var(--bg-day-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-day),-4px -4px 8px var(--shadow-light-day);
    color: var(--text-day);
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
}
body.dark-mode .roller-btn {
    background: var(--bg-night-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night);
    color: var(--text-night);
}
.roller-btn:active {
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}
body.dark-mode .roller-btn:active {
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}
.roller-display {
    font-size: 24px;
    font-weight: 700;
    min-width: 25px;
    text-align: center;
}
.size-selector > span {
    font-size: 20px;
    font-weight: 500;
    color: #aaa;
}

/* 类型选择器&确认按钮 */
.type-selector {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
#confirm-widget-btn {
    margin-top: 5px;
}

/* 新组件预览区 */
#new-widget-preview-area {
    min-height: 60px;
    border: 2px dashed rgba(128,128,128,0.3);
    border-radius: 12px;
    padding: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: border-color 0.3s;
}
#new-widget-preview-area.has-widget {
    border-style: solid;
    border-color: transparent;
}
.widget-preview-item {
    padding: 10px; /* 统一内边距 */
    border-radius: 16px; /* 增加圆角弧度，使其更像组件本身 */
    text-align: center;
    cursor: grab;
    font-size: 14px;
    font-weight: 600;
    background: var(--bg-day-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day);
    transition: all 0.2s ease;
    /* 核心修改：让其成为 flex 子项以便居中和控制尺寸 */
    display: flex;
    align-items: center;
    justify-content: center;
    /* 核心修改：设定固定的正方形尺寸 */
    width: 80px;
    height: 80px;
    flex-shrink: 0; /* 防止被 flex 容器压缩 */
    word-break: break-word; /* 防止文字溢出 */
}

body.dark-mode .widget-preview-item {
    background: var(--bg-night-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night);
}
.widget-preview-item:active {
    cursor: grabbing;
    transform: scale(0.95);
}

/* [新增] 胶囊形状样式 */
.widget.widget-shape-capsule {
    border-radius: 9999px;
}

/* [修复] 补充缺失的圆形样式 */
.widget.widget-shape-circle {
    border-radius: 50%;
}

/* 针对快捷方式组件的额外圆形样式优化 */
.widget-shortcut.widget-shape-square {
    border-radius: 16px; /* 让方形快捷按钮也保持统一的方正圆弧 */
}
/* [新增] 预览项形状样式 */
.widget-preview-item.shape-circle {
    border-radius: 50%;
    /* 强制预览块为正方形，以显示完美的圆形 */
    width: 80px; 
    height: 80px;
    padding: 10px; /* 调整内边距以适应大小 */
    flex-shrink: 0; /* 防止被压缩 */
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 锁屏设置 V4 模拟器样式 ================ */
/* =============================================================== */
/* [V8 修正] 模拟手机屏幕容器 */
.simulated-phone-screen {
    flex-shrink: 0;
    height: 40vh; /* 稍微增加高度 */
    max-height: 300px;
    width: auto;
    margin: 0 auto 15px auto;
    aspect-ratio: 9 / 18; /* 调整宽高比使其更宽 */
    background: rgba(0,0,0,0.1);
    border-radius: 18px; /* 轻微减小圆角以匹配更窄的边框 */
    border: 3px solid #333; /* [核心修改] 边框变窄 */
    box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
    padding: 8px; /* 减小内边距 */
    display: flex;
}
body.dark-mode .simulated-phone-screen {
    border-color: #555;
    background: rgba(255,255,255,0.05);
}
/* [V7 修正] 调整设置网格以适应新容器 (叠加策略) */
#lockscreen-settings-modal .settings-grid {
    position: relative; /* 关键：为绝对定位的子元素提供定位上下文 */
    padding: 0;
    box-shadow: none;
    background: transparent;
    width: 100%;
    height: 100%;
    /* 网格定义保持不变 */
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(8, 1fr);
}

/* [V7 修正] 重新定义 widget-placeholder (叠加策略) */
#lockscreen-settings-modal .widget-placeholder {
    /* `grid-area` 属性将由 JS 动态设置 */
    z-index: 5; /* 确保在虚线格子之上 */
    padding: 4px;
    font-size: 8px;
    overflow: hidden;
    text-align: center;
    word-break: break-all;
    background-size: cover;
    background-position: center;
    display: flex; /* 修正：确保内容居中和备忘录布局 */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    line-height: 1.3;
    position: relative; /* 为删除按钮提供定位上下文 */
    /* 已有样式继承自全局 .widget-placeholder */
    position: absolute; /* 绝对定位，覆盖在格子之上 */
    border: 1px solid var(--hold-border);
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    border-radius: 8px; /* [核心修改] 将组件预览也改成直角风格 */
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    color: inherit;
    pointer-events: none; /* 自身不响应鼠标事件 */
}
/* 迷你备忘录预览样式 */
.settings-widget-preview-memo-title {
    font-weight: bold;
    font-size: 9px;
    width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 2px;
}
.settings-widget-preview-memo-content {
    font-size: 7px;
    opacity: 0.8;
    display: -webkit-box;
    -webkit-line-clamp: 3; /* 限制显示行数 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
#lockscreen-settings-modal .widget-size-4x2 .settings-widget-preview-memo-content {
    -webkit-line-clamp: 5; /* 大尺寸显示更多行 */
}

/* 调整弹窗高度以适应模拟器 */
#lockscreen-settings-modal .modal-content {
    height: 85vh !important;
}

/* ========================================================================= */
/* ============== [V5 新增] 锁屏组件添加器紧凑布局样式 =============== */
/* ========================================================================= */
.adder-controls-row {
    display: flex;
    flex-wrap: nowrap; /* 强制不换行 */
    gap: 12px;
    align-items: flex-end; /* 底部对齐，使整体更整洁 */
}

.adder-control-group {
    display: flex;
    flex-direction: column;
    gap: 6px; /* 减小标签和控件之间的间距 */
}

.adder-control-group label {
    font-size: 13px; /* 缩小标签字体 */
    font-weight: 500;
    color: #889;
    padding-left: 2px;
}

/* 精确调整尺寸选择器内部 */
.adder-controls-row .size-selector {
    padding: 6px 8px; /* 减小内边距 */
    gap: 8px;
}
.adder-controls-row .roller-container {
    gap: 6px;
}
.adder-controls-row .roller-btn {
    width: 26px; /* 缩小按钮 */
    height: 26px;
    font-size: 18px; /* 减小按钮内字体 */
}
.adder-controls-row .roller-display {
    font-size: 20px; /* 减小数字字体 */
    min-width: 20px;
}
.adder-controls-row .size-selector > span {
    font-size: 16px;
}

/* 精确调整类型选择器（下拉框） */
.adder-controls-row .modal-select {
    padding: 6px 10px; /* 减小内边距以匹配高度 */
    font-size: 14px;
    height: 40px; /* 固定高度以对齐 */
    flex-grow: 1; /* 让其填充剩余空间 */
    min-width: 110px; /* 设置最小宽度防止被过度压缩 */
}
/* ========================================================================= */
/* ============================== [新增结束] =============================== */
/* ========================================================================= */

/* =============================================================== */
/* ============= [V6 新增] 模拟器网格与拖拽交互样式 ============ */
/* =============================================================== */
/* 调整设置网格容器，增加格子间距 */
#lockscreen-settings-modal .settings-grid {
    gap: 4px; /* 轻微减小间距以适应更宽的屏幕 */
}

/* [V8 修正] 可视化的虚线网格单元 (井字形) */
.settings-grid-cell {
    border: 1px dashed rgba(128,128,128,0.3);
    border-radius: 0; /* [核心修改] 去掉圆角，变为直角 */
    transition: all 0.2s ease;
    display: flex; 
    position: relative;
    background-size: cover;
    background-position: center;
}

/* 当拖拽物悬停在有效格子上时的样式 */
.settings-grid-cell.drag-over {
    border-style: solid;
    border-color: var(--hold-border);
    background-color: rgba(91, 153, 226, 0.1);
    transform: scale(1.02); /* 轻微缩放 */
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [V5 新增] 模拟器删除按钮优化样式 ============ */
/* =============================================================== */
/* 组件容器，用于定位和 hover 效果 */
.widget-container-wrapper {
    position: relative;
    /* grid-area 将由 JS 设置 */
}

/* 删除按钮的包裹层，用于居中和捕获点击 */
.widget-delete-wrapper {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.3);
    opacity: 0;
    pointer-events: none; /* 默认不可见不可点 */
    transition: opacity 0.2s ease;
}

/* 仅当包裹层被 hover 时，显示删除按钮 */
.widget-container-wrapper:hover .widget-delete-wrapper {
    opacity: 1;
    pointer-events: auto; /* hover 时可点击 */
}

/* 居中且更大的删除按钮本体 */
.widget-delete-btn-centered {
    width: 28px;
    height: 28px;
    background-color: rgba(245, 101, 101, 0.8);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    font-size: 20px;
    font-weight: bold;
    line-height: 26px; /* 垂直居中叉号 */
    text-align: center;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: transform 0.2s, background-color 0.2s;
}

.widget-delete-btn-centered:hover {
    transform: scale(1.1);
    background-color: #f56565;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [V7 新增] 居中加载指示器样式 ============= */
/* =============================================================== */
.loading-indicator-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999; /* 确保在最顶层 */
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
}

.loading-indicator-overlay.show {
    opacity: 1;
}

.loading-indicator-box {
    background-color: var(--content-bg);
    padding: 25px 40px;
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    text-align: center;
    transform: scale(0.95);
    transition: transform 0.2s ease-in-out;
}

.loading-indicator-overlay.show .loading-indicator-box {
    transform: scale(1);
}

.loading-indicator-text {
    font-size: 16px;
    color: var(--text-color);
    margin-bottom: 20px;
}

.loading-indicator-cancel-btn {
    background-color: #e53e3e;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.loading-indicator-cancel-btn:hover {
    background-color: #c53030;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* [新增] 锁屏HTML组件容器精准约束样式 */
.html-widget-container {
    position: relative; /* 为绝对定位的子元素创建定位上下文 */
}

.html-widget-container > .widget {
    position: absolute; /* 将widget脱离文档流，使其不再影响父容器的高度计算 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
/* =============================================================== */
/* ============= [新增] 锁屏组件背景选择器样式 ============= */
/* =============================================================== */
.widget-bg-picker-popup {
    position: absolute; /* 相对于父级容器定位 */
    z-index: 1; /* 确保在同一个容器内，但在其他内容之上 */
    background: var(--bg-day-element);
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
    padding: 10px;
    display: flex;
    align-items: center;
    gap: 8px;
    opacity: 0;
    transform: translateY(10px) scale(0.95);
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none;
    width: 220px; /* 固定宽度，保持紧凑 */
    margin-top: 8px; /* 与上方面板的间距 */
}
.widget-bg-picker-popup.show {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
}
body.dark-mode .widget-bg-picker-popup {
    background: var(--bg-night-element);
}
body.theme-glass .widget-bg-picker-popup {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}
body.theme-glass.dark-mode .widget-bg-picker-popup {
    background: rgba(30, 30, 30, 0.4);
    border-color: rgba(255, 255, 255, 0.15);
}

.widget-bg-picker-popup input[type="color"] {
    -webkit-appearance: none;
    width: 32px;
    height: 32px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background-color: transparent; /* 移除默认背景，让伪元素生效 */
    padding: 0;
    flex-shrink: 0;
}

.widget-bg-picker-popup input[type="color"]::-webkit-color-swatch {
    border-radius: 6px;
    border: 1px solid rgba(128,128,128,0.2);
}

.widget-bg-picker-popup .bg-picker-button {
    flex-grow: 1;
    padding: 8px;
    border: none;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 500;
    color: inherit;
    cursor: pointer;
    background-color: rgba(0,0,0,0.05);
    transition: background-color 0.2s;
}

.widget-bg-picker-popup .bg-picker-button:hover {
    background-color: rgba(0,0,0,0.1);
}
body.dark-mode .widget-bg-picker-popup .bg-picker-button {
    background-color: rgba(255,255,255,0.08);
}
body.dark-mode .widget-bg-picker-popup .bg-picker-button:hover {
    background-color: rgba(255,255,255,0.15);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* =================== [V2 BUG修复] 弹窗层级修正 =================== */
/* =============================================================== */
#jelly-css-help-modal.modal-overlay {
    z-index: 1003; /* 确保高于悬浮球设置弹窗(1002) */
}
/* =============================================================== */
/* ========================= [修复结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ============= [新增] 百度网盘集成专属样式 V1.0 =========== */
/* =============================================================== */

/* 文件夹页面右上角的设置按钮 */
#memoryModal .page-header .baidu-settings-btn {
    font-size: 22px; /* 设置一个合适的大小 */
    padding: 6px;
    margin-left: auto; /* 核心：将按钮推到最右侧 */
}

/* 百度网盘设置弹窗内的账户列表 */
#baidu-account-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 250px;
    overflow-y: auto;
    border-radius: 10px;
    padding: 10px;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}
body.dark-mode #baidu-account-list {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}

.baidu-account-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 15px;
    border-radius: 8px;
    transition: background-color 0.2s;
    gap: 15px;
}

.baidu-account-item:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .baidu-account-item:hover {
    background-color: rgba(255,255,255,0.08);
}

.baidu-account-info {
    display: flex;
    align-items: center;
    gap: 10px;
    min-width: 0; /* 防止长用户名撑开布局 */
}

.baidu-account-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #ccc;
    flex-shrink: 0;
}

.baidu-account-name {
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#baidu-auth-status {
    font-size: 14px;
    color: #889;
    text-align: center;
    margin-top: 15px;
    min-height: 20px;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ============= [新增] 备忘录编辑器 v2.0 样式 ============= */
/* =============================================================== */
#memoryModal #note-editor-view {
    padding-bottom: 0; /* 为工具栏留出空间 */
}
#memoryModal .editor-content {
    padding-bottom: 10px;
}
#memoryModal #note-content-editor {
    /* [修改] 移除 flex-grow，让其高度由内容决定，由父容器 .editor-content 滚动 */
    resize: none;
    line-height: 1.7;
    font-size: 16px;
    padding: 10px;
    -webkit-user-select: text; /* 允许在iOS上选择文本 */
    user-select: text;
    /* [修改] 移除此处的滚动，交由父容器处理 */
}


#memoryModal #note-content-editor:focus {
    outline: none;
}
#memoryModal #note-content-editor ul {
    list-style: none;
    padding-left: 0;
}
/* 通用待办清单样式 (编辑器 & 小组件) */
#memoryModal #note-content-editor li,
.widget-memo .widget-memo-content li {
    display: flex;
    align-items: flex-start;
    margin-bottom: 8px;
}
#memoryModal #note-content-editor li::before,
.widget-memo .widget-memo-content li::before {
    content: '○';
    font-size: 1.2em;
    margin-right: 10px;
    cursor: pointer;
    color: #889;
    font-weight: bold;
    display: inline-block;
    line-height: 1.5;
}
#memoryModal #note-content-editor li.completed::before,
.widget-memo .widget-memo-content li.completed::before {
    content: '●';
    color: var(--hold-border);
}
#memoryModal #note-content-editor li.completed .todo-text,
.widget-memo .widget-memo-content li.completed .todo-text {
    text-decoration: line-through;
    opacity: 0.6;
}
/* [V3 修复] 允许待办事项的文本内容换行 */
.todo-text {
    flex: 1; /* 让文本容器占据所有剩余空间 */
    min-width: 0; /* 关键：允许 flex item 收缩并换行其内容 */
    word-break: break-word; /* 确保长单词或URL也能正确换行 */
}


.memo-toolbar {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: space-around; /* 核心修复：使用 space-around 自动均分间距，取代固定的 gap */
    padding: 10px 15px; /* 优化：减少左右内边距，给按钮更多空间 */
    background: var(--bg-day-element);
    box-shadow: 0 -4px 12px rgba(0,0,0,0.05);
    border-top: 1px solid rgba(0,0,0,0.08);
    width: calc(100% + 20px);
    margin: 0 -10px -10px -10px;
    border-radius: 0 0 16px 16px;
    box-sizing: border-box;
}


body.dark-mode .memo-toolbar {
    background: var(--bg-night-element);
    box-shadow: 0 -4px 12px rgba(0,0,0,0.2);
    border-color: rgba(255,255,255,0.1);
}
.toolbar-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 20px;
    font-weight: bold;
    color: inherit;
    opacity: 0.7;
    transition: opacity 0.2s, transform 0.2s;
    padding: 5px;
    /* [新增] 以下三行是关键，确保按钮内容绝对居中 */
    display: flex;
    align-items: center;
    justify-content: center;
}

.toolbar-btn:hover {
    opacity: 1;
}
.toolbar-btn:active {
    transform: scale(0.9);
}
.toolbar-btn.strikethrough {
    text-decoration: line-through;
}
.toolbar-separator {
    width: 1px;
    height: 20px;
    background-color: rgba(128,128,128,0.3);
}
.toolbar-btn-code-copy {
    margin-left: auto; /* 靠右对齐 */
    font-size: 16px;
    font-weight: normal;
    background-color: rgba(128,128,128,0.1);
    padding: 4px 10px;
    border-radius: 6px;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备忘录代码块 v1.0 样式 ================ */
/* =============================================================== */
.memo-code-block {
    position: relative;
    background-color: rgba(128,128,128,0.1);
    border: 1px solid rgba(128,128,128,0.15);
    border-radius: 8px;
    padding: 12px 15px;
    margin: 10px 0;
    font-family: monospace;
    white-space: pre-wrap;
    word-break: break-all;
    font-size: 0.9em;
}
.code-block-copy-btn {
    position: absolute;
    top: 6px;
    right: 6px;
    background: rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.15);
    color: inherit;
    padding: 2px 6px;
    border-radius: 5px;
    font-size: 12px;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s, background-color 0.2s;
}
.memo-code-block:hover .code-block-copy-btn {
    opacity: 1;
}
.code-block-copy-btn:hover {
    background-color: rgba(0,0,0,0.2);
}
body.dark-mode .memo-code-block {
    background-color: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.1);
}
body.dark-mode .code-block-copy-btn {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.2);
}
body.dark-mode .code-block-copy-btn:hover {
    background-color: rgba(255,255,255,0.2);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备忘录工具栏激活状态 ================ */
/* =============================================================== */
.toolbar-btn.active {
    font-weight: 900; /* 使用更粗的字重表示激活 */
    opacity: 1;
    transform: scale(1.1);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 悬浮球设置预览区样式 ================= */
/* =============================================================== */
#jelly-css-preview-container {
    flex-shrink: 0;
    width: 80px;
    height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-day-element);
    border-radius: 12px;
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
    position: relative;
    overflow: hidden; /* 隐藏超出边界的辉光效果 */
    transform-style: preserve-3d; /* 提升渲染层级 */
}
body.dark-mode #jelly-css-preview-container {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}

/* 关键：重置预览球的位置，使其在容器内居中 */
#jelly-css-preview-container .jelly-ball-wrapper {
    position: relative;
    transform: scale(0.9); /* 稍微缩小以适应容器 */
    pointer-events: none; /* 确保预览球不可交互 */
}

/* [V2 BUG修复] 确保在主题设置弹窗关闭后，帮助弹窗依然可见 */
#jelly-css-help-modal.modal-overlay {
    z-index: 1003;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备忘录工具栏磨砂玻璃主题适配 ============= */
/* =============================================================== */

/* 日间模式下的磨砂玻璃工具栏 */
body.theme-glass .memo-toolbar {
    background: rgba(255, 255, 255, 0.15); /* 半透明背景 */
    backdrop-filter: blur(10px);          /* 核心：应用模糊效果 */
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid rgba(255, 255, 255, 0.25); /* 半透明亮色边框 */
    box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);    /* 更柔和的顶部阴影 */
    /* 关键：让工具栏的圆角匹配父容器的底部圆角 */
    border-radius: 0 0 16px 16px;
}

/* 夜间模式下的磨砂玻璃工具栏 */
body.theme-glass.dark-mode .memo-toolbar {
    background: rgba(20, 20, 20, 0.3); /* 更深的半透明背景 */
    border-top-color: rgba(255, 255, 255, 0.15); /* 夜间模式的半透明亮色边框 */
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);     /* 夜间模式下更深的阴影 */
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ================= [新增] 手机收藏馆专属样式 ================== */
/* =============================================================== */

/* 新增：泡泡漂浮动画 (保持不变) */
@keyframes float-bubble {
    0% { transform: translateY(0px) scale(1); }
    50% { transform: translateY(-8px) scale(1.02); }
    100% { transform: translateY(0px) scale(1); }
}

#phoneCollectionModal .modal-content {
    max-width: 800px;
    height: calc(100vh - 40px);
    padding: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}
#phoneCollectionModal .page-content {
    flex-grow: 1; 
    display: grid; /* [核心修改] 使用 Grid 布局替代 Flex */
    grid-template-rows: auto 1fr; /* [核心修改] 定义一个高度自适应的头部行，和一个占满剩余空间的滚动内容行 */
    min-height: 0; 
    overflow: hidden; /* 保持不变，确保整个页面内容不溢出 */
}

#phoneCollectionModal .page-header-container {
    flex-shrink: 0; 
}

#phoneCollectionModal .list-container {
    /* 垂直内边距保持，水平内边距交由布局自动处理 */
    padding: 35px 15px; /* [核心修正] 增加左右内边距 */
    display: flex; /* ★ 核心修改：使用 Flexbox 布局 */
    flex-wrap: wrap; /* ★ 核心修改：允许泡泡换行 */
    justify-content: center; /* [核心修正] 改为 center 避免溢出 */
    gap: 20px 15px; /* [核心修正] 使用 gap 控制间距 (行间距 列间距) */
    align-content: flex-start;
    overflow-y: auto;
    min-height: 0;
}

/* 核心修改：将分区项目改为圆形泡泡 */
.phone-partition-item {
    width: 100px; 
    height: 100px; 
    flex-shrink: 0; 
    position: relative;
    padding: 8px;
    border-radius: 50%; /* 关键：变为圆形 */
    box-shadow: 6px 6px 12px var(--shadow-dark-day), -6px -6px 12px var(--shadow-light-day);
    background: var(--bg-day-element);
    color: var(--text-day);
    cursor: pointer;
    transition: box-shadow 0.3s ease, transform 0.2s ease; /* 重加 transform 过渡，用于点击反馈 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    gap: 0;
    user-select: none; 
    -webkit-tap-highlight-color: transparent;

    animation: float-bubble 6s ease-in-out infinite;
}

/* ★ 新增：错落有致的布局效果 ★ */
.phone-partition-item:nth-child(odd) {
    transform: translateY(-20px); /* 奇数泡泡向上移动 */
}
.phone-partition-item:nth-child(even) {
    transform: translateY(20px); /* 偶数泡泡向下移动 */
}


.phone-partition-item:active {
    box-shadow: inset 3px 3px 6px var(--shadow-dark-day), inset -3px -3px 6px var(--shadow-light-day);
    animation-play-state: paused; 
    transform: scale(0.97) !important; /* 强制应用缩小效果，同时覆盖错落位移 */
}
body.dark-mode .phone-partition-item {
    box-shadow: 6px 6px 12px var(--shadow-dark-night), -6px -6px 12px var(--shadow-light-night);
    background: var(--bg-night-element);
    color: var(--text-night);
}
body.dark-mode .phone-partition-item:active {
    box-shadow: inset 3px 3px 6px var(--shadow-dark-night), inset -3px -3px 6px var(--shadow-light-night);
}
.phone-partition-icon {
    display: none;
}
.phone-partition-name {
    font-size: 0.9rem;
    font-weight: 600;
    line-height: 1.4;
    padding: 0 5px; 
}

/* ★ 新增：修复磨砂玻璃主题下的圆角问题 ★ */
body.theme-glass .phone-partition-item {
    border-radius: 50%;
}


/* ----- 以下为详情页样式，保持不变 ----- */
#phone-detail-content {
    gap: 18px;
    padding-bottom: 30px;
}
.detail-info-group {
    padding: 15px;
    border-radius: 12px;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}
body.dark-mode .detail-info-group {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}
.detail-info-group label {
    font-size: 14px;
    font-weight: 600;
    color: #889;
    display: block;
    margin-bottom: 8px;
}
.detail-info-value {
    font-size: 16px;
    word-wrap: break-word;
}
.detail-info-value.copyable {
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background 0.2s;
    padding: 5px 8px;
    margin: -5px -8px; 
    border-radius: 8px;
}
.detail-info-value.copyable:hover {
    background: rgba(0,0,0,0.05);
}
body.dark-mode .detail-info-value.copyable:hover {
    background: rgba(255,255,255,0.08);
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* =============================================================== */
/* ================= [新增] 手机收藏馆按钮样式 ================= */
/* =============================================================== */
#showNoticeBell {
    display: none; /* 保持默认隐藏，由 JS 控制显示 */
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 16px; /* 缩小字体 */
    font-weight: bold;
    color: #b0b0b0; /* 使用更柔和的灰色 */
    padding: 0 5px; /* 调整内边距 */
    line-height: 1;
    vertical-align: middle; /* 确保与标题垂直对齐 */
    transition: color 0.2s ease;
}
#showNoticeBell:hover {
    color: var(--hold-border); /* 悬停时使用主题高亮色 */
}
body.dark-mode #showNoticeBell {
    color: #666; /* 夜间模式下更暗的灰色 */
}
/* =============================================================== */
/* =============== [新增] 手机收藏馆移动端适配 =============== */
/* =============================================================== */
@media (max-width: 600px) {
    #phoneCollectionModal .list-container {
        padding: 25px 15px; /* 减小左右内边距 */
        gap: 15px; /* 减小泡泡间距 */
    }
    .phone-partition-item {
        width: 85px; /* 减小泡泡尺寸 */
        height: 85px;
    }
    .phone-partition-item .phone-partition-name {
        font-size: 0.8rem; /* 略微减小字体 */
    }
    /* 减小错落效果的幅度 */
    .phone-partition-item:nth-child(odd) {
        transform: translateY(-15px);
    }
    .phone-partition-item:nth-child(even) {
        transform: translateY(15px);
    }
}

/* =============================================================== */
/* ================== [新增] Giscus 主题适配样式 ================= */
/* =============================================================== */

/* 1. 将评论区模态框强制设为全屏 */
#phoneCommentsModal .modal-content {
    width: 100%;
    height: 100%;
    max-width: none;
    max-height: none;
    border-radius: 0;
    border: none;
}

/* 2. 确保 Giscus 的容器正确填充 */
#phoneCommentsModal .modal-body {
    padding: 0;
    flex-grow: 1;
    display: flex;
}

/* 3. ★★★ 终极修复：为 Giscus 组件本身重置外边距和宽度 ★★★ */
#phoneCommentsModal .giscus {
    width: 100% !important;     /* 覆盖通用规则的 calc(100% - 6px) */
    height: 100%;
    margin-left: 0 !important;  /* 覆盖通用规则的 margin-left: 3px */
    margin-right: 0 !important; /* 覆盖通用规则的 margin-right: 3px */
}

/* 4. 保留背景透明适配 */
.giscus-frame {
    background-color: transparent !important;
}

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备忘录代码块 v1.0 样式 ================ */
/* =============================================================== */
.memo-code-block {
    position: relative;
    background-color: rgba(128,128,128,0.1);
    border: 1px solid rgba(128,128,128,0.15);
    border-radius: 8px;
    padding: 12px 15px;
    margin: 10px 0;
    font-family: monospace;
    font-size: 0.9em;
    /* [修改] 移除 white-space 和 word-break，交由 pre 标签处理 */
}

/* [新增] 针对 pre 标签的样式，实现自动换行 */
.memo-code-block pre {
    margin: 0; /* 移除 pre 标签的默认外边距 */
    white-space: pre-wrap; /* 保留空白符序列，但正常地进行换行 */
    word-break: break-all; /* 允许在长单词或 URL 内部中断换行，防止溢出 */
}

.code-block-copy-btn {
    position: absolute;
    top: 6px;
    right: 6px;
    background: rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.15);
    color: inherit;
    padding: 2px 6px;
    border-radius: 5px;
    font-size: 12px;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s, background-color 0.2s;
}
.memo-code-block:hover .code-block-copy-btn {
    opacity: 1;
}
.code-block-copy-btn:hover {
    background-color: rgba(0,0,0,0.2);
}
body.dark-mode .memo-code-block {
    background-color: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.1);
}
body.dark-mode .code-block-copy-btn {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.2);
}
body.dark-mode .code-block-copy-btn:hover {
    background-color: rgba(255,255,255,0.2);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] Giscus 反馈数据展示样式 ============= */
/* =============================================================== */
.giscus-feedback-container {
    margin-top: 20px;
    padding: 12px 15px;
    border-radius: 12px;
    background: rgba(0,0,0,0.03);
    min-height: 48px; /* 给加载状态一个固定高度 */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #889;
    transition: background 0.3s;
}
body.dark-mode .giscus-feedback-container {
    background: rgba(255,255,255,0.04);
}
.giscus-feedback-container.loaded {
    justify-content: space-between; /* 加载成功后两端对齐 */
}
.giscus-reactions, .giscus-comments {
    display: flex;
    align-items: center;
    gap: 8px;
}
.reaction-item {
    display: flex;
    align-items: center;
    gap: 4px;
    background: var(--bg-day-element);
    padding: 3px 8px;
    border-radius: 10px;
    box-shadow: 2px 2px 4px var(--shadow-dark-day), -2px -2px 4px var(--shadow-light-day);
    font-size: 13px;
    font-weight: 500;
}
body.dark-mode .reaction-item {
    background: var(--bg-night-element);
    box-shadow: 2px 2px 4px var(--shadow-dark-night), -2px -2px 4px var(--shadow-light-night);
}
.giscus-comments a {
    text-decoration: none;
    color: var(--hold-border);
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 4px;
}
.giscus-comments a:hover {
    text-decoration: underline;
}
/* =============================================================== */
/* ============== [新增] 手机收藏馆筛选功能样式 =============== */
/* =============================================================== */
.filter-section { margin-bottom: 20px; border-bottom: 1px solid rgba(128, 128, 128, 0.1); padding-bottom: 15px; }
.filter-section:last-of-type { border-bottom: none; margin-bottom: 0px; }
.filter-group-title { font-size: 14px; font-weight: 600; color: rgb(136, 136, 153); margin-bottom: 12px; }
#selected-filters-container { padding: 10px; background: rgba(128, 128, 128, 0.05); border-radius: 10px; min-height: 40px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
.selected-filter-tag { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 16px; font-size: 13px; font-weight: 600; color: white; background-color: var(--hold-border); }
.selected-filter-tag .remove-tag-btn { font-family: sans-serif; font-weight: bold; font-size: 14px; cursor: pointer; line-height: 1; opacity: 0.7; transition: opacity 0.2s ease 0s; }
.selected-filter-tag .remove-tag-btn:hover { opacity: 1; }
.filter-options-grid { display: flex; flex-wrap: wrap; gap: 10px; }
.filter-tag-option { padding: 8px 16px; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; background: var(--bg-day-element); color: var(--text-day); box-shadow: var(--shadow-dark-day) 4px 4px 8px, var(--shadow-light-day) -4px -4px 8px; transition: all 0.2s ease 0s; }
body.dark-mode .filter-tag-option { background: var(--bg-night-element); color: var(--text-night); box-shadow: var(--shadow-dark-night) 4px 4px 8px, var(--shadow-light-night) -4px -4px 8px; }
.filter-tag-option:active { box-shadow: var(--shadow-dark-day) 4px 4px 8px inset, var(--shadow-light-day) -4px -4px 8px inset; }
body.dark-mode .filter-tag-option:active { box-shadow: var(--shadow-dark-night) 4px 4px 8px inset, var(--shadow-light-night) -4px -4px 8px inset; }
.filter-tag-option.selected {
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
    font-weight: 700; /* [新增] 字体加粗 */
    transform: scale(1.05); /* [新增] 整体放大 */
    color: var(--hold-border); /* [新增] 字体颜色高亮 */
}

body.dark-mode .filter-tag-option.selected {
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}

.filter-tag-option[data-group="user"][data-value="owned"] { color: #d69e2e; font-weight: bold; }
.filter-tag-option[data-group="user"][data-value="wishlist"] { color: #C53030; font-weight: bold; }
.filter-tag-option[data-group="user"][data-value="not_owned"] { color: #718096; }


/* [新增] 相册自定义背景样式 */
#memoryModal .album-item.has-custom-bg {
    color: white; /* 强制文字颜色为白色以保证可见性 */
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px; /* 调整内边距，让文字居中 */
}

#memoryModal .album-item.has-custom-bg .folder-name {
    /* 为文字添加边缘阴影，增强在各种背景下的可读性 */
    text-shadow: 0px 0px 4px rgba(0, 0, 0, 0.8), 0px 0px 8px rgba(0, 0, 0, 0.6);
    font-size: 1.1em;
    text-align: center;
}

/* 当有自定义背景时，隐藏图标，并重置信息样式 */
#memoryModal .album-item.has-custom-bg .folder-icon,
#memoryModal .album-item.has-custom-bg .manage-checkbox {
    display: none;
}

#memoryModal .album-item.has-custom-bg .album-info {
    position: absolute;
    bottom: 8px;
    left: 12px;
    font-size: 12px;
    font-weight: bold;
    color: white;
    text-shadow: 0 0 3px rgba(0, 0, 0, 0.7);
    background-color: rgba(0,0,0,0.2);
    padding: 2px 6px;
    border-radius: 4px;
}

/* ===== [新增] 相册排序拖拽把手样式 ===== */
.album-item .sort-handle {
    display: none; /* 默认隐藏 */
    position: absolute;
    top: 8px;
    right: 8px;
    font-size: 24px;   /* 增大图标尺寸 */
    font-weight: bold;
    color: #b0b0b0; /* 淡灰色 */
    cursor: grab;
    padding: 5px;
    z-index: 10;
    transition: color 0.2s, transform 0.2s;
    -webkit-user-select: none; /* 防止拖拽时选中文字 */
    user-select: none;
    line-height: 1; /* 确保垂直居中 */
}

body.dark-mode .album-item .sort-handle {
    color: #777; /* 夜间模式下稍亮的灰色 */
}

/* 管理模式下显示把手 */
.album-item.manage-mode .sort-handle {
    display: block;
}

.album-item .sort-handle:hover {
    color: var(--hold-border); /* 悬停时高亮 */
    transform: scale(1.1);
}

.album-item .sort-handle:active {
    cursor: grabbing;
}

/* =============================================================== */
/* =================== [新增] 功能优化专属样式 =================== */
/* =============================================================== */

/* 1. 更新公告标签的红点 */
.segmented-control label[for="help-tab-2"] {
    position: relative; /* 为红点的绝对定位提供基准 */
}
#update-log-indicator {
    display: none; /* 默认隐藏 */
    position: absolute;
    top: 6px;
    right: 8px;
    width: 8px;
    height: 8px;
    background-color: #e53e3e;
    border-radius: 50%;
    border: 1px solid white;
    box-shadow: 0 0 5px #e53e3e;
}
#update-log-indicator.show {
    display: block; /* 用于JS控制显示 */
}

/* 2. 美化新用户引导弹窗的内容 */
#welcome-modal-content p {
    line-height: 1.7;
    margin-bottom: 12px;
}
#welcome-modal-content ul {
    list-style: none;
    padding-left: 10px;
    margin-bottom: 15px;
}
#welcome-modal-content li {
    margin-bottom: 8px;
    color: #4a5568;
}
body.dark-mode #welcome-modal-content li {
    color: #a0aec0;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 备份提醒设置弹窗专属样式 V3 ============ */
/* =============================================================== */
.time-input-row {
    display: flex;
    align-items: center;
    gap: 8px; /* 减小间距，让布局更紧凑 */
    margin-bottom: 10px; /* 每行之间增加一点垂直间距 */
}
.time-input-row .modal-input {
    flex-grow: 1; /* 核心：让输入框占据所有剩余空间 */
    flex-shrink: 1; /* 允许输入框在空间不足时收缩 */
    min-width: 100px; /* 保证输入框的最小可操作宽度 */
}
.time-action-btn {
    flex-shrink: 0; /* 核心：禁止按钮收缩 */
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 50%;
    background: var(--bg-day-element);
    box-shadow: 2px 2px 4px var(--shadow-dark-day),-2px -2px 4px var(--shadow-light-day);
    color: var(--text-day);
    font-size: 22px;
    font-weight: bold;
    cursor: pointer;
    transition: all .2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}
body.dark-mode .time-action-btn {
    background: var(--bg-night-element);
    box-shadow: 2px 2px 4px var(--shadow-dark-night),-2px -2px 4px var(--shadow-light-night);
    color: var(--text-night);
}
.time-action-btn:active {
    box-shadow: inset 2px 2px 4px var(--shadow-dark-day), inset -2px -2px 4px var(--shadow-light-day);
}
body.dark-mode .time-action-btn:active {
     box-shadow: inset 2px 2px 4px var(--shadow-dark-night), inset -2px -2px 4px var(--shadow-light-night);
}
.time-action-btn.add {
    color: var(--hold-border);
}
.time-action-btn.remove {
    color: #f56565;
}


#backupProjectList .project-checkbox-item {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    padding: 5px;
    border-radius: 6px;
    transition: background-color 0.2s;
}
#backupProjectList .project-checkbox-item:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode #backupProjectList .project-checkbox-item:hover {
    background-color: rgba(255,255,255,0.08);
}

#backupProjectList .project-checkbox-item input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
        /* ===== [修改] 相册照片下载按钮样式 V3 (最终版) ===== */
        #download-photo-btn {
            position: absolute;
            right: 15px; /* 向右移动 */
            bottom: 8px; /* 向下移动 */
            z-index: 20;
            background: transparent; /* 移除背景 */
            border: none;
            color: white;
            font-size: 17px; /* 稍微增大图标尺寸 */
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.7; /* 初始透明度 */
            display: none; /* 默认隐藏，由JS控制显示 */
            padding: 10px; /* 增加点击热区 */
            text-decoration: none;
            -webkit-tap-highlight-color: transparent;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5); /* 为图标增加轻微阴影，增强可读性 */
        }
        #download-photo-btn:hover {
            opacity: 1; /* 悬停时完全显示 */
            transform: scale(1.15); /* 悬停时放大效果更明显 */
        }
        /* ===== [修改结束] ===== */

/* =============================================================== */
/* =============== [新增] 手机收藏馆状态功能样式 =============== */
/* =============================================================== */

/* 状态按钮的弹出菜单容器 */
#phoneStatusMenu {
    position: absolute;
    top: 100%; /* 定位在状态按钮的正下方 */
    left: 50%;
    transform: translateX(-50%) translateY(10px) scale(0.9); /* 初始状态，轻微下移和缩小 */
    display: flex;
    gap: 15px; /* 按钮之间的间距 */
    padding: 8px 12px;
    background: var(--bg-day-element);
    border-radius: 20px; /* 胶囊形状 */
    box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day);
    z-index: 10;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease, transform 0.2s ease;
}
body.dark-mode #phoneStatusMenu {
    background: var(--bg-night-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night);
}

/* 弹出菜单显示时的样式 */
#phoneStatusMenu.show {
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) translateY(5px) scale(1);
}

/* 弹出菜单中的小按钮 */
.status-option-btn {
    width: 36px;
    height: 36px;
    border: none;
    background: transparent;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    transition: transform 0.2s, background-color 0.2s;
}
.status-option-btn:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .status-option-btn:hover {
    background-color: rgba(255,255,255,0.1);
}
.status-option-btn:active {
    transform: scale(0.9);
}

/* 按钮图标颜色 */
.status-option-btn .owned-icon {
    color: #ffc107; /* 黄色 */
}
.status-option-btn .wishlist-icon {
    color: #ff85a2; /* 粉色 */
}

/* "已拥有" 状态的呼吸辉光效果 */
@keyframes breathing-glow {
    0% { box-shadow: 0 0 5px 0px var(--status-color), inset 0 0 3px 0px var(--status-color); }
    50% { box-shadow: 0 0 15px 3px var(--status-color), inset 0 0 5px 1px var(--status-color); }
    100% { box-shadow: 0 0 5px 0px var(--status-color), inset 0 0 3px 0px var(--status-color); }
}

.phone-partition-item.status-owned {
    background: var(--status-color); /* 将背景设为状态颜色 */
    color: black; /* 将文字颜色设为黑色 */
    text-shadow: 0 1px 3px rgba(255,255,255,0.3); /* 为文字添加轻微阴影以增强可读性 */
    animation: float-bubble 6s ease-in-out infinite, breathing-glow 2.5s ease-in-out infinite;
}


/* "愿望单" 状态的实线边框效果 (修正版) */
.phone-partition-item.status-wishlist {
    outline: 2.5px solid var(--status-color);
    outline-offset: 2px; /* 让边框与泡泡之间有一点空隙，更好看 */
}
/* ★★★ 新增：修复磨砂玻璃主题下“已拥有”状态的背景色问题 ★★★ */
body.theme-glass .phone-partition-item.status-owned,
body.theme-glass.dark-mode .phone-partition-item.status-owned {
    background: var(--status-color);
    /* 移除磨砂玻璃主题添加的透明边框，避免颜色冲突 */
    border: none;
}
/* =============================================================== */
/* ============= [新增] 多版本恢复选择器样式 ================ */
/* =============================================================== */
#recovery-versions-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-height: 45vh;
    overflow-y: auto;
    padding: 5px;
    margin: 10px 0;
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15px, black 90%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15px, black 90%, transparent 100%);
}

.recovery-version-item {
    border: 1px solid rgba(128,128,128,0.2);
    border-radius: 10px;
    transition: background-color 0.2s, border-color 0.2s;
    position: relative;
}

.recovery-version-item:has(input:checked) {
    background-color: rgba(91, 153, 226, 0.1);
    border-color: var(--hold-border);
    box-shadow: 0 0 8px rgba(91, 153, 226, 0.3);
}

.recovery-version-item label {
    display: block;
    padding: 12px 18px;
    cursor: pointer;
    line-height: 1.6;
}

.recovery-version-item input[type="radio"] {
    position: absolute;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
}

.version-meta {
    font-size: 14px;
    margin-bottom: 8px;
    font-weight: 600;
}
.version-meta span {
    font-size: 12px;
    font-weight: normal;
    color: #889;
    margin-left: 8px;
}
body.dark-mode .version-meta span {
    color: #a0aec0;
}

.version-summary {
    font-size: 13px;
    color: #5a6778;
    display: flex;
    flex-wrap: wrap;
    gap: 5px 15px; /* 行间距 和 列间距 */
}
body.dark-mode .version-summary {
    color: #c0c6cc;
}

#confirmRecoveryBtn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    color: #9db2c2 !important;
    box-shadow: none !important;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

/* ===== [新增] 相册重命名图标样式 ===== */
#memoryModal .album-item .rename-icon {
    display: none; /* 默认隐藏 */
    position: absolute;
    bottom: 8px;
    right: 12px;
    font-size: 20px;
    font-weight: normal;
    color: #a0aec0; /* 一个柔和的颜色 */
    cursor: pointer;
    padding: 5px;
    z-index: 10;
    transition: color 0.2s, transform 0.2s;
    -webkit-user-select: none;
    user-select: none;
    line-height: 1;
}

body.dark-mode #memoryModal .album-item .rename-icon {
    color: #718096;
}

/* 管理模式下显示 */
#memoryModal .album-item.manage-mode .rename-icon {
    display: block;
}

#memoryModal .album-item .rename-icon:hover {
    color: var(--hold-border);
    transform: scale(1.2);
}

/* 当有自定义背景时，使图标更清晰 */
#memoryModal .album-item.has-custom-bg .rename-icon {
    color: white;
    opacity: 0.7;
    text-shadow: 0 0 3px rgba(0,0,0,0.7);
}
#memoryModal .album-item.has-custom-bg .rename-icon:hover {
    opacity: 1;
}
/* ===== [新增] 长图查看器缩放样式 ===== */
#memoryPhotoViewerOverlay #viewer-img-container {
    cursor: zoom-in; /* 默认显示放大光标 */
}
#viewer-img-container.zoomed-long {
    align-items: flex-start; /* 切换为顶部对齐 */
    overflow-y: auto;        /* 允许垂直滚动 */
    cursor: default;         /* 容器本身恢复默认光标 */
}
#viewer-img-container.zoomed-long #viewer-img {
    max-height: none;        /* 移除最大高度限制 */
    width: 100%;             /* 宽度占满容器 */
    cursor: zoom-out;        /* 图片上显示缩小光标 */
}
/* =============================================================== */
/* ============= [新增] 备忘录文件夹管理图标样式 =============== */
/* =============================================================== */

/* 1. 重命名图标样式 (复用相册样式) */
#memoryModal .folder-item .rename-icon {
    display: none; /* 默认隐藏 */
    position: absolute;
    bottom: 8px;
    right: 12px;
    font-size: 20px;
    font-weight: normal;
    color: #a0aec0;
    cursor: pointer;
    padding: 5px;
    z-index: 10;
    transition: color 0.2s, transform 0.2s;
    -webkit-user-select: none;
    user-select: none;
    line-height: 1;
}

body.dark-mode #memoryModal .folder-item .rename-icon {
    color: #718096;
}

/* 管理模式下显示重命名图标 */
#memoryModal .folder-item.manage-mode .rename-icon {
    display: block;
}

#memoryModal .folder-item .rename-icon:hover {
    color: var(--hold-border);
    transform: scale(1.2);
}

/* 2. 排序拖拽把手样式 (复用相册样式) */
.folder-item .sort-handle.memo-sort-handle {
    display: none; /* 默认隐藏 */
    position: absolute;
    top: 8px;
    right: 8px;
    font-size: 24px;
    font-weight: bold;
    color: #b0b0b0;
    cursor: grab;
    padding: 5px;
    z-index: 10;
    transition: color 0.2s, transform 0.2s;
    -webkit-user-select: none;
    user-select: none;
    line-height: 1;
}

body.dark-mode .folder-item .sort-handle.memo-sort-handle {
    color: #777;
}

/* 管理模式下显示排序把手 */
.folder-item.manage-mode .sort-handle.memo-sort-handle {
    display: block;
}

.folder-item .sort-handle.memo-sort-handle:hover {
    color: var(--hold-border);
    transform: scale(1.1);
}

.folder-item .sort-handle.memo-sort-handle:active {
    cursor: grabbing;
}
/* =============================================================== */
/* ============= [新增] 百度网盘集成专属样式 V1.0 =========== */
/* =============================================================== */

/* 文件夹页面右上角的设置按钮 */
#memoryModal .page-header .baidu-settings-btn {
    font-size: 22px; /* 设置一个合适的大小 */
    padding: 6px;
    margin-left: auto; /* 核心：将按钮推到最右侧 */
}

/* 百度网盘设置弹窗内的账户列表 */
#baidu-account-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 250px;
    overflow-y: auto;
    border-radius: 10px;
    padding: 10px;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}
body.dark-mode #baidu-account-list {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}

.baidu-account-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 15px;
    border-radius: 8px;
    transition: background-color 0.2s;
    gap: 15px;
}

.baidu-account-item:hover {
    background-color: rgba(0,0,0,0.05);
}
body.dark-mode .baidu-account-item:hover {
    background-color: rgba(255,255,255,0.08);
}

.baidu-account-info {
    display: flex;
    align-items: center;
    gap: 10px;
}

.baidu-account-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #ccc;
}

.baidu-account-name {
    font-weight: 600;
}

#baidu-auth-status {
    font-size: 14px;
    color: #889;
    text-align: center;
    margin-top: 15px;
    min-height: 20px;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* ========================================================================= */
/* ============= [重构] 备忘录工具栏 & 字号滑块 V3.0 最终样式 ===== */
/* ========================================================================= */


/* 2. 统一所有按钮样式 */
.memo-toolbar .toolbar-btn {
    font-size: 20px;
    font-weight: 600; /* 统一字重为 600，视觉效果更和谐 */
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    font-style: normal;
    text-decoration: none;
    padding: 8px; /* 增加点击热区，确保图标显示完整 */
    flex-shrink: 0; /* 防止按钮在空间不足时被压缩 */
}

/* 3. 特殊按钮样式微调 */
.toolbar-btn.strikethrough {
    text-decoration: line-through;
}
.toolbar-btn[data-command="italic"] {
    font-style: italic; /* 恢复斜体按钮的视觉样式 */
}
.toolbar-btn.font-size-icon {
    line-height: 1; /* 确保AA图标垂直居中 */
}
.font-size-icon small {
    font-size: 0.7em;
    vertical-align: 1px;
    margin-left: -2px;
}

/* 4. 全新设计的字号滑块弹窗 */
#fontSizeSliderPopup {
    position: absolute;
    bottom: 85px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    padding: 8px 15px;
    background: rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.5);
    border-radius: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    z-index: 250;
    transition: opacity 0.2s, transform 0.2s;
}

body.dark-mode #fontSizeSliderPopup {
    background: rgba(30, 30, 30, 0.5);
    border-color: rgba(255, 255, 255, 0.15);
}

/* 5. 美化滑块本身 */
#fontSizeSliderPopup input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    background: rgba(128, 128, 128, 0.2);
    border-radius: 3px;
    outline: none;
    padding: 0;
    margin: 5px 0;
}

#fontSizeSliderPopup input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    border: 1px solid rgba(0,0,0,0.1);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

body.dark-mode #fontSizeSliderPopup input[type="range"]::-webkit-slider-thumb {
    background: #e0e6f0;
    border-color: transparent;
}
/* =============================================================== */
/* ============= [最终修正] 备忘录一键回顶按钮样式 V6.0 ========= */
/* =============================================================== */
.memo-fab-back-to-top {
    position: absolute;
    right: 25px;
    bottom: 75px;
    z-index: 210;

    width: 20px;
    height: 20px;
    
    background: var(--bg-day-element);
    color: var(--hold-border); /* 图标颜色将传递给内部的span */
    box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day);
    
    border: none;
    border-radius: 50%;
    cursor: pointer;
    
    display: flex;
    align-items: center;
    justify-content: center;

    opacity: 0;
    transform: scale(0.8) translateY(10px); /* 恢复按钮本身的动画，移除旋转 */
    pointer-events: none;
    transition: opacity 0.3s ease, transform 0.3s ease;
}

/* ★★★ 新增：只旋转图标本身 ★★★ */
.back-to-top-icon {
    display: inline-block; /* 使 transform 生效 */
    transform: rotate(-90deg); /* 核心：只将图标逆时针旋转90度 */
    font-size: 13px;
    line-height: 1;
    padding-left: 1px; /* 旋转后微调位置 */
}

/* ★★★ 修正：按钮显示时的动画（移除旋转） ★★★ */
.memo-fab-back-to-top.show {
    opacity: 1;
    transform: scale(1) translateY(0); /* 恢复正确的显示动画 */
    pointer-events: auto;
}

.memo-fab-back-to-top.show {
    opacity: 1;
    transform: scale(1) translateY(0); /* 显示时恢复正常大小和位置 */
    pointer-events: auto;
}

.memo-fab-back-to-top:active {
    box-shadow: inset 2px 2px 4px var(--shadow-dark-day), inset -2px -2px 4px var(--shadow-light-day);
    transform: scale(0.95) !important;
}

/* 夜间模式适配 */
body.dark-mode .memo-fab-back-to-top {
    background: var(--bg-night-element);
    color: var(--text-night);
    box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night);
}

body.dark-mode .memo-fab-back-to-top:active {
    box-shadow: inset 2px 2px 4px var(--shadow-dark-night), inset -2px -2px 4px var(--shadow-light-night);
}

/* 磨砂玻璃主题适配 */
body.theme-glass .memo-fab-back-to-top {
    background: rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px 15px 0 rgba(0, 0, 0, 0.1);
}

body.theme-glass.dark-mode .memo-fab-back-to-top {
    background: rgba(20, 20, 20, 0.4);
    border-color: rgba(255, 255, 255, 0.1);
}
/* =============================================================== */
/* ================ [新增] 摇摆挂件及设置弹窗样式 ================= */
/* =============================================================== */

/* 1. 挂件容器定位 (V2 - 全局固定定位) */
#pendant-container {
    position: fixed;    /* [核心修改] 改为固定定位，相对于视口 */
    top: 0;             /* [核心修改] 初始 top 为 0，将由JS动态设置 */
    right: 15%;         /* 水平位置保持不变 */
    width: 50px;        /* 容器宽度 */
    height: 100vh;      /* [核心修改] 高度占满整个屏幕，确保长绳子不会溢出 */
    pointer-events: none; /* 保持事件穿透特性 */
    z-index: 5;         /* [核心修改] 调整层级，使其在大部分内容之上，但在弹窗之下 */
    transition: top 0.3s ease; /* [新增] 当窗口大小变化时，可以平滑过渡 */
}

/* 2. 动画效果 (基本复用原代码) */
#pendant-container .all-wrap {
    /* 引入变量以便JS修改 */
    --bob-amount: -20px;
    --anim-duration: 7s;
    animation: bob var(--anim-duration) cubic-bezier(0.5, 0, 0.5, 1) infinite both;
}
#pendant-container .all {
    position: relative;
    transform-origin: center top; /* 线的顶端为摇摆支点 */
    animation: swing var(--anim-duration) cubic-bezier(0.5, 0, 0.5, 1) infinite both;
}

/* 3. 绳子样式 (可由JS修改) */
#pendant-container .all::before {
    content: "";
    /* 引入CSS变量，方便JS动态修改 */
    height: var(--line-length, 5rem); 
    width: 2px;
    background-color: var(--line-color, #000); 
    position: absolute;
    left: 50%;
    top: 0; 
    transform: translateX(-50%);
}

/* 4. 挂件图案样式 (可点击) */
#pendant-shape {
    display: block; /* 确保transform生效 */
    position: absolute;
    /* 核心：top值与绳子长度变量绑定，确保始终连接 */
    top: var(--line-length, 5rem);
    left: 50%;
    transform: translateX(-50%);
    transform-origin: top center;
    cursor: pointer; /* 鼠标变为手型，提示可点击 */
    z-index: 20;      /* 确保图案在最前面，可以被点击 */
    -webkit-tap-highlight-color: transparent; /* 移除移动端点击高亮 */
    pointer-events: auto; /* [核心修改] 让图案本身可以接收鼠标事件 */
}


#pendant-shape img {
    width: 50px;
    height: auto;
    vertical-align: top; /* 消除图片底部空隙 */
}

#pendant-shape .emoji {
    font-size: 40px; /* 如果是emoji，调整大小 */
    line-height: 1;
}

/* 5. 动画关键帧 (复用原代码) */
@keyframes swing {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(15deg); }
    75% { transform: rotate(-15deg); }
}
@keyframes bob {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(var(--bob-amount)); }
}

/* 6. 挂件设置弹窗样式 (V2 - 固定高度布局) */
#pendant-settings-modal {
    z-index: 1005; 
}
#pendant-settings-modal .modal-content {
    max-width: 420px; /* 稍微加宽以容纳内容 */
    height: 90vh; /* 关键：设置一个相对于视口的高度 */
    max-height: 650px; /* 关键：在超长屏幕上限制最大高度 */
    display: flex; /* 关键：启用flexbox布局 */
    flex-direction: column; /* 关键：设置主轴为垂直方向 */
}
#pendant-settings-modal .modal-body {
    /* display, flex-direction, gap等属性已在下方.widget-hub-page相关规则中定义，此处无需重复 */
}

.pendant-settings-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.pendant-settings-group label {
    font-size: 14px;
    color: #5a6778;
    font-weight: 600;
}
body.dark-mode .pendant-settings-group label {
    color: #c0c6cc;
}
.pendant-settings-group .slider-container {
    display: flex;
    align-items: center;
    gap: 15px;
}
.pendant-settings-group input[type="range"] {
    flex-grow: 1;
}
.pendant-settings-group .slider-value {
    font-size: 14px;
    font-weight: 500;
    min-width: 3em; /* 保证宽度，防止跳动 */
    text-align: right;
}
/* =============================================================== */
/* ============= [新增] 挂件设置悬浮窗升级样式 V1.0 =========== */
/* =============================================================== */

/* 重构 modal-body 以支持页面切换 */
#pendant-settings-modal .modal-body {
    padding: 15px 15px 80px 15px; /* 关键：为底部胶囊栏留出空间 */
    position: relative; /* 为页面切换容器提供定位基准 */
    overflow: hidden; /* 隐藏页面切换时的溢出 */
}

/* 页面容器的样式 (修正版) */
.widget-hub-page {
    /* 移除了 position: absolute 和相关的 top/left/right/bottom */
    width: 100%;
    height: 100%;
    display: none; /* 默认隐藏所有页面 */
    flex-direction: column;
    gap: 20px;
    overflow-y: auto; /* 当页面内容过多时，允许独立滚动 */
    padding-right: 5px; /* 为滚动条留出空间，防止内容挤压 */
    padding-left: 0px;
    margin-right: -5px;
    opacity: 0;
    transform: translateX(10px);
    transition: opacity 0.3s ease, transform 0.3s ease;
    /* 新增：让 flex 容器在内容不足时也不会收缩 */
    flex-grow: 1;
}

/* 活动页面的显示样式 */
.widget-hub-page.active {
    display: flex; /* 改为 flex 以便内部布局 */
    opacity: 1;
    transform: translateX(0);
}

/* [新增] 底部悬浮胶囊导航栏 */
#widget-hub-capsule {
    position: absolute;
    bottom: 15px;
    left: 1px;
    right: 15px;
    height: 50px;
    background: var(--bg-day-element);
    border-radius: 30px; /* 胶囊形状 */
    box-shadow: 0 5px 15px rgba(0,0,0,0.1),
                inset 2px 2px 4px var(--shadow-dark-day),
                inset -2px -2px 4px var(--shadow-light-day);
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 0 10px;
    z-index: 10;
    transition: all 0.3s ease;
}
body.dark-mode #widget-hub-capsule {
    background: var(--bg-night-element);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2),
                inset 2px 2px 4px var(--shadow-dark-night),
                inset -2px -2px 4px var(--shadow-light-night);
}
body.theme-glass #widget-hub-capsule {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
}
body.theme-glass.dark-mode #widget-hub-capsule {
    background: rgba(20, 20, 20, 0.35);
    border-color: rgba(255, 255, 255, 0.15);
}


/* 胶囊内的按钮样式 */
.capsule-btn {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 20px; /* 为了点击效果 */
    padding: 6px 0;
    transition: background-color 0.2s, transform 0.2s, color 0.3s;
    color: #889; /* 默认图标和文字颜色 */
}

/* 按钮内的SVG图标样式 */
.capsule-btn svg {
    width: 20px;
    height: 20px;
    transition: transform 0.3s ease;
}
body.dark-mode .capsule-btn, body.dark-mode .capsule-btn span {
    color: #a0aec0;
}
.capsule-btn:not(.active) svg path,
.capsule-btn:not(.active) svg rect {
    fill: #889 !important; /* 强制未激活的图标为灰色 */
}
body.dark-mode .capsule-btn:not(.active) svg path,
body.dark-mode .capsule-btn:not(.active) svg rect {
    fill: #a0aec0 !important; /* 夜间模式未激活的图标颜色 */
}


/* 按钮内的文字样式 */
.capsule-btn span {
    font-size: 11px;
    font-weight: 600;
}

/* 激活状态的按钮样式 */
.capsule-btn.active {
    color: var(--hold-border); /* 激活时文字颜色高亮 */
    font-weight: 700;
}
.capsule-btn.active svg {
    transform: scale(1.1); /* 激活时图标放大 */
}
.capsule-btn.active svg path,
.capsule-btn.active svg rect {
    fill: var(--hold-border) !important; /* 激活时图标颜色高亮 */
}

/* 按钮点击效果 */
.capsule-btn:active {
    transform: scale(0.95);
}

/* 占位符样式 */
.placeholder-content {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    font-size: 18px;
    color: #ccc;
    font-weight: 600;
    user-select: none;
}
body.dark-mode .placeholder-content {
    color: #666;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ================ [新增] 使用时长排行榜专属样式 ================ */
/* =============================================================== */

/* 排行榜列表容器 */
#usage-leaderboard-list {
    list-style: none; /* 移除默认的数字列表样式 */
    padding: 0;
    margin: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* 每个排行榜项目 */
.leaderboard-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 12px 15px;
    border-radius: 12px;
    background: var(--bg-day-element);
    box-shadow: inset 3px 3px 6px var(--shadow-dark-day), inset -3px -3px 6px var(--shadow-light-day);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

body.dark-mode .leaderboard-item {
    background: var(--bg-night-element);
    box-shadow: inset 3px 3px 6px var(--shadow-dark-night), inset -3px -3px 6px var(--shadow-light-night);
}

/* [新增] 使用时长项目在磨砂玻璃主题下的样式 */
body.theme-glass .leaderboard-item {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow: none; /* 移除拟态的内阴影 */
}

body.theme-glass.dark-mode .leaderboard-item {
    background: rgba(10, 10, 10, 0.2);
    border-color: rgba(255, 255, 255, 0.1);
}

/* 排名徽章 */
.leaderboard-rank {
    flex-shrink: 0;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: var(--bg-day-element);
    box-shadow: 3px 3px 6px var(--shadow-dark-day), -3px -3px 6px var(--shadow-light-day);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 700;
    color: var(--hold-border);
}
body.dark-mode .leaderboard-rank {
    background: var(--bg-night-element);
    box-shadow: 3px 3px 6px var(--shadow-dark-night), -3px -3px 6px var(--shadow-light-night);
}
/* 前三名特殊样式 */
.leaderboard-rank.rank-1 { background-color: #ffd700; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.leaderboard-rank.rank-2 { background-color: #c0c0c0; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.leaderboard-rank.rank-3 { background-color: #cd7f32; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }


/* 项目信息 */
.leaderboard-info {
    flex-grow: 1;
    min-width: 0; /* 防止内容溢出时撑开布局 */
    text-align: left;
}
.leaderboard-info-name {
    font-size: 16px;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.leaderboard-info-time {
    font-size: 13px;
    color: #889;
    margin-top: 4px;
}
body.dark-mode .leaderboard-info-time {
    color: #a0aec0;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* =============== [新增] 签到翻转日历专属样式 ================= */
/* =============================================================== */

/* 整体容器尺寸和3D变换准备 */
.calendar-flipper {
    /* [核心修正] 使用相对单位和 aspect-ratio 实现动态缩放 */
    width: 85%; /* 宽度为父容器的85% */
    max-width: 350px; /* 但最大不超过350px，保证在大屏幕上不会过大 */
    aspect-ratio: 1 / 1.1; /* 强制保持微调后的比例，给标题留出空间感 */
    height: auto; /* 高度自动计算以匹配宽度 */
    
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.7s cubic-bezier(0.4, 0, 0.2, 1);
    perspective: 1000px; /* 增加透视，使3D效果更明显 */
}

/* 翻转后的状态 */
.calendar-flipper.flipped {
    transform: rotateY(180deg);
}

/* 正面和背面的通用样式 */
.calendar-front, .calendar-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden; /* 隐藏翻转到背后的那一面 */
    -webkit-backface-visibility: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    transform: translateZ(1px); 
}

/* 背面默认旋转180度 */
.calendar-back {
    transform: rotateY(180deg) translateZ(1px);
}


/* 复用并调整您原有的日历样式 */
.calendar {
    width: 100%; 
    height: 100%;
    border-radius: 18px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.18);
    position: relative;
    overflow: hidden;
    background-color: #fff;
    font-family: 'Arial', sans-serif;
}
.calendar-header {
    width: 100%;
    height: 18%;
    max-height: 60px;
    background-color: #8B4513;
    /* [V2 修复] 使用 inset box-shadow 替代 border-bottom 来创建动态颜色分界线 */
    box-shadow: inset 0 -3px 0 0 rgba(0, 0, 0, 0.15);
    position: absolute;
    top: 0;
    left: 0;
    z-index: 3;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #fff;
    font-size: clamp(16px, 6vw, 22px);
    font-weight: 500;
    letter-spacing: 1px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.calendar-header:hover {
    background-color: #a0522d;
}
.calendar-date-current {
    width: 100%;
     /* [核心修正] 使用百分比高度 */
    height: 82%;
    position: absolute;
    bottom: 0; left: 0;
    background-color: #fff;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: grab;
    box-shadow: 0 6px 12px rgba(0,0,0,0.12);
    transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1.2);
    z-index: 2;
}
.calendar-date-current:active { cursor: grabbing; }
.calendar-date-next {
    width: 100%;
    /* [核心修正] 使用百分比高度 */
    height: 82%;
    position: absolute;
    bottom: 0; left: 0;
    background-color: #fff;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    box-shadow: 0 3px 8px rgba(0,0,0,0.09);
    z-index: 1;
}
.date-number {
    /* [核心修正] 调整 clamp() 参数以获得更好的缩放效果 */
    font-size: clamp(50px, 28vw, 110px);
    font-weight: bold;
    color: #333;
    line-height: 1;
}
.date-full {
    /* [核心修正] 调整 clamp() 参数 */
    font-size: clamp(12px, 4vw, 16px);
    color: #666;
    margin-top: 10px;
    letter-spacing: 0.5px;
}


/* 月度日历的样式 */
.monthly-calendar {
    width: 100%;
    height: 100%;
    padding: 15px;
    border-radius: 18px;
    background: #fff;
    box-shadow: 0 10px 25px rgba(0,0,0,0.18);
    display: flex;
    flex-direction: column;
}
.monthly-calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}
.monthly-calendar-header span {
    /* [核心修正] 动态字体 */
    font-size: clamp(16px, 5vw, 18px);
    font-weight: 600;
}
.monthly-calendar-header button {
    background: transparent;
    border: none;
    /* [核心修正] 动态字体 */
    font-size: clamp(18px, 5.5vw, 20px);
    cursor: pointer;
    padding: 5px 10px;
    border-radius: 8px;
    transition: background-color 0.2s;
}

.monthly-calendar-header button:hover { background-color: #f0f0f0; }
#monthly-calendar-table { width: 100%; flex-grow: 1; border-collapse: collapse; }
#monthly-calendar-table th, #monthly-calendar-table td {
    text-align: center;
    padding: 2px; /* 减小内边距以适应小屏幕 */
    /* [核心修正] 动态字体 */
    font-size: clamp(11px, 3.5vw, 14px);
}

#monthly-calendar-table th { color: #aaa; font-weight: normal; }
#monthly-calendar-table td { position: relative; height: 14.28%; }
/* 当天日期的小圆点样式 */
#monthly-calendar-table td.today::after {
    content: '';
    position: absolute;
    bottom: 4px; /* 调整位置 */
    left: 50%;
    transform: translateX(-50%);
    width: clamp(4px, 1.2vw, 6px); /* [核心修正] 小圆点也动态缩放 */
    height: clamp(4px, 1.2vw, 6px);
    background-color: #63b3ed;
    border-radius: 50%;
}
#monthly-calendar-table td.other-month { color: #ccc; }
/* 已打卡的淡蓝色圆形背景样式 */
#monthly-calendar-table td.checked-in {
    background-color: #e3f2fd; color: #1565c0; font-weight: bold; border-radius: 50%;
}

        /* [新增] 用于控制挂件显隐的CSS类 */
        .pendant-hidden {
            display: none !important;
        }
/* =============================================================== */
/* =============== [新增] 签到提醒摇摆挂件样式 ================= */
/* =============================================================== */

@keyframes remind-shake {
  0%, 100% {
    transform: rotate(0);
  }
  10%, 30%, 50%, 70%, 90% {
    transform: rotate(4deg);
  }
  20%, 40%, 60%, 80% {
    transform: rotate(-4deg);
  }
}


#pendant-all-wrap.remind-active {
  /* 使用 `!important` 来确保此动画会覆盖默认的 'bob' 动画 */
  animation: remind-shake 1.5s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite both !important;
}
/* =============================================================== */
/* ============= [新增] 备忘录导入文件名列表样式 ============= */
/* =============================================================== */
.memo-import-filename {
    font-size: 12px;
    color: #889;
    padding: 3px 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
body.dark-mode .memo-import-filename {
    color: #a0aec0;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ================== [新增] 留言板专属样式 V2 ================== */
/* =============================================================== */

#message-board-container {
    padding: 15px;
    display: flex; /* 改为 flex 布局 */
    flex-direction: column; /* 垂直排列 */
    gap: 15px; /* 卡片间距 */
    height: 100%;
    overflow-y: auto;
}

.message-card {
    min-height: 110px; /* [需求修改] 加大卡片高度 */
    width: 100%;
    padding: 15px;
    border-radius: 16px;
    background: var(--bg-day-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-day), -4px -4px 8px var(--shadow-light-day);
    color: var(--text-day);
    display: flex;
    flex-direction: column;
    justify-content: center;
    cursor: grab;
    transition: background-color 0.3s ease, opacity 0.3s ease;
    overflow: hidden;
    position: relative;
    user-select: none;
    touch-action: pan-y;
}

body.dark-mode .message-card {
    background: var(--bg-night-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-night), -4px -4px 8px var(--shadow-light-night);
    color: var(--text-night);
}
.message-card.swiping {
    cursor: grabbing; /* 滑动时变为抓紧手势 */
    transition: none; /* 滑动时移除过渡效果，确保实时响应 */
}

.message-card-content-wrapper {
    display: flex;
    flex-direction: column;
    gap: 10px; /* 内部元素间距 */
}

.message-card--add {
    min-height: 60px;
    background: transparent;
    border: 2px dashed rgba(128, 128, 128, 0.4);
    box-shadow: none;
    flex-direction: row; /* 水平排列图标和文字 */
    align-items: center;
    justify-content: center;
    gap: 10px;
    cursor: pointer;
}
.message-card--add svg {
    width: 24px;
    height: 24px;
    fill: rgba(128, 128, 128, 0.5);
    transition: transform 0.3s ease;
}
.message-card--add:hover svg {
    transform: scale(1.1);
}
.message-card--add span {
    font-size: 16px;
    color: rgba(128, 128, 128, 0.7);
    font-weight: 600;
}

.message-card.completed {
    opacity: 0.6;
    background: #e9ecef;
}
body.dark-mode .message-card.completed {
    background: #2d3748;
}

.message-card-header {
    /* [需求修改] 使用 flex 布局实现左右对齐 */
    display: flex;
    justify-content: space-between; /* 核心：两端对齐 */
    align-items: center; /* 垂直居中 */
    gap: 15px; /* 标题和链接之间的最小间距 */
    width: 100%;
}
.message-card-time {
    /* 保持隐藏 */
    display: none;
}
.message-card-title {
    /* [需求修改] 再次增大字号并改为左对齐 */
    font-size: 28px;
    font-weight: 700;
    text-align: left; /* 靠左显示 */
    word-break: break-word;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    /* [新增] 确保标题不会被链接挤压 */
    flex-grow: 1;
    min-width: 0;
}

.message-card-link-info {
    /* [需求修改] 调整链接样式并使其靠右 */
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px; /* 稍微增大字体 */
    font-weight: 600; /* 加粗 */
    color: #889;
    background-color: rgba(128,128,128,0.08);
    padding: 6px 12px; /* 调整内边距 */
    border-radius: 8px;
    /* [移除] margin-left/right: auto，因为父元素已经是 flex 布局 */
    margin-top: 5px;
    max-width: 50%; /* 限制最大宽度，防止过长 */
    flex-shrink: 0; /* 防止被标题挤压 */
     white-space: nowrap; /* [新增] 确保内容不换行 */
}

.message-card-link-info .link-icon {
    /* [需求修改] 隐藏 "链接" 文字 */
    display: none;
}
.message-card-link-info .link-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 弹窗内 segmented-control 样式 */
#messageBoardModal .segmented-control .slider-indicator { 
    width: calc(33.33% - 4px); 
}
#messageBoardModal input[type="radio"]:checked + label { 
    color: var(--hold-border); 
}
#reminder-type-daily:checked ~ .slider-indicator { transform: translateX(100%); }
#reminder-type-periodic:checked ~ .slider-indicator { transform: translateX(200%); }

/* [核心修复] 提升留言板编辑弹窗的层级 */
#messageBoardModal.modal-overlay {
    z-index: 1010; /* 设置一个比挂件中心(1005)更高的值 */
}

/* [新增修复] 强制提高弹窗内容区域的不透明度，彻底解决重叠问题 */
#messageBoardModal .modal-content {
    /* 使用一个完全不透明的背景颜色，覆盖所有主题（包括磨砂玻璃）的半透明设置 */
    background-color: var(--day-color1);
    /* 既然背景不透明，就不再需要背景模糊效果了 */
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

body.dark-mode #messageBoardModal .modal-content {
    /* 适配夜间模式下的不透明背景色 */
    background-color: var(--night-color2);
}

/* [核心修复] 提升留言板编辑弹窗的层级 */
#messageBoardModal.modal-overlay {
    z-index: 1010; /* 设置一个比挂件中心(1005)更高的值 */
}


/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* ============= [新增] 视频预览标识样式 V1.0 ============= */
.photo-item .video-indicator,
.photo-item-set .video-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 44px;
    height: 44px;
    background-color: rgba(0, 0, 0, 0.4);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 4; /* 确保在图片之上，但在标题之下 */
    pointer-events: none; /* 确保图标不影响点击 */
    transition: opacity 0.3s ease;
}

.photo-item-set .video-indicator {
    z-index: 6; /* 在照片集中，层级需要更高 */
}

/* 鼠标悬停时，图标可以稍微变淡，避免过度干扰 */
.photo-item:hover .video-indicator,
.photo-item-set:hover .video-indicator {
    opacity: 0.8;
}

.video-indicator svg {
    /* 直接使用你提供的SVG尺寸 */
    width: 22px;
    height: 22px;
}

/* 为你提供的SVG图标设置描边颜色为白色，确保清晰可见 */
.video-indicator svg path {
    stroke: #ffffff;
}
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* ============= [新增] 文件标签功能专属样式 ================ */
/* =============================================================== */

/* 标签功能按钮容器 */
.tag-actions-container {
    display: flex;
    gap: 10px;
    margin-bottom: 0px; /* [修改] 减小与下方文件列表的间距 */
    padding: 5px;
    border-radius: 12px;
    background: var(--bg-day-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-day), inset -4px -4px 8px var(--shadow-light-day);
}

body.dark-mode .tag-actions-container {
    background: var(--bg-night-element);
    box-shadow: inset 4px 4px 8px var(--shadow-dark-night), inset -4px -4px 8px var(--shadow-light-night);
}
body.theme-glass .tag-actions-container {
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow: none;
}
body.theme-glass.dark-mode .tag-actions-container {
     background: rgba(10, 10, 10, 0.2);
     border-color: rgba(255, 255, 255, 0.1);
}


.tag-actions-container .tag-action-btn {
    flex-grow: 1;
    box-shadow: none;
    font-size: 14px;
    padding: 10px 5px;
    color: #5a6778;
    background: transparent;
}
body.dark-mode .tag-actions-container .tag-action-btn {
    color: #c0c6cc;
}

.tag-actions-container .tag-action-btn:active {
    background: rgba(0,0,0,0.05);
    box-shadow: none;
}
body.dark-mode .tag-actions-container .tag-action-btn:active {
    background: rgba(255,255,255,0.08);
}


/* 文件列表中的标签容器 */
.file-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    margin-top: 8px;
    margin-left: 10px; /* 与文件名对齐 */
}

/* 单个标签样式 */
.file-tag-item {
    background-color: rgba(128, 128, 128, 0.1);
    color: #889;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 11px;
    font-weight: 600;
}
body.dark-mode .file-tag-item {
    background-color: rgba(255, 255, 255, 0.1);
    color: #a0aec0;
}

/* 标签管理模态框内的列表项 */
#tag-list-editor .tag-editor-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 8px;
    background: rgba(0,0,0,0.03);
    transition: background-color 0.2s;
}
#tag-list-editor .tag-editor-item:hover {
    background: rgba(0,0,0,0.06);
}
body.dark-mode #tag-list-editor .tag-editor-item {
    background: rgba(255,255,255,0.04);
}
body.dark-mode #tag-list-editor .tag-editor-item:hover {
    background: rgba(255,255,255,0.08);
}

.tag-editor-item .tag-name {
    flex-grow: 1;
    font-weight: 600;
    cursor: pointer;
}

.tag-editor-item .tag-actions button {
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 18px;
    padding: 4px 8px;
    border-radius: 50%;
    transition: background-color 0.2s;
}
.tag-editor-item .tag-actions button:hover {
    background-color: rgba(0,0,0,0.1);
}
.tag-editor-item .tag-actions .delete {
    color: #f56565;
}

/* 批量绑定模式下的文件列表项 */
#cloud-drive-section.tag-binding-active #fileList li {
    padding-left: 45px; /* 为复选框留出空间 */
    cursor: pointer;
}
#cloud-drive-section.tag-binding-active #file-list-container li .delete-btn {
    display: none; /* 批量模式下隐藏单个删除按钮 */
}

/* 批量绑定的复选框 */
.file-manage-checkbox {
    position: absolute;
    top: 50%;
    left: 15px;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    accent-color: var(--hold-border); /* 让复选框颜色跟随主题 */
    display: none; /* 默认隐藏 */
}
/* [新增] 当标签批量绑定栏激活时，为文件列表增加底部内边距，防止遮挡 */
#cloud-drive-section.tag-binding-active #file-list-container {
    padding-bottom: 70px; /* 留出足够的高度给底部的操作栏 */
    transition: padding-bottom 0.3s ease;
}

#cloud-drive-section.tag-binding-active .file-manage-checkbox {
    display: block; /* 批量模式下显示 */
}

/* 文件被选中时的边框高亮 */
#file-list-container li.manage-selected {
    background-color: rgba(91, 153, 226, 0.1);
    border: 1px solid var(--hold-border);
}
body.dark-mode #file-list-container li.manage-selected {
    background-color: rgba(99, 179, 237, 0.1);
}

/* 按标签查看模态框的结果列表 */
#tagged-files-result-container ul {
    list-style: none;
    padding: 0;
}
#tagged-files-result-container li {
    padding: 12px 15px;
    border-radius: 8px;
    margin-bottom: 8px;
    background: rgba(0,0,0,0.03);
}
body.dark-mode #tagged-files-result-container li {
    background: rgba(255,255,255,0.04);
}
#tagged-files-result-container .tagged-file-name {
    font-weight: 600;
}
#tagged-files-result-container .tagged-file-project {
    font-size: 12px;
    color: #889;
    margin-top: 4px;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 文件标签布局专属样式 V2 ============ */
/* =============================================================== */
#fileList li .file-info {
    display: flex; /* 让 file-info 成为 flex 容器 */
    flex-direction: column; /* 内部元素垂直排列 */
    justify-content: center; /* 垂直居中 */
    gap: 6px; /* 文件名和下面一行的间距 */
}

.file-main-info {
    /* 这一层不是必需的，但在复杂布局下有助于分组 */
}

/* 核心：包裹元信息和标签的容器 */
.file-meta-tags-wrapper {
    display: flex;
    align-items: baseline; /* [修改] 将垂直居中改为基线对齐，视觉效果更和谐 */
    gap: 10px; /* 元信息和标签组之间的间距 */
    flex-wrap: wrap; /* 如果标签太多，允许换行 */
}

/* 之前修改的 .file-tags，现在它是一个 span */
.file-tags {
    display: inline-flex; /* 让它表现得像 flex 容器但又是行内元素 */
    flex-wrap: wrap;
    gap: 6px; /* 标签与标签之间的间距 */
    align-items: center;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* ============= [重构] 可向下展开的标签栏样式 V2.1 (水平排列) ================ */
.upload-actions-row {
    display: flex;
    gap: 10px;
    align-items: center;
}

.tag-actions-toggle-btn {
    flex-shrink: 0;
    width: 44px; /* 调整为与上传按钮同高 */
    height: 44px;
    padding: 12px; /* 调整内边距让图标居中 */
    border: none;
    border-radius: 12px;
    background: var(--bg-day-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-day),-4px -4px 8px var(--shadow-light-day);
    color: var(--text-day);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all .2s ease;
}
body.dark-mode .tag-actions-toggle-btn {
    background: var(--bg-night-element);
    box-shadow: 4px 4px 8px var(--shadow-dark-night),-4px -4px 8px var(--shadow-light-night);
    color: var(--text-night);
}
.tag-actions-toggle-btn:active {
    box-shadow: inset 2px 2px 4px var(--shadow-dark-day), inset -2px -2px 4px var(--shadow-light-day);
}
body.dark-mode .tag-actions-toggle-btn:active {
    box-shadow: inset 2px 2px 4px var(--shadow-dark-night), inset -2px -2px 4px var(--shadow-light-night);
}
.tag-actions-toggle-btn.expanded svg {
    transform: rotate(90deg); /* 当按钮本身有 .expanded 类时旋转图标 */
}
.tag-actions-toggle-btn svg {
    transition: transform 0.3s ease; /* 给图标旋转增加动画 */
}

.upload-actions-row #uploadBtn {
    flex-grow: 1; /* 让上传按钮占据剩余空间 */
}

/* [核心修改] 调整为水平排列并实现向下展开动画 */
#tag-actions-wrapper {
    display: flex;
    flex-direction: row; /* [修改] 改为水平排列 */
    justify-content: space-between; /* [新增] 按钮之间均匀分布 */
    gap: 8px; /* [新增] 按钮之间的间隙 */
    overflow: hidden;
    transition: max-height 0.4s ease, opacity 0.3s ease, margin-top 0.4s ease;
    max-height: 0;
    opacity: 0;
    margin-top: -30px; /* [核心修改] 收起时，使用-15px的负外边距来抵消父容器的gap间隙 */
}

#tag-actions-wrapper.expanded {
    max-height: 60px; /* [修改] 调整为按钮的高度 + padding */
    opacity: 1;
    margin-top: 1px; /* [核心修改] 展开时，恢复15px的顶部外边距，保持与其他元素的间距 */
}

#tag-actions-wrapper .tag-action-btn {
    flex: 1; /* [修改] 让每个按钮平分可用空间 */
    white-space: nowrap; /* 防止按钮内文字换行 */
    overflow: hidden;
    text-overflow: ellipsis; /* 如果空间不足，用省略号代替 */
    padding: 10px 5px; /* [修改] 调整内边距，使按钮更窄 */
    font-size: 13px; /* [可选] 也可以稍微减小字体大小 */
}
/* =============================================================== */
/* =============================================================== */
/* ============= [新增] 标签绑定设置栏移动端优化 V1.0 ======= */
/* =============================================================== */

/* 缩小整个操作栏的上下内边距 */
#tag-binding-controls {
    padding-top: 10px;
    padding-bottom: 10px;
    gap: 8px; /* 减小元素间距 */
}

/* 缩小下拉选择框的高度和字体 */
#tag-binding-controls .modal-select {
    padding-top: 8px;
    padding-bottom: 8px;
    font-size: 14px;
    /* [核心] 允许其在flex布局中被压缩，但不要过度压缩 */
    flex-grow: 1;
    min-width: 120px; /* 保证一个最小的可视宽度 */
}

/* 缩小按钮的高度和字体 */
#tag-binding-controls .modal-button {
    padding-top: 8px;
    padding-bottom: 8px;
    font-size: 14px;
    /* [核心] 禁止按钮在flex布局中被拉伸或压缩 */
    flex-grow: 0;
    flex-shrink: 0;
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */
/* =============================================================== */
/* =========== [新增] 文件标签功能磨砂玻璃主题适配 V1.0 ========== */
/* =============================================================== */

/* 1. 适配标签功能折叠/展开按钮 */
body.theme-glass .tag-actions-toggle-btn,
body.theme-glass.dark-mode .tag-actions-toggle-btn {
    /* 继承磨砂玻璃主题下通用按钮的样式 */
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px; /* 保持与容器一致的圆角 */
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);

    /* 覆盖从 .tag-action-btn 继承的透明背景和无阴影设置 */
    background-color: rgba(255, 255, 255, 0.2) !important; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.05) !important;
}

/* 夜间模式下的适配 */
body.theme-glass.dark-mode .tag-actions-toggle-btn {
    background-color: rgba(30, 30, 30, 0.4) !important;
    border-color: rgba(255, 255, 255, 0.15);
}


/* 2. 适配“按标签查看”模态框中的标签选项按钮 */
body.theme-glass .filter-tag-option,
body.theme-glass.dark-mode .filter-tag-option {
    /* 继承磨砂玻璃主题下通用按钮的样式 */
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    
    /* 覆盖拟态主题的内外阴影 */
    box-shadow: 0 4px 15px rgba(0,0,0,0.05) !important;
}

/* 夜间模式适配 */
body.theme-glass.dark-mode .filter-tag-option {
    background: rgba(30, 30, 30, 0.4);
    border-color: rgba(255, 255, 255, 0.15);
}

/* 按钮激活/点击时的效果，替换掉拟态的内阴影效果 */
body.theme-glass .filter-tag-option:active {
    box-shadow: 0 2px 10px rgba(0,0,0,0.1) !important;
    transform: translateY(1px);
}

/* [V2] 选中状态的样式适配：在磨砂玻璃主题下，通过轻微放大来表示选中 */
body.theme-glass .filter-tag-option.selected {
    /* 移除 opacity 和 background-color 改变，保持原样 */
    transform: scale(1.05); /* 轻微放大 */
    box-shadow: 0 6px 20px rgba(0,0,0,0.1); /* 可以稍微增强阴影，更有“浮起”感 */
}


body.theme-glass.dark-mode .filter-tag-option.selected {
    background-color: rgba(10, 10, 10, 0.2);
}
/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */

    </style>

 <style id="custom-jelly-ball-styles"></style>

    <!-- [新增] 用于全局字体的样式标签 -->
    <style id="global-font-style"></style>
    <!-- 手机模式滑动容器 -->
    <div class="main-wrapper" id="mainWrapper">
        <div class="page-slider" id="pageSlider">
            <!-- 锁屏页面 -->
            <div class="lock-screen-page" id="lockScreenPage">
                <div class="lockscreen-grid" id="lockscreenGrid">
                    <!-- JS 动态填充 -->
                </div>
            </div>
            <!-- 主屏幕页面 (JS会将下面的内容移入此div) -->
            <div class="home-screen-page" id="homeScreenPage">
                <!-- JS 动态填充 -->
            </div>
        </div>
    </div>

    <!-- [核心修复] 将主页内容移出 mobile-wrapper，作为 body 的直接子元素 -->
    <div class="page-overlay" id="pageOverlay"></div>
    <div class="title-card" id="titleCard">
        <h1 class="editable-title" id="title">Jellyfish Island</h1>
        <div class="editable-subtitle" id="subtitle">长按🌞打开工具栏 | By淡季水母</div>


    </div>

    <div class="category-nav-container" id="categoryNavContainer">
        <div class="category-nav" id="categoryNav"></div>
    </div>

    <!-- [新增] 可滚动的包裹容器 (结构调整) -->
    <div class="scrollable-nav-wrapper">
        <div class="nav-container" id="navContainer">
            <p id="loading-status" style="text-align: center; color: #889;">正在从云端加载配置...</p>
        </div>
    </div>

    <!-- ===== [新增] 摇摆挂件的HTML结构 (全局定位) ===== -->
    <div id="pendant-container" class="pendant-hidden">
        <div id="pendant-all-wrap" class="all-wrap">
            <div id="pendant-all" class="all">
                <!-- 使用一个span来方便地更改emoji或图片 -->
                <span id="pendant-shape">
                    <span class="emoji">☁️</span>
                </span>
            </div>
        </div>
    </div>
    <!-- ===== [新增结束] ===== -->

    <!-- 注意：悬浮按钮和模态框需要放在滑动容器之外，以保证它们在所有页面上都能正常显示和交互 -->
    <div class="fab-container" id="fabContainer">
        <div class="fab-drawer" id="fabDrawer">
            <button class="fab-drawer-item" id="helpBtn" title="使用指南">📧</button>
            <button class="fab-drawer-item" id="dataSyncBtn" title="数据同步">☁️<span id="sync-status-indicator" title="云同步状态"></span></button>
            <button class="fab-drawer-item" id="addNavBtn" title="管理项目">📱</button>
            <button class="fab-drawer-item" id="colorBtn" title="主题设置">🎨</button>
            <button class="fab-drawer-item" id="phoneCollectionBtn" title="手机收藏馆">💬</button>
            <button class="fab-drawer-item" id="memoryBtn" title="记忆">📷</button>
        </div>
        <button class="fab-main theme-toggle" id="themeBtn" title="切换主题">🌞</button>
    </div>

    <!-- ===== [结构修改] 手机收藏馆模态框 v2 ===== -->
    <!-- 列表主窗口 -->
    <div class="modal-overlay" id="phoneCollectionModal">
        <div class="modal-content">
            <div class="page-content">
                <div class="page-header-container">
                    <div class="modal-header" style="padding: 12px 15px;">
                        <div class="modal-title-group" style="gap: 8px; align-items: center;">
                            <span>手机收藏馆</span>
                            <button id="showNoticeBell" title="查看社区须知">ⓘ</button>
                        </div>
                        <button class="close-btn" data-modal-id="phoneCollectionModal">&times;</button>
                    </div>
                    <!-- ★★★ 修改：将搜索框和筛选按钮放在一个 flex 容器中 ★★★ -->
                    <div id="phone-search-filter-bar" style="padding: 0 15px 15px 15px; display: flex; align-items: center; gap: 10px;">
                        <input type="search" id="phoneSearchInput" class="modal-input" placeholder="按名称或作者ID搜索..." style="flex-grow: 1; min-width: 0;">
                        <button id="phoneFilterBtn" class="modal-button" style="flex-shrink: 0; padding: 10px 15px;">筛选</button>
                    </div>
                </div>
                <div id="phone-list-container" class="list-container">
                    <!-- JS动态填充手机分区 -->
                </div>
            </div>
        </div>
    </div>

    <!-- ★★★ 新增：筛选功能的模态框 ★★★ -->
    <div id="phoneFilterModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 80vh;">
            <div class="modal-header">
                <div class="modal-title-group">筛选器</div>
                <button class="close-btn" data-modal-id="phoneFilterModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- 1. 已选中的筛选标签 -->
                <div id="selected-filters-container" class="filter-section" style="border-bottom:none; padding-bottom: 5px; margin-bottom: 5px;">
                    <!-- JS 将在此处填充 -->
                </div>
                <!-- 2. 可选的筛选条件 -->
                <div class="filter-section">
                    <h4 class="filter-group-title">手机状态</h4>
                    <div id="filter-options-status" class="filter-options-grid">
                        <!-- JS 将在此处填充 -->
                    </div>
                </div>
                <div class="filter-section">
                    <h4 class="filter-group-title">售卖类型</h4>
                    <div id="filter-options-price" class="filter-options-grid">
                        <!-- JS 将在此处填充 -->
                    </div>
                </div>
                <div class="filter-section">
                    <h4 class="filter-group-title">我的状态</h4>
                    <div id="filter-options-user" class="filter-options-grid">
                        <!-- JS 将在此处填充 -->
                    </div>
                </div>
            </div>
            <!-- 3. 底部按钮 -->
            <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 15px; flex-grow: 0; flex-shrink: 0; border-top: 1px solid rgba(128,128,128,0.2);">
                <button id="clear-filters-btn" class="modal-button" style="color: #889;">清除</button>
                <button id="apply-filters-btn" class="modal-button" style="flex-grow: 1; margin-left: 10px; color: var(--hold-border);">确认</button>
            </div>
        </div>
    </div>

    <!-- 详情悬浮窗 -->
    <div class="modal-overlay" id="phoneDetailModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <!-- ★★★ 修改点：将标题和状态按钮包裹起来，并新增弹出菜单 ★★★ -->
                <div id="phone-detail-title-group" class="modal-title-group" style="gap: 12px; align-items: center; position: relative;">
                    <span id="phone-detail-title">手机详情</span>
                    <span id="phoneStatusBtn" style="cursor: pointer; font-size: 24px;" title="设置状态">◌</span>
                    <!-- [新增] 状态选择弹出菜单 -->
                    <div id="phoneStatusMenu">
                        <button class="status-option-btn" data-status="owned" title="已拥有">
                            <span class="status-icon owned-icon">★</span>
                        </button>
                        <button class="status-option-btn" data-status="wishlist" title="加入愿望单">
                            <span class="status-icon wishlist-icon">♥</span>
                        </button>
                         <button class="status-option-btn" data-status="none" title="未拥有">
                            <span class="status-icon" style="font-size: 20px;">∅</span>
                        </button>
                    </div>
                </div>
                <button class="close-btn" data-modal-id="phoneDetailModal">&times;</button>
            </div>
            <div class="modal-body" id="phone-detail-content">
                <!-- JS动态填充手机信息 -->
            </div>
        </div>
    </div>
    
    <!-- [新增] 评论区模态框 -->
    <div class="modal-overlay" id="phoneCommentsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div id="phone-comments-title" class="modal-title-group">安利区</div>
                <button class="close-btn" data-modal-id="phoneCommentsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Giscus 评论组件将在这里加载 -->
                <div class="giscus"></div>
                <!-- ⚠️ script 标签已被移除，将由 JavaScript 动态创建 -->
            </div>
        </div>
    </div>
    <!-- ===== [修改结束] ===== -->
    
    <!-- Modals -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group"><span>使用指南</span></div>
                <button class="close-btn" data-modal-id="helpModal">&times;</button>
            </div>
            <div class="modal-body">
                <input type="radio" id="help-tab-0" name="help-tab" value="setup" checked hidden>
                <input type="radio" id="help-tab-1" name="help-tab" value="features" hidden>
                <input type="radio" id="help-tab-2" name="help-tab" value="updates" hidden>
                <input type="radio" id="help-tab-3" name="help-tab" value="disclaimer" hidden>

                <div class="segmented-control four-segments">
                    <label for="help-tab-0">首次配置</label>
                    <label for="help-tab-1">功能介绍</label>
                    <label for="help-tab-2">更新公告<span id="update-log-indicator"></span></label>
                    <label for="help-tab-3">免责声明</label>
                    <div class="slider-indicator"></div>
                </div>
                <div class="help-content-wrapper">
                    <div id="help-page-0" class="help-page-content">
                        <h3>从零开始 (必需)</h3><p>此流程仅需您创建一个安全的“钥匙”(PAT)和一个云端“私人数据仓库”，让本应用可以为您安全地存储和同步所有数据。</p><ol><li><strong>访问创建页面</strong>：<a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener noreferrer">点击此链接直接进入 GitHub Token 创建页面</a>。</li><li><strong>填写基本信息</strong>：备注(Note)填写 <code>JellyfishIslandToken</code>，有效期(Expiration)选择 <code>No expiration</code> (永不过期)。</li><li><strong>分配权限 (关键)</strong>：只需 <strong>勾选 <code>repo</code></strong> 这一项。</li><li><strong>生成并复制</strong>：滑动到页面最底部，点击 <strong><code>Generate token</code></strong> 按钮。<strong>【⚠️极其重要⚠️】</strong> GitHub 只会显示这一次完整的 Token。请 <strong>立即点击复制按钮</strong> 将其保存到安全的地方，下一步会马上用到。它应该以 <code>ghp_</code> 开头。</li></ol>
                        <h4>步骤 2：创建私人数据仓库</h4><p>此步骤将创建一个独立的、完全私密的仓库，专门用来存放您的所有配置和文件。</p><ol><li><strong>访问创建页面</strong>：<a href="https://github.com/new" target="_blank" rel="noopener noreferrer">点击此链接直接进入 GitHub 仓库创建页面</a>。</li><li><strong>填写仓库信息</strong>：<ul><li><strong>Repository name (仓库名称)</strong>：起一个清晰的名字，例如 <code>My-Jellyfish-Data</code>。</li><li><strong>关键：选择 <code>Private</code> (私有)</strong>。这是您的私人数据，必须设为私有。</li></ul></li><li><strong>点击 <code>Create repository</code></strong> 按钮完成创建。</li></ol>
                        <h4>步骤 3：在 Jellyfish Island
 内完成最终配置</h4><p>现在，我们将“钥匙”和“数据仓库”信息告诉本应用。</p><ol><li><strong>打开配置面板</strong>：长按右下角的 🌞/🌜 按钮展开菜单 → 点击 <strong>☁️ (数据同步)</strong>。</li><li><strong>填入信息</strong>：<ul><li><strong>仓库</strong>：填写您在 <strong>步骤2</strong> 创建的**私人数据仓库**地址，格式为 <code>你的GitHub用户名/My-Jellyfish-Data</code>。</li><li><strong>Personal Access Token</strong>：粘贴您在 <strong>步骤1</strong> 创建并复制好的完整 Token。</li></ul></li><li><strong>保存并同步</strong>：点击 <strong><code>保存配置</code></strong> 按钮。</li></ol><p><strong>恭喜！</strong> 您的 Jellyfish Island 现已与云端完全同步，可以开始使用了！</p>
                    </div>
              
<div id="help-page-1" class="help-page-content">
    <details>
        <summary>核心操作</summary>
        <div class="details-content">
            <p><strong>编辑标题/副标题</strong>: 直接点击页面上的主标题或副标题即可修改。</p>
            <p><strong>切换主题</strong>: <strong>单击 (短按)</strong> 右下角的 🌞/🌜 按钮。</p>
            <p><strong>打开功能菜单</strong>: <strong>长按</strong> 右下角的 🌞/🌜 按钮。</p>
            <p><strong>访问链接与返回</strong>: 对于外部链接，默认在应用内全屏打开。您可以从屏幕**左侧中间区域向右滑动**来关闭当前页面并返回中心。您也可以在添加链接时选择“在新标签页中打开”，这样链接会直接通过系统浏览器打开。</p>
            <div class="important-note">
                <p><strong>关于“在新标签页中打开”选项的说明：</strong><br>此选项主要用于解决部分与应用内浏览器不兼容的网站。启用此选项后，链接将通过系统默认浏览器打开。请注意，部分设备在该模式下可能无法隐藏底部工具栏，这是一个已知的系统限制，请您根据需求自行选择。</p>
            </div>
        </div>
    </details>
    <details>
        <summary>☁️ 数据同步</summary>
        <div class="details-content">
            <p><strong>配置同步</strong>: 此功能用于设置您的私有GitHub仓库信息，是整个应用数据同步的核心。配置完成后，所有更改都将自动保存至云端。</p>
            <div class="important-note"><p><strong>新增智能迁移</strong>：该功能现在可以自动识别并修复旧版本（无分类功能）的配置文件，将其无缝升级为最新格式。</p></div>
            <p><strong>云同步状态指示灯</strong>：☁️ 图标上的小圆点会实时显示同步状态：</p>
            <ul><li><strong>🟢 绿点</strong>: <code>已同步</code> - 所有本地更改都已成功保存到云端。</li><li><strong>🟡 黄点 (闪烁)</strong>: <code>同步中</code> - 正在与云端进行数据交换。</li><li><strong>🔴 红点</strong>: <code>同步失败</code> - 发生错误，请点击图标查看失败原因。</li></ul>
            <p><strong>手动同步与修复</strong>: 在“数据同步”弹窗内，提供了一个手动同步按钮。此功能会强制从云端获取最新的配置文件，并与应用内置的最新模板进行对比。如果您的配置文件因版本更新而缺少了某些新功能的设置项，此功能会自动为您补全，确保应用正常运行。</p>
        </div>
    </details>
    <details>
        <summary>📱 项目管理</summary>
        <div class="details-content">
            <p><strong>分类导航</strong>: 您可以左右滑动顶部的分类导航栏来切换不同的项目分类。此导航栏可在“管理项目”中通过“分页展示”开关控制其显示或隐藏。</p>
            <p><strong>添加/编辑项目</strong>: 在"管理项目"弹窗中进行操作。进入“按钮管理模式”（在“管理项目”弹窗内点击）后，点击已存在的按钮即可进入编辑模式。</p>
<p><strong>删除分类</strong>: 在“管理项目”弹窗中，选择一个分类后，即可看到“删除当前分类”按钮。您可以选择：</p>
            <ul>
                <li><strong>仅删除分类</strong>: 项目将被保留并移至“全部”分类下。</li>
                <li><strong>删除分类和所有项目</strong>: 永久删除该分类及其包含的所有项目（需二次确认）。</li>
            </ul>
            <p><strong>删除项目时的文件转移</strong>: 当删除一个关联了“文件夹（云盘）”文件的项目时，系统会提示您是否需要将这些文件转移到一个新的或已有的项目中，以防数据丢失。</p>
        </div>
    </details>
    <details>
        <summary>🎨 主题与个性化</summary>
        <div class="details-content">
            <p><strong>主题风格</strong>：您现在可以在“全拟态”和“磨砂玻璃”两种视觉风格之间切换。选择“磨砂玻璃”后，界面元素将变为半透明质感，此时配色功能将关闭，但您仍可上传自定义背景图以搭配新风格。</p>
            <p><strong>实时调色</strong>：在“全拟态”风格下，可实时调整日间/夜间模式的背景渐变色，以及标题卡片的背景图片。</p>
            <p><strong>色彩预设</strong>：在“全拟态”风格下，您可以保存、应用、更新或删除自己喜欢的配色方案，还可以开启“随机主题”功能，在每次启动时随机应用一个已保存的预设。</p>
            <div class="important-note" style="margin-top: 15px;">
                <h4>🪼 悬浮窗与悬浮球</h4>
                <p>通过 <code>主题设置 → 网页内悬浮球</code>，您可以在应用内网页中开启一个便捷的悬浮助手。</p>
                <p><strong>悬浮球操作</strong>:</p>
<ul>
                    <li><strong>拖动</strong>: 按住并拖动可移动位置，松手后自动贴边。</li>
                    <li><strong>闲置隐藏</strong>: 静置3秒后会自动半透明隐藏，减少干扰。</li>
                    <li><strong>功能菜单</strong>: <strong>长按</strong>悬浮球会弹出环形功能菜单，滑动到目标功能上松手即可触发。</li>
                    <li><strong>全屏功能 (⛶)</strong>: 在应用内打开网页时，通过菜单中的“全屏”按钮可将当前网页全屏化（此功能仅在部分安卓设备上可用）。</li>
                </ul>
                <p><strong>“快速切换”悬浮窗</strong>:</p>
                <p>这是悬浮球菜单中的一个强大功能（🔗），它允许您将任何项目在独立的悬浮窗口中打开。</p>
                <ul>
                    <li><strong>移动</strong>: 按住窗口顶部的标题栏进行拖动。</li>
                    <li><strong>隐藏/关闭</strong>: 点击标题栏上的 <strong>－</strong> 可将其最小化至侧边栏，点击 <strong>×</strong> 可彻底关闭。</li>
                    <li><strong>调整大小</strong>: 拖动窗口右下角可以等比例缩放窗口大小。</li>
                </ul>
            </div>
            <div class="important-note" style="margin-top: 15px;">
                <h4>📱 锁屏组件</h4>
                <p>通过 <code>主题设置 → 手机模式</code>，您可以开启一个模拟手机桌面的锁屏界面。在这里，您可以自由添加和布局多种实用小组件。</p>
                <ul>
                    <li><strong>自由布局</strong>: 在设置界面，通过拖拽即可将组件放置在锁屏网格的任意位置。</li>
                    <li><strong>多种尺寸与形状</strong>: 支持创建不同尺寸（如2x2, 4x2）和形状（方形、圆形）的组件。</li>
                    <li><strong>丰富组件类型</strong>:
                        <ul>
                            <li><strong>快捷方式</strong>: 将任意项目（链接或上传的应用）固定到锁屏，实现一键直达。</li>
                            <li><strong>备忘录</strong>: 直接在锁屏上预览指定备忘录的内容，或实时查看和完成待办事项。</li>
                            <li><strong>图片</strong>: 从“记忆相册”中选择一张图片作为锁屏背景或装饰。</li>
                            <li><strong>HTML</strong>: 支持嵌入自定义HTML代码，实现天气、时钟等高度个性化功能。</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </details>
    <!-- ★★★ 新增：手机收藏馆介绍 ★★★ -->
    <details>
        <summary>💬 手机收藏馆</summary>
        <div class="details-content">
            <p>一个社区驱动的手机分区展示与交流中心。</p>
            <ul>
                <li><strong>集中展示</strong>：汇集了来自社区作者的各类手机分区，方便你快速浏览和发现。</li>
                <li><strong>快速直达</strong>：提供作者ID、获取方式等基础信息，并支持作者小红书ID一键复制。</li>
                <li><strong>友好安利区</strong>：每个分区都拥有独立的评论区，你可以在这里分享使用体验、进行友好交流。</li>
                <li><strong>个性化置顶</strong>：可以将你最喜欢的手机分区置顶显示，打造专属的收藏列表。</li>
            </ul>
        </div>
    </details>
    <details>
        <summary>📷 记忆功能</summary>
        <div class="details-content">
            <p>一个集成了备忘录、相册和文件云盘的私人空间，所有数据都安全地存储在您的GitHub私有仓库中。</p>
            <ul>
                <li><strong>备忘录</strong>: 支持文件夹分类管理。编辑器提供待办清单、多种文字格式和可一键复制的代码块功能，满足不同的记录需求。</li>
                <li><strong>相册</strong>: 支持创建多个相册，批量上传照片，并可进入沉浸式的“漫游模式”浏览，支持配合背景音乐播放。</li>
                <li><strong>文件夹</strong>: 一个轻量级的文件云盘，支持按项目分类上传、下载和管理各类文件。</li>
            </ul>
        </div>
    </details>

    <div class="warning"><p><strong>危险操作</strong>：在 <code>数据同步</code> (☁️) 弹窗的最下方有“清空所有数据”按钮。此操作会 <strong>永久删除</strong> 您 GitHub 数据仓库中所有相关数据。<strong>此操作不可逆，请极度谨慎</strong>。</p></div>
</div>
<div id="help-page-2" class="help-page-content">
    <div class="update-header-info">
        <p><strong>小红书ID:</strong> 淡季水母</p>
        <p><strong>QQ交流群:</strong> 563191005</p>
    </div>
        <!-- ★ 在这里新增下面的代码块 ★ -->
    <div class="update-log-entry">
    <h4>v6.0.0 <span class="update-date">- 2025.11.16</span></h4>
    <ul>
        <li><span class="tag new">新功能</span> 新增「挂件中心」模块，集成签到、使用时长统计和留言板功能。</li>
        <li><span class="tag new">新功能</span> 备忘录功能大幅增强：
            <ul>
                <li style="margin-top: 8px;">支持从 .txt, .docx, .xml 等文件批量导入纯文本内容。</li>
                <li>新增全局及文件夹内搜索功能。</li>
                <li>列表项新增“复制全文”按钮。</li>
                <li>编辑器内新增“一键回顶”按钮，方便浏览长篇笔记。</li>
            </ul>
        </li>
        <li><span class="tag new">新功能</span> 删除项目时，新增选项可将其关联的云盘文件转移至新项目或已有项目中。</li>
        <li><span class="tag new">新功能</span> 悬浮球菜单新增“全屏”功能（仅安卓可用），可将应用内打开的网页全屏化。</li>
        <li><span class="tag opt">优化</span> 更新了部分UI图标，提升了视觉美感。</li>
        <li><span class="tag fix">修复</span> 解决了备忘录在内容过长时可能溢出显示区域的问题。</li>
    </ul>
</div>
<div class="update-log-entry">
    <h4>v5.9.5 <span class="update-date">- 2025.11.06</span></h4>
    <ul>
        <li><span class="tag new">新功能</span> 备忘录工具栏加强，支持调整文字大小和一键复制全文。</li>
        <li><span class="tag new">新功能</span> 漫游模式支持上传 <code>.m4a</code> 格式的音乐文件。</li>
        <li><span class="tag new">新功能</span> 新增照片上传取消功能，可在上传过程中随时中止任务。</li>
        <li><span class="tag new">新功能</span> 数据清理功能现已支持按类别（如主配置、相册、云盘等）进行选择性清空。</li>
        <li><span class="tag new">新功能</span> 备忘录的文件夹封面上增加项目数量显示。</li>
        <li><span class="tag new">新功能</span> 新增对网易云盘的授权上传支持（此功能测试中，暂不可用）。</li>
        <li><span class="tag opt">优化</span> 对于 iOS 设备，相册照片下载方式变更为“分享，”可选择保存到“照片”或“文件”应用。</li>
        <li><span class="tag opt">优化</span> 修复了悬浮球的预览功能交互，点击“预览”可实时查看效果，应用后将刷新页面。</li>
        <li><span class="tag opt">优化</span> 优化了悬浮球CSS自定义功能的帮助提示词。</li>
        <li><span class="tag opt">优化</span> 优化了“记忆”模块的加载逻辑与显示效果，提升了启动速度。</li>
        <li><span class="tag opt">优化</span> 上传照片时，默认不再勾选“创建照片集”选项。</li>
        <li><span class="tag opt">优化</span> 优化了退出页面时管理模式的自动退出逻辑。</li>
        <li><span class="tag fix">修复</span> 修复了在“磨砂玻璃”主题下，项目按钮的磨砂背景显示不正确的问题。</li>
    </ul>
</div>
<div class="update-log-entry">
    <h4>v5.9.5 <span class="update-date">- 2025.10.19</span></h4>
    <ul>
        <li><span class="tag new">新功能</span> 新增备份提醒功能，支持定时或在关闭项目时弹出提醒，有效防止数据丢失。</li>
        <li><span class="tag new">新功能</span> 手机收藏馆新增“我的状态”功能，可将手机标记为“已拥有”或“愿望单”，并附有专属动态效果。</li>
        <li><span class="tag new">新功能</span> 手机收藏馆新增高级筛选功能，支持按手机状态、售价和“我的状态”进行多条件组合筛选。</li>
        <li><span class="tag new">新功能</span> 在相册的全屏看图模式下，现已支持直接下载当前照片。</li>
    </ul>
</div>
<div class="update-log-entry">
    <h4>v5.9.0 <span class="update-date">- 2025.10.17</span></h4>
    <ul>
        <li><span class="tag release">里程碑</span> 应用正式更名为“水母岛 (Jellyfish Island)”。</li>
        <li><span class="tag opt">优化</span> 重构了新用户引导流程。首次打开应用时，将弹出友好的配置向导，取代了原有的技术性错误提示，帮助用户更顺畅地完成初始设置。</li>
        <li><span class="tag new">新功能</span> “更新公告”标签页新增红点提示，与主菜单的更新提醒同步，让版本变更一目了然。</li>
        <li><span class="tag fix">修复</span> 解决了因逻辑中断导致全局字体设置功能按钮无法点击的问题。</li>
    </ul>
</div>
    <div class="update-log-entry">
        <h4>v5.8.0 <span class="update-date">- 2025.10.16</span></h4>
        <ul>
            <li><span class="tag new">新功能</span> 【数据保险箱】当云端数据意外清空时，进入“数据同步”弹窗点击“手动同步与修复”，系统会自动检测并引导您从上一个历史版本一键恢复所有数据。</li>
            <li><span class="tag new">新功能</span> 新增上传中断保护，在上传文件或照片时关闭页面会触发挽留提示。</li>
            <li><span class="tag new">新功能</span> 在“记忆-文件夹”中上传文件时，增加了“✖”按钮以随时终止上传任务。</li>
            <li><span class="tag fix">修复</span> 修复了在特定情况下，“记忆-相册”批量上传照片时可能中断或失败的问题。</li>
            <li><span class="tag opt">优化</span> 优化了项目内所有弹窗的字体渲染，增强了可读性。</li>
            <li><span class="tag opt">优化</span> 提升了文件上传进度条的计算精度。</li>
        </ul>
    </div>
        <!-- ★ 在这里新增下面的代码块 ★ -->
    <div class="update-log-entry">
        <h4>v5.7.6 <span class="update-date">- 2025.10.16</span></h4>
        <ul>
            <li><span class="tag new">新功能</span> 新增全局字体更换功能，支持在主题设置中应用在线字体及管理预设。</li>
            <li><span class="tag new">新功能</span> 新增为相册设置自定义背景（封面）的功能。</li>
            <li><span class="tag new">新功能</span> 新增相册排序功能，在管理模式下可以拖拽调整相册顺序。</li>
            <li><span class="tag opt">优化</span> 优化了项目编辑逻辑，修改项目后其按钮将保持在原位，不再移动到末尾。</li>
            <li><span class="tag opt">优化</span> 美化了“手机收藏馆”的界面，采用更具动感的泡泡布局以提升视觉体验。</li>
            <li><span class="tag opt">优化</span> 优化了相册的上传流程，批量上传照片和编辑信息的交互更为简洁。</li>
            <li><span class="tag fix">修复</span> 修复了备忘录内容无法垂直滚动以及代码块内长文本溢出的问题。</li>
            <li><span class="tag fix">修复</span> 修复了在主题设置中，所选的主题风格（如“磨砂玻璃”）无法被正确保存的问题。</li>
            <li><span class="tag fix">修复</span> 修复了在管理模式下长按拖拽排序时，项目按钮位置可能无法正确互换的问题。</li>
        </ul>
    </div>

    <div class="update-log-entry">
        <h4>v5.5.0 <span class="update-date">- 2025.10.14</span></h4>
        <ul>
            <li><span class="tag new">新功能</span> 新增悬浮球CSS预设管理功能。</li>
            <li><span class="tag opt">优化</span> 简化了主题颜色预设的管理界面，操作更直观。</li>
        </ul>
    </div>
    
    <!-- 下方是原始的 v5.4.0 代码 -->
    <div class="update-log-entry">
        <h4>v5.4.0 <span class="update-date">- 2025.10.13</span></h4>
        <ul>
            <!-- ★ 修改点：移除加粗标题，润色文案 -->
            <li><span class="tag opt">优化</span> 全拟态主题的颜色设置体验得到优化，颜色值现已支持直接在输入框中修改，整体布局也更为直观。</li>
            <li><span class="tag new">新功能</span> 新增“手机收藏馆”功能，一个社区驱动的手机分区收藏与交流中心，方便发现与分享。</li>
        </ul>
    </div>
     <div class="update-log-entry">
        <h4>v5.3.0 <span class="update-date">- 2025.10.11</span></h4>
        <ul>
            <!-- ★ 修改点：移除加粗标题，润色文案 -->
            <li><span class="tag new">新功能</span> 新增“锁屏组件”功能，支持在手机模式下高度自定义布局与多种组件类型。（详见“功能介绍”）</li>
            <li><span class="tag new">新功能</span> 备忘录功能得到增强，新增待办事项（清单）、多种文字格式及一键复制代码块功能。</li>
            <li><span class="tag fix">修复</span> 解决了悬浮球在部分内嵌网页中无法显示的问题。</li>
            <li><span class="tag fix">修复</span> 修复了在悬浮球设置中，自定义CSS输入框无法实时预览样式的问题。</li>
        </ul>
    </div>
    <!-- ... (这里是你文件里原有的其他更新日志，保持不变) ... -->
    <div class="update-log-entry">
        <h4>v4.1.0 <span class="update-date">- 2025.10.04</span></h4>
        <ul>
            <li><span class="tag fix">修复</span> 解决了上传的HTML项目在部分情况下无法正常打开的问题。</li>
            <li><span class="tag new">新功能</span> 新增悬浮球CSS自定义向导与模板，方便用户快速美化悬浮球。（详见“主题设置”）</li>
            <li><span class="tag new">新功能</span> 在“按钮管理模式”下，支持通过长按并拖拽的方式，对项目按钮进行直观排序。</li>
            <li><span class="tag fix">修复</span> 修复了记忆功能的“文件夹”模块中，项目选择器无法正确加载和选择项目的问题。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v3.9.0 <span class="update-date">- 2025.10.03</span></h4>
        <ul>
            <li><span class="tag new">新功能</span> 新增网页内悬浮球与多项目悬浮窗功能，提升多任务操作体验。（详见“功能介绍”）</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v3.7.0 <span class="update-date">- 2025.10.02</span></h4>
        <ul>
            <li><span class="tag opt">优化</span> 对相册的底层加载逻辑进行了重构，引入懒加载技术，彻底解决了开启、浏览和管理相册时的各种卡顿、图片错乱和重复显示问题。</li>
            <li><span class="tag fix">修复</span> 彻底修复了文件在某些情况下无法下载的问题。</li>
            <li><span class="tag fix">修复</span> 修复了从内嵌网页跳转后，可能导致数据导出功能异常的Bug。</li>
            <li><span class="tag fix">修复</span> 修复了可能导致音乐无法正常加载播放和退出漫游后仍在后台播放的Bug。</li>
            <li><span class="tag fix">修复</span> 解决了因加载逻辑问题导致的相册照片无法显示的问题。</li>
            <li><span class="tag fix">修复</span> 修正了分页逻辑，现在关闭分页模式后，所有分类下的所有按钮都会被正确显示。</li>
            <li><span class="tag fix">修复</span> 修复了在漫游模式下照片无法左右滑动切换的问题。</li>
            <li><span class="tag opt">优化</span> 全拟态夜间模式下的立体阴影颜色调整为更深邃的黑色，增强了视觉层次感。</li>
            <li><span class="tag opt">优化</span> 移除了磨砂玻璃风格下按钮和悬浮窗的多余蓝调，使其色彩表现更纯净、更通透。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v3.6.0 <span class="update-date">- 2025.10.01</span></h4>
        <ul>
            <li><span class="tag fix">重要修复</span> 彻底解决了旧版无分类的 `config.json` 文件无法在新版应用中显示按钮的问题。</li>
            <li><span class="tag new">新功能</span> “手动同步与修复” 现已集成**智能数据迁移**功能，可自动将旧版配置文件无缝升级为最新、最兼容的格式。</li>
            <li><span class="tag opt">优化</span> 应用在首次加载云端数据时，也会自动执行数据迁移检查，确保老用户平滑过渡。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v3.5.0 <span class="update-date">- 2025.10.01</span></h4>
        <ul>
            <li><span class="tag new">功能</span> 新增按钮分类功能，可创建自定义分类管理项目。</li>
            <li><span class="tag new">功能</span> 新增 “在新标签页中打开” 选项，用于兼容特殊外部链接。</li>
            <li><span class="tag new">功能</span> 新增 “磨砂半透明” 主题，提供全新视觉风格。</li>
            <li><span class="tag fix">修复</span> 解决了上传的本地HTML项目无法在应用内正确打开的问题。</li>
            <li><span class="tag fix">修复</span> 修复了在部分页面左上角返回按钮无法点击的Bug。</li>
            <li><span class="tag opt">优化</span> 优化了应用内的错误与状态提示信息。</li>
            <li><span class="tag opt">优化</span> 访问GitHub相关链接时，增加开启VPN的友好提示弹窗。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v2.0.0 <span class="update-date">- 2025.09.30</span></h4>
        <ul>
            <li><span class="tag new">功能</span> 极大简化了添加网址与上传文件项目的方式。</li>
            <li><span class="tag new">功能</span> 新增文件云盘功能，支持按分类上传和下载文件。</li>
            <li><span class="tag new">功能</span> 新增 “记忆” 功能模块，集成备忘录与相册。</li>
            <li><span class="tag new">功能</span> 相册内置 “漫游模式”，提供沉浸式看图体验。</li>
            <li><span class="tag new">功能</span> 支持自定义上传全局背景图片和标题卡片背景图片。</li>
            <li><span class="tag fix">优化</span> 优化iOS端全屏显示，左侧右滑返回时增加确认弹窗以防误触。</li>
        </ul>
    </div>
    <div class="update-log-entry">
        <h4>v1.0.0 <span class="update-date">- 2025.09.24</span></h4>
        <ul>
            <li><span class="tag release">正式发布</span> JellyfishCenter 导航正式上线。</li>
            <li><span class="tag new">功能</span> 新增日间/夜间模式一键切换。</li>
            <li><span class="tag new">功能</span> 新增自定义图标与卡片主题色功能。</li>
        </ul>
    </div>
    
    <footer class="update-footer">
        当前版本: v6.0.0
    </footer>
</div>
                    <div id="help-page-3" class="help-page-content">
                        <h3>免责声明与使用条款</h3><h4>1. 服务条款</h4><p>本应用 (Jellyfish Island) 按“现状”提供，不附带任何明示或暗示的保证。开发者不保证应用的持续可用性、功能完整性或无错误。所有因使用本应用导致的直接或间接风险与责任，均由用户自行承担。</p><h4>2. 数据安全</h4><p>用户需自行负责其GitHub个人访问令牌 (PAT) 的安全保管。任何因PAT泄露导致的数据丢失、篡改或账户安全问题，开发者概不负责。强烈建议为本应用创建独立的、具有最小必要权限 (<code>repo</code>) 的PAT。</p><h4>3. 知识产权与版权责任</h4><div class="important-note"><p>本应用可能被用于托管或链接至第三方项目。用户必须对所上传或链接的内容负全部法律责任，并确保拥有展示、使用和分发该内容的合法权利。<strong>用户必须尊重所有原创作者的知识产权，不得侵犯他人版权。</strong></p></div><h4>4. 使用与分发限制</h4><div class="warning"><p>本项目 (Jellyfish Island) 及其源代码仅供个人非商业性使用。严禁以下行为：</p><ul><li>对本项目的源代码进行任何形式的二次修改、再分发或公开发布（即“二传二改”）。</li><li>公开或私下分享通过本应用“上传项目”功能生成的任何网页链接或文件。此行为可能构成对原创内容的未授权分发。</li></ul></div><p>继续使用本应用，即表示您已阅读、理解并同意上述所有条款。</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="syncErrorModal"><div class="modal-content"><div class="modal-header"><div class="modal-title-group"><span>⚠️ 同步失败</span></div><button class="close-btn" data-modal-id="syncErrorModal">&times;</button></div><div class="modal-body"><p>无法连接到云端。请检查您的网络连接或GitHub配置。</p><p><strong>失败原因:</strong></p><div id="sync-error-message"></div></div></div></div>
<div class="modal-overlay" id="addNavModal"><div class="modal-content"><div class="modal-header"><div class="modal-title-group"><span id="addNavModalTitle">管理项目</span></div><div class="header-toggle-group"><span>连续添加</span><label class="toggle-switch"><input type="checkbox" id="stayOpenToggle"><span class="slider"></span></label></div><button class="close-btn" data-modal-id="addNavModal">&times;</button></div><div class="modal-body">
    <button id="enterManageModeBtn" class="modal-button" style="color:#5a6778;">进入按钮管理模式</button>
    
    <!-- 分页展示开关 -->
    <div class="toggle-section" style="margin-top: 10px;">
        <span>分页展示</span>
        <label class="toggle-switch"><input type="checkbox" id="paginationToggle"><span class="slider"></span></label>
    </div>

    <!-- [新增] 备份提醒入口 -->
    <div class="toggle-section" style="margin-top: 10px; flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
        <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
            <span>备份提醒</span>
            <label class="toggle-switch"><input type="checkbox" id="backupReminderToggle"><span class="slider"></span></label>
        </div>
        <div id="backupSettingsEntry" style="width: 100%; display: none;">
                <button id="openBackupSettingsBtn" class="modal-button" style="width: 100%; margin-top: 10px;">备份提醒设置</button>
        </div>
    </div>
    <!-- [新增结束] -->
    
    <div class="segmented-control two-segments"><input type="radio" id="type-link" name="nav-type" value="link" checked hidden><label for="type-link">外部链接</label><input type="radio" id="type-upload" name="nav-type" value="upload" hidden><label for="type-upload">上传项目</label><div class="slider-indicator"></div></div><div class="form-section"><label for="newButtonCategoryInput">分类名称</label><input type="text" id="newButtonCategoryInput" class="modal-input" placeholder="选择或创建分类" list="category-datalist"><datalist id="category-datalist"></datalist></div><div id="category-management-section" style="display: none;"><button id="deleteCategoryBtn" class="modal-button" style="color:#e53e3e;">删除当前分类</button></div><div class="form-section"><label for="newButtonNameInput">按钮名称</label><input type="text" id="newButtonNameInput" class="modal-input" placeholder="例如: 我的博客"></div><div id="link-section"><div class="form-section"><label for="newButtonUrlInput">网址链接</label><input type="text" id="newButtonUrlInput" class="modal-input" placeholder="https://example.com"></div><div class="toggle-section" style="margin-top: 10px;"><span>在新标签页中打开</span><label class="toggle-switch"><input type="checkbox" id="openExternallyToggle"><span class="slider"></span></label></div></div><div id="upload-section" class="form-section" style="display: none;"><label>选择项目的主HTML文件</label><div class="file-select-wrapper"><input type="file" id="projectHtmlPicker" accept=".html,.htm" style="display: none;"><button id="filePickerBtn" class="modal-button">选择文件</button><span id="file-picker-status" class="status-text">未选择任何文件</span></div><div class="important-note" style="font-size: 13px; padding: 8px 12px; margin-top: 5px;"><p>上传的项目无法编辑链接，如需更新请删除后重新上传。</p></div></div><button id="createNavBtn" class="modal-button">加入新项目</button><div class="status-text" id="upload-status"></div></div></div></div>
    <div class="modal-overlay" id="settingsModal"><div class="modal-content"><div class="modal-header"><div class="modal-title-group"><span>数据同步</span></div><button class="close-btn" data-modal-id="settingsModal">&times;</button></div><div class="modal-body"><div class="form-section"><label for="githubRepoInput">仓库 (格式: 用户名/仓库名)</label><input type="text" id="githubRepoInput" class="modal-input" placeholder="例如: my-username/JellyfishPhones"></div><div class="form-section"><label for="githubTokenInput">Personal Access Token</label><input type="password" id="githubTokenInput" class="modal-input" placeholder="ghp_xxxxxxxxxx"></div><button id="saveSettingsBtn" class="modal-button">保存配置</button><button id="manualSyncBtn" class="modal-button" style="color:#5a6778; margin-top: 10px;">手动同步与修复</button><!-- [修改] 将"清空所有数据"按钮改为"高级数据清理"，链接到新的选择性清理弹窗 -->
<div class="nuke-section"><button id="openClearDataModalBtn" class="modal-button" style="color: #e53e3e;">清空所有云端及本地数据</button></div></div></div></div>
    <div class="modal-overlay" id="colorPaletteModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group"><span>主题设置</span></div>
                <button class="close-btn" data-modal-id="colorPaletteModal">&times;</button>
            </div>
                        <div class="modal-body">

                <!-- [新增] 手机模式开关 -->
                <div class="toggle-section" style="flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                    <span style="font-weight: 600; width: 100%;">手机模式</span>
                    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
                        <span>启用手机主题</span>
                        <label class="toggle-switch"><input type="checkbox" id="mobileModeToggle"><span class="slider"></span></label>
                    </div>
                    <!-- [新增] 锁屏设置入口 -->
                    <div id="lockscreenSettingsEntry" style="width: 100%; display: none;">
                         <button id="openLockscreenSettingsBtn" class="modal-button" style="width: 100%; margin-top: 10px;">锁屏组件设置</button>
                    </div>
                </div>
                <!-- [新增结束] -->
                
                <!-- ============= [ 新增：摇摆挂件总开关 ] ============= -->
                <div class="toggle-section" id="pendant-main-control" style="flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                    <span style="font-weight: 600; width: 100%;">摇摆挂件</span>
                    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
                        <span>启用挂件</span>
                        <label class="toggle-switch"><input type="checkbox" id="pendantMasterToggle"><span class="slider"></span></label>
                    </div>
                    <!-- [新增] 挂件显隐控制 -->
                    <div id="pendantVisibilityControls" style="width: 100%; display: none;">
                         <button id="togglePendantVisibilityBtn" class="modal-button" style="width: 100%; margin-top: 10px;">隐藏挂件</button>
                    </div>
                </div>
                <!-- ============= [ 新增结束 ] ============= -->
                
                <div class="toggle-section" id="jelly-ball-main-control" style="flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                    <span style="font-weight: 600; width: 100%;">网页内悬浮球</span>
                    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
                        <span>启用悬浮球</span>
                        <label class="toggle-switch"><input type="checkbox" id="jellyBallToggle"><span class="slider"></span></label>
                    </div>
                    <!-- [新增] 悬浮球设置入口 -->
                    <div id="jellyBallSettingsEntry" style="width: 100%; display: none;">
                         <button id="openJellyBallSettingsBtn" class="modal-button" style="width: 100%; margin-top: 10px;">悬浮球设置</button>
                    </div>
                </div>

                <div class="theme-style-selector">
                    <label style="font-weight: 600;">主题风格</label>
                    <div class="segmented-control two-segments">
                        <input type="radio" id="theme-style-neumorphism" name="theme-style" value="neumorphism" checked hidden>
                        <label for="theme-style-neumorphism">全拟态</label>
                        <input type="radio" id="theme-style-glass" name="theme-style" value="glass" hidden>
                        <label for="theme-style-glass">磨砂玻璃</label>
                        <div class="slider-indicator"></div>
                    </div>
                </div>
                <div id="pneumorphism-settings">
                    <div class="color-picker-grid">
                        <div class="color-picker-group"><label>日间模式 - 左上</label><div class="color-input-wrapper"><input type="color" id="dayColor1Picker"><input type="text" class="modal-input hex-display" id="dayColor1HexInput" maxlength="7"></div></div>
                        <div class="color-picker-group"><label>日间模式 - 右下</label><div class="color-input-wrapper"><input type="color" id="dayColor2Picker"><input type="text" class="modal-input hex-display" id="dayColor2HexInput" maxlength="7"></div></div>
                        <div class="color-picker-group"><label>夜间模式 - 左上</label><div class="color-input-wrapper"><input type="color" id="nightColor1Picker"><input type="text" class="modal-input hex-display" id="nightColor1HexInput" maxlength="7"></div></div>
                        <div class="color-picker-group"><label>夜间模式 - 右下</label><div class="color-input-wrapper"><input type="color" id="nightColor2Picker"><input type="text" class="modal-input hex-display" id="nightColor2HexInput" maxlength="7"></div></div>
                    </div>
                    <div class="preview-container"><div class="preview-box" id="dayPreview" data-label="Day"></div><div class="preview-box" id="nightPreview" data-label="Night"></div></div>
                    <div class="preset-manager" style="margin-bottom: 15px;">
                        <div class="preset-row">
                            <select id="presetSelector" class="modal-select" style="flex-grow: 1;"></select>
                            <button id="addColorPresetBtn" title="添加新预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">+</button>
                            <button id="updateColorPresetBtn" title="更新当前预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 24 24" style="vertical-align: middle;"> <path fill-rule="evenodd" clip-rule="evenodd" d="M6.00283 5.97646C7.54105 4.44489 9.65927 3.5 12.0001 3.5C16.6945 3.5 20.5001 7.30558 20.5001 12V13H22.5001V12C22.5001 6.20101 17.7991 1.5 12.0001 1.5C9.21634 1.5 6.52096 2.62797 4.55516 4.59569L2.51245 6.84208L3.99216 8.18762L6.00283 5.97646Z" fill="currentColor"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 1.5V6.5H9.5V8.5H2.5V1.5H4.5Z" fill="currentColor"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M17.9972 18.0235C16.4589 19.5551 14.3407 20.5 11.9999 20.5C7.30551 20.5 3.49993 16.6944 3.49993 12V11H1.49993V12C1.49993 17.799 6.20094 22.5 11.9999 22.5C14.901 22.5 17.5289 21.3221 19.4282 19.4209L21.4875 17.1579L20.0078 15.8124L17.9972 18.0235Z" fill="currentColor" data-color="color-2"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M19.5 22.5V17.5H14.5V15.5H21.5V22.5H19.5Z" fill="currentColor" data-color="color-2"></path> </svg></button>
                            <button id="deleteColorPresetBtn" title="删除当前预设" class="modal-button delete" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 24 24" style="vertical-align: middle;"><path d="m4.458,9l.463,11.125c.067,1.612,1.384,2.875,2.998,2.875h8.163c1.613,0,2.93-1.263,2.998-2.875l.463-11.125H4.458Z" stroke-width="0" fill="currentColor"></path><path d="m16,5V1h-8v4H2v2h20v-2h-6Zm-6-2h4v2h-4v-2Z" fill="currentColor" stroke-width="0" data-color="color-2"></path></svg></button>
                        </div>
                    </div>
                    <div class="toggle-section"><span>每次启动时随机应用预设</span><label class="toggle-switch"><input type="checkbox" id="randomPaletteToggle"><span class="slider"></span></label></div>
                </div>
                <div class="background-image-manager">
                    <div class="background-image-row">
                        <input type="file" id="dayBgImagePicker" accept="image/*" hidden>
                        <button id="uploadDayBgBtn" class="modal-button">导入日间背景</button>
                        <span id="dayBgStatus" class="status"></span>
                        <button id="clearDayBgBtn" class="modal-button delete">清除</button>
                    </div>
                    <div class="background-image-row">
                        <input type="file" id="nightBgImagePicker" accept="image/*" hidden>
                        <button id="uploadNightBgBtn" class="modal-button">导入夜间背景</button>
                        <span id="nightBgStatus" class="status"></span>
                        <button id="clearNightBgBtn" class="modal-button delete">清除</button>
                    </div>
                    <div class="background-image-row">
                        <input type="file" id="dayTitleCardBgImagePicker" accept="image/*" hidden>
                        <button id="uploadDayTitleCardBgBtn" class="modal-button">导入日间卡片</button>
                        <span id="dayTitleCardBgStatus" class="status"></span>
                        <button id="clearDayTitleCardBgBtn" class="modal-button delete">清除</button>
                    </div>
                    <div class="background-image-row">
                        <input type="file" id="nightTitleCardBgImagePicker" accept="image/*" hidden>
                        <button id="uploadNightTitleCardBgBtn" class="modal-button">导入夜间卡片</button>
                        <span id="nightTitleCardBgStatus" class="status"></span>
                        <button id="clearNightTitleCardBgBtn" class="modal-button delete">清除</button>
                    </div>
                </div>

                <!-- [新增] 全局字体管理区域 -->
                <div class="preset-manager font-manager" style="border-top: 1px solid rgba(0,0,0,0.1); padding-top: 20px; margin-top:20px;">
                    <label style="font-weight: 600; font-size: 1em; margin-bottom: 10px; display: block; text-align: left;">全局字体设置</label>
                    
                    <!-- [优化] 一行式操作布局 -->
                    <div class="preset-row">
                        <input type="text" id="fontUrlInput" class="modal-input" placeholder="输入字体文件链接 (.woff2, .ttf)" style="flex-grow: 1;">
                        <button id="applyFontBtn" class="modal-button" style="width: auto; padding: 12px 15px; flex-shrink: 0; font-size: 14px;">应用</button>
                        <button id="clearFontBtn" class="modal-button" style="width: auto; padding: 12px 15px; flex-shrink: 0; font-size: 14px; color:#889;">恢复</button>
                    </div>
                    
                    <div class="preset-row" style="margin-top: 15px;">
                        <select id="fontPresetSelector" class="modal-select" style="flex-grow: 1;"></select>
                        <button id="addFontPresetBtn" title="添加新预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">+</button>
                        <button id="updateFontPresetBtn" title="修改预设名" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 24 24" style="vertical-align: middle;"><rect x="1" y="20" width="22" height="2" fill="currentColor" stroke-width="0" data-color="color-2"></rect><path d="m18.875,2.125c-1.492-1.493-3.922-1.493-5.414,0L4.079,11.507l-1.354,6.768,6.768-1.354,9.382-9.382c1.493-1.493,1.493-3.921,0-5.414Zm-1.414,4l-.875.875-2.586-2.586.875-.875c.713-.713,1.873-.713,2.586,0s.713,1.873,0,2.586Z" stroke-width="0" fill="currentColor"></path></svg></button>
                        <button id="deleteFontPresetBtn" title="删除当前预设" class="modal-button delete" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 24 24" style="vertical-align: middle;"><path d="m4.458,9l.463,11.125c.067,1.612,1.384,2.875,2.998,2.875h8.163c1.613,0,2.93-1.263,2.998-2.875l.463-11.125H4.458Z" stroke-width="0" fill="currentColor"></path><path d="m16,5V1h-8v4H2v2h20v-2h-6Zm-6-2h4v2h-4v-2Z" fill="currentColor" stroke-width="0" data-color="color-2"></path></svg></button>
                    </div>
                </div>
                <!-- [新增结束] -->

            </div>
        </div>
    </div>
    
    <!-- ===== [START] CSS HELP MODAL ===== -->
    <div class="modal-overlay" id="jelly-css-help-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group"><span>💡 悬浮球 CSS 自定义模板</span></div>
                <button class="close-btn" data-modal-id="jelly-css-help-modal">&times;</button>
            </div>
            <div class="modal-body" style="gap: 15px;">
                <div class="css-help-section" style="padding: 10px 15px;">
                    <h3 style="color:#777; border-bottom: none; margin-bottom: 0;">悬浮球样式自定义模板</h3>
                    <p style="font-size: 0.95em; color: #889; text-align: center; margin-top: 5px;">
                        选择一个模板，点击“复制”，然后粘贴到下方的输入框内即可。
                    </p>
                </div>

                <!-- 模板 1: 有背景 + 图床链接 -->
                <div class="css-help-section">
                    <h4>方案一: 图片图标 (有背景)</h4>
                    <p style="font-size: 0.9em; color: #889; margin-top: -5px; margin-bottom: 10px;">保留半透明圆形背景，内部显示带辉光的图片。</p>
                    <div class="css-help-text-block">
                        <button class="copy-btn">复制</button>
<pre><code>/* 步骤 1: 自定义辉光动画 */
@keyframes icon-glow {
  0%, 100% {
    /* 修改颜色和范围 (初始/结束状态) */
    filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.7));
  }
  50% {
    /* 修改颜色和范围 (最亮状态) */
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 1));
  }
}

/* 步骤 2: (可选) 自定义球体背景 */
#floating-jellyfish-ball {
  background: rgba(0, 0, 0, 0.4); /* 半透明黑色背景 */
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}
body.dark-mode #floating-jellyfish-ball {
  background: rgba(255, 255, 255, 0.2); /* 夜间模式半透明白色背景 */
  border-color: rgba(255, 255, 255, 0.3);
}

/* 步骤 3: 将图标设为图片并应用动画 */
#floating-jellyfish-ball span {
  display: block;
  width: 65%; /* 调整图标占球体的比例 */
  height: 65%;
  font-size: 0; /* 隐藏原始的 🪼 */
  
  /* 在这里替换为你的图片链接 (推荐透明背景 .png) */
  background-image: url('在这里替换为你的图片链接');
  
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  
  /* 关键：将辉光动画应用到有图片的 span 上 */
  animation: icon-glow 2.5s infinite ease-in-out;
}</code></pre>
                    </div>
                </div>

                <!-- 模板 2: 有背景 + Emoji -->
                <div class="css-help-section">
                    <h4>方案二: Emoji 图标 (有背景)</h4>
                    <p style="font-size: 0.9em; color: #889; margin-top: -5px; margin-bottom: 10px;">保留半透明圆形背景，内部显示带辉光的Emoji。</p>
                    <div class="css-help-text-block">
                        <button class="copy-btn">复制</button>
<pre><code>/* 步骤 1: 自定义辉光动画 */
@keyframes emoji-glow {
  0%, 100% {
    /* Emoji使用text-shadow来发光 (初始/结束状态) */
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.7), 0 0 10px rgba(255, 105, 180, 0.6);
  }
  50% {
    /* (最亮状态) */
    text-shadow: 0 0 10px rgba(255, 255, 255, 1), 0 0 20px rgba(255, 105, 180, 1);
  }
}

/* 步骤 2: (可选) 自定义球体背景 */
#floating-jellyfish-ball {
  background: rgba(255, 182, 193, 0.5); /* 粉色背景 */
  backdrop-filter: blur(5px);
  border: 1px solid rgba(255, 182, 193, 0.8);
  font-size: 0; /* 隐藏原始图标 */
}

/* 步骤 3: 使用伪元素显示Emoji并应用动画 */
#floating-jellyfish-ball::before {
  content: '🌸'; /* 在这里替换为你想要的 Emoji */
  font-size: 28px; /* 在这里调整 Emoji 的大小 */
  
  /* 关键：将辉光动画应用到显示Emoji的伪元素上 */
  animation: emoji-glow 3s infinite ease-in-out;
}</code></pre>
                    </div>
                </div>

                <!-- 模板 3: 无背景 + 图床链接 -->
                <div class="css-help-section">
                    <h4>方案三: 图片图标 (无背景)</h4>
                    <p style="font-size: 0.9em; color: #889; margin-top: -5px; margin-bottom: 10px;">隐藏背景，仅显示发光的图片图标 (此方案完全复刻您提供的参考代码)。</p>
                    <div class="css-help-text-block">
                        <button class="copy-btn">复制</button>
<pre><code>/* 步骤 1: 让球体容器完全透明 */
#floating-jellyfish-ball {
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;

  /* 在这里设定图标的尺寸 */
  width: 48px;
  height: 48px;
  font-size: 0;
}

/* 步骤 2: 定义辉光动画 */
@keyframes icon-glow {
  0%, 100% {
    /* 修改颜色和范围 (初始/结束状态) */
    filter: drop-shadow(0 0 4px rgba(255, 105, 180, 0.7));
  }
  50% {
    /* 修改颜色和范围 (最亮状态) */
    filter: drop-shadow(0 0 14px rgba(255, 20, 147, 1));
  }
}

/* 步骤 3: 将图标设为图片并应用动画 */
#floating-jellyfish-ball span {
  display: block;
  width: 100%;
  height: 100%;
  
  /* 在这里替换为你的图片链接 (推荐透明背景 .png) */
  background-image: url('在这里替换为你的图片链接');
  
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  
  /* 关键: 将辉光动画应用到 span 上 */
  animation: icon-glow 2.5s infinite ease-in-out;
}</code></pre>
                    </div>
                </div>
                
                <!-- 模板 4: 无背景 + Emoji -->
                <div class="css-help-section">
                    <h4>方案四: Emoji 图标 (无背景)</h4>
                    <p style="font-size: 0.9em; color: #889; margin-top: -5px; margin-bottom: 10px;">隐藏背景，仅显示发光的Emoji图标。</p>
                    <div class="css-help-text-block">
                        <button class="copy-btn">复制</button>
<pre><code>/* 步骤 1: 让球体容器完全透明 */
#floating-jellyfish-ball {
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  
  /* 在这里设定图标的点击区域大小 */
  width: 48px;
  height: 48px;
  font-size: 0; /* 隐藏原始图标 */
}

/* 步骤 2: 定义Emoji的辉光动画 */
@keyframes emoji-glow {
  0%, 100% {
    /* Emoji使用text-shadow来发光 (初始/结束状态) */
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.7), 0 0 10px rgba(0, 255, 255, 0.6);
  }
  50% {
    /* (最亮状态) */
    text-shadow: 0 0 10px rgba(255, 255, 255, 1), 0 0 20px rgba(0, 255, 255, 1);
  }
}

/* 步骤 3: 使用伪元素显示Emoji并应用动画 */
#floating-jellyfish-ball::before {
  content: '💎'; /* 在这里替换为你想要的 Emoji */
  font-size: 36px; /* 在这里调整 Emoji 的大小 */
  
  /* 关键：将辉光动画应用到伪元素上 */
  animation: emoji-glow 2.5s infinite ease-in-out;
}</code></pre>
                    </div>
                </div>
                </div>

            </div>
        </div>
    </div>
    <!-- ===== [END] CSS HELP MODAL ===== -->

    <!-- ... 你现有的其他 modal ... -->
    <div class="modal-overlay" id="jelly-css-help-modal">
        <!-- ... CSS 帮助模态框的内容 ... -->
    </div>
    <!-- ===== [END] CSS HELP MODAL ===== -->

    <!-- =============================================================== -->
    <!-- ================ [新增] iOS 用户首次访问提示模态框 ================ -->
    <!-- =============================================================== -->
    <div class="modal-overlay" id="iosWarningModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>⚠️ iOS 用户重要提示</span></div>
            </div>
            <div class="modal-body">
                <p>尊敬的 iOS 用户，由于系统对 Web 应用沙箱（Sandbox）环境的严格限制，当您将本应用“添加到主屏幕”后，每次从后台彻底关闭应用（上划清除）都可能导致 iframe 内的项目数据被清除。</p>
                <div class="important-note">
                    <p><strong>强烈建议您在使用依赖数据保存的项目前，先进行少量操作测试，确保数据能够正常导入、导出和保存，避免重要数据意外丢失。</strong></p>
                </div>
                <p style="margin-top: 15px;">为最大程度保障数据安全，建议：</p>
                <ol style="margin-left: 20px; line-height: 1.7;">
                    <li><strong>使用“文件版”上传项目</strong>：对于您拥有源代码的项目，通过“管理项目”中的“上传项目”功能进行上传。</li>
                    <li><strong>使用浏览器打开</strong>：对于外部网站链接，在添加或编辑时，开启“在新标签页中打开”开关。项目将通过Safari等系统浏览器打开，数据由浏览器自身管理，更稳定。</li>
                </ol>
                <button id="iosWarningConfirmBtn" class="modal-button" style="margin-top: 15px;">我已了解风险</button>
            </div>
        </div>
    </div>

    <!-- ===== [START] MEMORY MODAL ===== -->
    <div class="modal-overlay" id="memoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group">
                    <span id="memory-modal-title">记忆</span>
                    <span id="memory-sync-status" style="font-size: 12px; font-weight: normal; margin-left: 8px;"></span>
                </div>
                <button class="close-btn" data-modal-id="memoryModal">&times;</button>
            </div>
            <div class="app-container" id="memoryAppContainer">
                <!-- HUB / 入口页面 -->
                <div id="hub-view" class="page active">
                    <div id="hub-view-content">
                        <button data-action="goto-memo" class="hub-btn">备忘录</button>
                        <button data-action="goto-album" class="hub-btn">相册</button>
                        <button data-action="goto-cloud" class="hub-btn">文件夹</button>
                    </div>
                </div>
            <!-- MEMO / 备忘录部分 -->
            <div id="memo-section" class="page">
                <div id="folder-view" class="page active">
                    <div class="page-header">
                        <button data-action="back-to-hub" class="header-btn back-btn">&#10094;</button>
                        <h1 class="title">我的备忘录</h1>
                        <!-- [新增] 全局搜索输入框 -->
                        <input type="search" id="global-memo-search-input" class="memo-search-input" placeholder="全局搜索备忘录..." style="display: none;">
                        <button id="global-memo-search-cancel" class="header-btn" style="display:none; color: var(--hold-border);">取消</button>
                        
                        <div class="header-controls">
                             <!-- [新增] 全局搜索按钮 -->
                            <button data-action="toggle-global-memo-search" class="header-btn manage-btn" style="padding: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="18px" height="18px" viewBox="0 0 18 18"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1083 11.1083C11.4012 10.8154 11.876 10.8154 12.1689 11.1083L16.2803 15.2197C16.5732 15.5126 16.5732 15.9874 16.2803 16.2803C15.9874 16.5732 15.5126 16.5732 15.2197 16.2803L11.1083 12.1689C10.8154 11.876 10.8154 11.4012 11.1083 11.1083Z" fill="currentColor"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 7.75C1.5 4.29829 4.29829 1.5 7.75 1.5C11.2017 1.5 14 4.29829 14 7.75C14 11.2017 11.2017 14 7.75 14C4.29829 14 1.5 11.2017 1.5 7.75ZM7.75 3C5.12671 3 3 5.12671 3 7.75C3 10.3733 5.12671 12.5 7.75 12.5C10.3733 12.5 12.5 10.3733 12.5 7.75C12.5 5.12671 10.3733 3 7.75 3Z" fill="currentColor"></path></svg>
                            </button>
                            <button data-action="toggle-memo-manage" class="header-btn manage-btn">管理</button>
                        </div>
                    </div>
                    <!-- 将 #folder-list-container 移动到 notes-list-container 一样的结构里，以便共用布局 -->
                    <div id="folder-list-container" class="list-container"></div>
                    <button data-action="add-memo-folder" class="fab">+</button>
                    <div id="memo-management-controls" class="management-controls">
                         <button data-action="select-all-memo" class="modal-button">全选</button>
                         <button data-action="delete-selected-memo" class="modal-button" style="color:#f56565;">删除选中</button>
                    </div>
                </div>
                <div id="notes-view" class="page">
                    <div class="page-header">
                        <button data-action="back-to-memo-folders" class="header-btn back-btn">&#10094;</button>
                        <h1 id="notes-view-title" class="title">文件夹</h1>
                        <!-- [新增] 局部搜索输入框 -->
                        <input type="search" id="local-memo-search-input" class="memo-search-input" placeholder="在当前文件夹中搜索..." style="display: none;">
                        <button id="local-memo-search-cancel" class="header-btn" style="display: none; color: var(--hold-border);">取消</button>
                        <div class="header-controls">
                            <!-- [新增] 局部搜索按钮 -->
                             <button data-action="toggle-local-memo-search" class="header-btn manage-btn" style="padding: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="18px" height="18px" viewBox="0 0 18 18"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1083 11.1083C11.4012 10.8154 11.876 10.8154 12.1689 11.1083L16.2803 15.2197C16.5732 15.5126 16.5732 15.9874 16.2803 16.2803C15.9874 16.5732 15.5126 16.5732 15.2197 16.2803L11.1083 12.1689C10.8154 11.876 10.8154 11.4012 11.1083 11.1083Z" fill="currentColor"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 7.75C1.5 4.29829 4.29829 1.5 7.75 1.5C11.2017 1.5 14 4.29829 14 7.75C14 11.2017 11.2017 14 7.75 14C4.29829 14 1.5 11.2017 1.5 7.75ZM7.75 3C5.12671 3 3 5.12671 3 7.75C3 10.3733 5.12671 12.5 7.75 12.5C10.3733 12.5 12.5 10.3733 12.5 7.75C12.5 5.12671 10.3733 3 7.75 3Z" fill="currentColor"></path></svg>
                            </button>
                            <button data-action="toggle-note-manage" class="header-btn manage-btn">管理</button>
                        </div>
                    </div>
                    <div id="notes-list-container" class="list-container"></div>
                    <button data-action="add-note" class="fab">+</button>
                    <div id="note-management-controls" class="management-controls">
                         <button data-action="select-all-notes" class="modal-button">全选</button>
                         <button data-action="move-selected-notes" class="modal-button">移动选中</button>
                         <button data-action="delete-selected-notes" class="modal-button" style="color:#f56565;">删除选中</button>
                    </div>
                </div>
                    <div id="note-editor-view" class="page">
                        <div class="editor-header">
                            <button data-action="cancel-note" class="editor-btn">取消</button>
                            <div>
                                <button data-action="delete-note" class="editor-btn" style="display: none;">删除</button>
                                <button data-action="save-note" class="editor-btn">完成</button>
                            </div>
                        </div>
                        <div class="editor-content">
                            <input type="text" id="note-title-input" placeholder="标题">
                            <div id="note-content-editor" contenteditable="true" placeholder="在这里输入内容..."></div>
                        </div>
                        <!-- [V3] 最终版工具栏布局：所有按钮平铺，由 Flexbox 自动均分间距 -->
                        <div class="memo-toolbar">
                            <button class="toolbar-btn" data-command="todo" title="待办清单"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="20px" height="20px" viewBox="0 0 20 20"><polyline points="3 6 4.5 7.5 8 3.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" data-color="color-2"></polyline><rect x="3" y="12" width="4" height="4" rx="1" ry="1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" fill="currentColor"></rect><line x1="11" y1="6" x2="17" y2="6" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" data-color="color-2"></line><line x1="11" y1="14" x2="17" y2="14" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></line></svg></button>
                            <button class="toolbar-btn" data-command="bold" title="加粗">B</button>
                            <button class="toolbar-btn" data-command="italic" title="斜体">I</button>
                            <button class="toolbar-btn" data-command="underline" title="下划线">U</button>
                            <button class="toolbar-btn strikethrough" data-command="strikeThrough" title="删除线">S</button>
                            <button class="toolbar-btn font-size-icon" data-command="fontSize" title="调整字号">A<small>A</small></button>
                            <button class="toolbar-btn" data-command="createCodeBlock" title="代码块"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="20px" height="20px" viewBox="0 0 20 20"><path d="m14,3H6c-1.657,0-3,1.343-3,3v2h14v-2c0-1.657-1.343-3-3-3Zm-8,3c-.552,0-1-.448-1-1s.448-1,1-1,1,.448,1,1-.448,1-1,1Zm3,0c-.552,0-1-.448-1-1s.448-1,1-1,1,.448,1,1-.448,1-1,1Z" stroke-width="0" fill="currentColor"></path><polyline points="12.5 12 10 14.5 12.5 17" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" data-color="color-2"></polyline><path d="m17,8.845v-2.845c0-1.657-1.343-3-3-3H6c-1.657,0-3,1.343-3,3v8c0,1.657,1.343,3,3,3h1.55l-.025-.025" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><polyline points="15.5 17 18 14.5 15.5 12" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" data-color="color-2"></polyline></svg></button>
<button class="toolbar-btn" data-command="copyContent" title="复制备忘录正文"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="20px" height="20px" viewBox="0 0 20 20"><path d="m4,7h3c.552,0,1-.448,1-1v-3" fill="#1c1f21" stroke="#1c1f21" stroke-linejoin="round" stroke-width="2" data-color="color-2"></path><path d="m16,14v-8c0-1.657-1.343-3-3-3h-4.586c-.265,0-.52.105-.707.293l-3.414,3.414c-.188.188-.293.442-.293.707v6.586c0,1.657,1.343,3,3,3h6c1.657,0,3-1.343,3-3Z" fill="none" stroke="#1c1f21" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button>
                        </div>

                        <!-- [V2] 重新设计的、更小巧的字号滑块弹窗 -->
                        <div id="fontSizeSliderPopup" style="display: none;">
                            <input type="range" id="fontSizeSlider" min="12" max="28" value="16">
                        </div>

                        <!-- ★★★ [最终修正] 一键回顶按钮 (仅旋转图标) V6 ★★★ -->
                        <button id="memo-back-to-top" class="memo-fab-back-to-top" title="回到顶部">
                            <span class="back-to-top-icon">➤</span>
                        </button>
                    </div>
                </div>
                <!-- ALBUM / 相册部分 -->
                <div id="album-section" class="page">
                    <div id="album-folder-view" class="page active">
                        <div class="page-header">
                            <button data-action="back-to-hub" class="header-btn back-btn">&#10094;</button>
                            <h1 class="title">我的相册</h1>
                            <div class="header-controls">
                               <button data-action="wander-global" class="header-btn wander-btn">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
      <title>star-sparkle</title>
      <g fill="none">
        <path d="M20.3174 8.19531C20.0357 8.8823 19.5416 9.61008 18.9248 10.332C17.6628 11.8091 15.7312 13.4472 13.4355 14.9248C11.14 16.4022 8.8494 17.4826 6.98242 18.0195C6.31873 18.2104 5.67868 18.3394 5.09375 18.3857L5.45996 16.3232C5.74837 16.2727 6.07264 16.1993 6.42969 16.0967C8.06215 15.6272 10.1747 14.6455 12.3535 13.2432C14.5326 11.8406 16.3019 10.3247 17.4053 9.0332C17.7661 8.61089 18.0377 8.22999 18.2305 7.90234L20.3174 8.19531Z" fill="url(#star-sparkle_grad_0-global)" data-glass="origin" mask="url(#star-sparkle_mask-global)"></path>
        <path d="M20.3174 8.19531C20.0357 8.8823 19.5416 9.61008 18.9248 10.332C17.6628 11.8091 15.7312 13.4472 13.4355 14.9248C11.14 16.4022 8.8494 17.4826 6.98242 18.0195C6.31873 18.2104 5.67868 18.3394 5.09375 18.3857L5.45996 16.3232C5.74837 16.2727 6.07264 16.1993 6.42969 16.0967C8.06215 15.6272 10.1747 14.6455 12.3535 13.2432C14.5326 11.8406 16.3019 10.3247 17.4053 9.0332C17.7661 8.61089 18.0377 8.22999 18.2305 7.90234L20.3174 8.19531Z" fill="url(#star-sparkle_grad_0-global)" data-glass="clone" filter="url(#star-sparkle_filter-global)" clip-path="url(#star-sparkle_clip-global)"></path>
        <path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="url(#star-sparkle_grad_1-global)" data-glass="blur"></path>
        <path d="M10.6641 2.61911C11.2207 1.52809 12.7793 1.52809 13.336 2.61911L15.5079 6.87498C15.7301 7.31065 16.1505 7.61058 16.6348 7.67869L21.4083 8.34959C22.654 8.5247 23.1438 10.0637 22.2286 10.9267L18.839 14.123C18.4713 14.4698 18.3034 14.9789 18.3917 15.4766L19.2003 20.0371C19.4097 21.2177 18.2249 22.1382 17.1475 21.6846L17.044 21.6367L12.6797 19.418C12.2525 19.2008 11.7475 19.2008 11.3203 19.418L6.95602 21.6367L6.85251 21.6846C5.80984 22.1236 4.6659 21.2757 4.78315 20.1504L4.79975 20.0371L5.60835 15.4766C5.68559 15.0411 5.56634 14.5972 5.28901 14.2607L5.16108 14.123L1.7714 10.9267C0.884703 10.0905 1.31671 8.62007 2.47746 8.3701L2.59172 8.34959L7.36521 7.67869C7.84952 7.61057 8.26991 7.31064 8.49217 6.87498L10.6641 2.61911ZM12.668 2.95993C12.3897 2.41442 11.6104 2.41442 11.332 2.95993L9.16015 7.2158C8.82676 7.86931 8.19619 8.31969 7.4697 8.42185L2.69621 9.09275C2.07335 9.18031 1.82846 9.9493 2.28605 10.3808L5.67574 13.5771C6.22733 14.0974 6.47906 14.8609 6.34664 15.6074L5.53804 20.168C5.42998 20.7772 6.06456 21.248 6.61618 20.9678L10.9805 18.749C11.6212 18.4234 12.3789 18.4234 13.0196 18.749L17.3839 20.9678C17.9355 21.248 18.5701 20.7772 18.462 20.168L17.6534 15.6074C17.521 14.8609 17.7727 14.0974 18.3243 13.5771L21.714 10.3808C22.1716 9.9493 21.9267 9.18031 21.3038 9.09275L16.5303 8.42185C15.8038 8.31969 15.1733 7.86931 14.8399 7.2158L12.668 2.95993Z" fill="url(#star-sparkle_grad_2-global)"></path>
        <path d="M6.07314 2.88824L5.44324 1.30101C5.28398 0.8997 4.71603 0.89965 4.55669 1.30094L3.92644 2.88824C3.91951 2.90563 3.90577 2.91938 3.88838 2.9263L2.30091 3.55671C1.89969 3.71604 1.8997 4.28396 2.30092 4.44329L3.88838 5.0737C3.90577 5.08063 3.91951 5.09437 3.92644 5.11176L4.55668 6.69906C4.71602 7.10035 5.28397 7.1003 5.44324 6.69899L6.07314 5.11176C6.08008 5.0943 6.094 5.08061 6.11147 5.0737L7.69907 4.4433C8.10031 4.28398 8.10031 3.71602 7.69907 3.5567L6.11147 2.9263C6.094 2.91939 6.08008 2.9057 6.07314 2.88824Z" fill="url(#star-sparkle_grad_3-global)"></path>
        <path d="M23.5 16.25C23.5 16.9404 22.9404 17.5 22.25 17.5C21.5596 17.5 21 16.9404 21 16.25C21 15.5596 21.5596 15 22.25 15C22.9404 15 23.5 15.5596 23.5 16.25Z" fill="url(#star-sparkle_grad_4-global)"></path>
        <path d="M18.2307 4.89743C18.949 4.93039 19.7944 5.15041 20.2727 5.89353L20.3548 6.03415C20.7312 6.74332 20.584 7.53845 20.3333 8.16404C20.3289 8.17492 20.3231 8.18536 20.3186 8.19626L18.2327 7.90329C18.3369 7.72619 18.4187 7.56496 18.4768 7.4199C18.578 7.16745 18.5847 7.03502 18.5813 6.98142C18.5338 6.95616 18.4108 6.90798 18.1399 6.89548C17.6948 6.87509 17.0493 6.96563 16.2268 7.20212C14.5943 7.67159 12.482 8.65321 10.303 10.0556C8.12386 11.4582 6.3547 12.974 5.25125 14.2656C4.69526 14.9164 4.34675 15.4662 4.18093 15.8799C4.07977 16.1323 4.07313 16.2646 4.07644 16.3183C4.12416 16.3436 4.24758 16.3918 4.51882 16.4043C4.76947 16.4157 5.08313 16.3909 5.45632 16.3261L5.09011 18.3867C4.86005 18.4047 4.63829 18.412 4.42703 18.4023C3.70884 18.3694 2.86334 18.1492 2.38504 17.4062C1.90698 16.6632 2.05709 15.803 2.32449 15.1357C2.60377 14.4391 3.10509 13.7002 3.73172 12.9668C4.99373 11.4897 6.92524 9.85163 9.22097 8.374C11.5166 6.89649 13.8071 5.81617 15.6741 5.27927C16.6011 5.01275 17.4811 4.86312 18.2307 4.89743Z" fill="url(#star-sparkle_grad_5-global)"></path>
        <defs>
          <linearGradient id="star-sparkle_grad_0-global" x1="12.706" y1="7.902" x2="12.706" y2="18.386" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_1-global" x1="12" y1="1.801" x2="12" y2="21.802" gradientUnits="userSpaceOnUse"><stop stop-color="#E3E3E5" stop-opacity=".6"></stop><stop offset="1" stop-color="#BBBBC0" stop-opacity=".6"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_2-global" x1="12" y1="1.801" x2="12" y2="13.384" gradientUnits="userSpaceOnUse"><stop stop-color="#fff"></stop><stop offset="1" stop-color="#fff" stop-opacity="0"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_3-global" x1="5" y1="1" x2="5" y2="7" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_4-global" x1="22.25" y1="15" x2="22.25" y2="17.5" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_5-global" x1="11.329" y1="4.893" x2="11.329" y2="18.407" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient>
          <filter id="star-sparkle_filter-global" x="-100%" y="-100%" width="400%" height="400%" filterUnits="objectBoundingBox" primitiveUnits="userSpaceOnUse"><feGaussianBlur stdDeviation="2" x="0%" y="0%" width="100%" height="100%" in="SourceGraphic" edgeMode="none" result="blur"></feGaussianBlur></filter>
          <clipPath id="star-sparkle_clip-global"><path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="url(#star-sparkle_grad_1-global)"></path></clipPath>
          <mask id="star-sparkle_mask-global"><rect width="100%" height="100%" fill="#FFF"></rect><path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="#000"></path></mask>
        </defs>
      </g>
    </svg>
</button>
                                <button data-action="toggle-album-manage" class="header-btn manage-btn">管理</button>
                            </div>
                        </div>
                        <div id="album-list-container" class="list-container"></div>
                        <button data-action="add-album-folder" class="fab">+</button>
                        <div id="album-management-controls" class="management-controls">
                             <button data-action="select-all-album" class="modal-button">全选</button>
                             <button data-action="delete-selected-album" class="modal-button" style="color:#f56565;">删除选中</button>
                        </div>
                    </div>
                    <div id="photo-grid-view" class="page">
                         <div class="page-header">
                            <button data-action="back-to-album-folders" class="header-btn back-btn">&#10094;</button>
                            <h1 id="photo-grid-title" class="title">相册</h1>
                            <div class="header-controls">
<button data-action="wander-global" class="header-btn wander-btn">
<button data-action="wander-local" class="header-btn wander-btn">
    <!-- 这是一个新的、唯一的SVG图标，用于相册内部，解决了ID冲突问题 -->
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
      <title>star-sparkle</title>
      <g fill="none">
        <path d="M20.3174 8.19531C20.0357 8.8823 19.5416 9.61008 18.9248 10.332C17.6628 11.8091 15.7312 13.4472 13.4355 14.9248C11.14 16.4022 8.8494 17.4826 6.98242 18.0195C6.31873 18.2104 5.67868 18.3394 5.09375 18.3857L5.45996 16.3232C5.74837 16.2727 6.07264 16.1993 6.42969 16.0967C8.06215 15.6272 10.1747 14.6455 12.3535 13.2432C14.5326 11.8406 16.3019 10.3247 17.4053 9.0332C17.7661 8.61089 18.0377 8.22999 18.2305 7.90234L20.3174 8.19531Z" fill="url(#star-sparkle_grad_0-album-inner)" data-glass="origin" mask="url(#star-sparkle_mask-album-inner)"></path>
        <path d="M20.3174 8.19531C20.0357 8.8823 19.5416 9.61008 18.9248 10.332C17.6628 11.8091 15.7312 13.4472 13.4355 14.9248C11.14 16.4022 8.8494 17.4826 6.98242 18.0195C6.31873 18.2104 5.67868 18.3394 5.09375 18.3857L5.45996 16.3232C5.74837 16.2727 6.07264 16.1993 6.42969 16.0967C8.06215 15.6272 10.1747 14.6455 12.3535 13.2432C14.5326 11.8406 16.3019 10.3247 17.4053 9.0332C17.7661 8.61089 18.0377 8.22999 18.2305 7.90234L20.3174 8.19531Z" fill="url(#star-sparkle_grad_0-album-inner)" data-glass="clone" filter="url(#star-sparkle_filter-album-inner)" clip-path="url(#star-sparkle_clip-album-inner)"></path>
        <path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="url(#star-sparkle_grad_1-album-inner)" data-glass="blur"></path>
        <path d="M10.6641 2.61911C11.2207 1.52809 12.7793 1.52809 13.336 2.61911L15.5079 6.87498C15.7301 7.31065 16.1505 7.61058 16.6348 7.67869L21.4083 8.34959C22.654 8.5247 23.1438 10.0637 22.2286 10.9267L18.839 14.123C18.4713 14.4698 18.3034 14.9789 18.3917 15.4766L19.2003 20.0371C19.4097 21.2177 18.2249 22.1382 17.1475 21.6846L17.044 21.6367L12.6797 19.418C12.2525 19.2008 11.7475 19.2008 11.3203 19.418L6.95602 21.6367L6.85251 21.6846C5.80984 22.1236 4.6659 21.2757 4.78315 20.1504L4.79975 20.0371L5.60835 15.4766C5.68559 15.0411 5.56634 14.5972 5.28901 14.2607L5.16108 14.123L1.7714 10.9267C0.884703 10.0905 1.31671 8.62007 2.47746 8.3701L2.59172 8.34959L7.36521 7.67869C7.84952 7.61057 8.26991 7.31064 8.49217 6.87498L10.6641 2.61911ZM12.668 2.95993C12.3897 2.41442 11.6104 2.41442 11.332 2.95993L9.16015 7.2158C8.82676 7.86931 8.19619 8.31969 7.4697 8.42185L2.69621 9.09275C2.07335 9.18031 1.82846 9.9493 2.28605 10.3808L5.67574 13.5771C6.22733 14.0974 6.47906 14.8609 6.34664 15.6074L5.53804 20.168C5.42998 20.7772 6.06456 21.248 6.61618 20.9678L10.9805 18.749C11.6212 18.4234 12.3789 18.4234 13.0196 18.749L17.3839 20.9678C17.9355 21.248 18.5701 20.7772 18.462 20.168L17.6534 15.6074C17.521 14.8609 17.7727 14.0974 18.3243 13.5771L21.714 10.3808C22.1716 9.9493 21.9267 9.18031 21.3038 9.09275L16.5303 8.42185C15.8038 8.31969 15.1733 7.86931 14.8399 7.2158L12.668 2.95993Z" fill="url(#star-sparkle_grad_2-album-inner)"></path>
        <path d="M6.07314 2.88824L5.44324 1.30101C5.28398 0.8997 4.71603 0.89965 4.55669 1.30094L3.92644 2.88824C3.91951 2.90563 3.90577 2.91938 3.88838 2.9263L2.30091 3.55671C1.89969 3.71604 1.8997 4.28396 2.30092 4.44329L3.88838 5.0737C3.90577 5.08063 3.91951 5.09437 3.92644 5.11176L4.55668 6.69906C4.71602 7.10035 5.28397 7.1003 5.44324 6.69899L6.07314 5.11176C6.08008 5.0943 6.094 5.08061 6.11147 5.0737L7.69907 4.4433C8.10031 4.28398 8.10031 3.71602 7.69907 3.5567L6.11147 2.9263C6.094 2.91939 6.08008 2.9057 6.07314 2.88824Z" fill="url(#star-sparkle_grad_3-album-inner)"></path>
        <path d="M23.5 16.25C23.5 16.9404 22.9404 17.5 22.25 17.5C21.5596 17.5 21 16.9404 21 16.25C21 15.5596 21.5596 15 22.25 15C22.9404 15 23.5 15.5596 23.5 16.25Z" fill="url(#star-sparkle_grad_4-album-inner)"></path>
        <path d="M18.2307 4.89743C18.949 4.93039 19.7944 5.15041 20.2727 5.89353L20.3548 6.03415C20.7312 6.74332 20.584 7.53845 20.3333 8.16404C20.3289 8.17492 20.3231 8.18536 20.3186 8.19626L18.2327 7.90329C18.3369 7.72619 18.4187 7.56496 18.4768 7.4199C18.578 7.16745 18.5847 7.03502 18.5813 6.98142C18.5338 6.95616 18.4108 6.90798 18.1399 6.89548C17.6948 6.87509 17.0493 6.96563 16.2268 7.20212C14.5943 7.67159 12.482 8.65321 10.303 10.0556C8.12386 11.4582 6.3547 12.974 5.25125 14.2656C4.69526 14.9164 4.34675 15.4662 4.18093 15.8799C4.07977 16.1323 4.07313 16.2646 4.07644 16.3183C4.12416 16.3436 4.24758 16.3918 4.51882 16.4043C4.76947 16.4157 5.08313 16.3909 5.45632 16.3261L5.09011 18.3867C4.86005 18.4047 4.63829 18.412 4.42703 18.4023C3.70884 18.3694 2.86334 18.1492 2.38504 17.4062C1.90698 16.6632 2.05709 15.803 2.32449 15.1357C2.60377 14.4391 3.10509 13.7002 3.73172 12.9668C4.99373 11.4897 6.92524 9.85163 9.22097 8.374C11.5166 6.89649 13.8071 5.81617 15.6741 5.27927C16.6011 5.01275 17.4811 4.86312 18.2307 4.89743Z" fill="url(#star-sparkle_grad_5-album-inner)"></path>
        <defs>
          <linearGradient id="star-sparkle_grad_0-album-inner" x1="12.706" y1="7.902" x2="12.706" y2="18.386" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_1-album-inner" x1="12" y1="1.801" x2="12" y2="21.802" gradientUnits="userSpaceOnUse"><stop stop-color="#E3E3E5" stop-opacity=".6"></stop><stop offset="1" stop-color="#BBBBC0" stop-opacity=".6"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_2-album-inner" x1="12" y1="1.801" x2="12" y2="13.384" gradientUnits="userSpaceOnUse"><stop stop-color="#fff"></stop><stop offset="1" stop-color="#fff" stop-opacity="0"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_3-album-inner" x1="5" y1="1" x2="5" y2="7" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_4-album-inner" x1="22.25" y1="15" x2="22.25" y2="17.5" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient>
          <linearGradient id="star-sparkle_grad_5-album-inner" x1="11.329" y1="4.893" x2="11.329" y2="18.407" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient>
          <filter id="star-sparkle_filter-album-inner" x="-100%" y="-100%" width="400%" height="400%" filterUnits="objectBoundingBox" primitiveUnits="userSpaceOnUse"><feGaussianBlur stdDeviation="2" x="0%" y="0%" width="100%" height="100%" in="SourceGraphic" edgeMode="none" result="blur"></feGaussianBlur></filter>
          <clipPath id="star-sparkle_clip-album-inner"><path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="url(#star-sparkle_grad_1-album-inner)"></path></clipPath>
          <mask id="star-sparkle_mask-album-inner"><rect width="100%" height="100%" fill="#FFF"></rect><path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="#000"></path></mask>
        </defs>
      </g>
    </svg>
</button>
                                <button data-action="toggle-photo-manage" class="header-btn manage-btn">管理</button>
                            </div>
                        </div>
                        <div id="photo-list-container" class="list-container"></div>
                        <label for="photo-uploader" data-action="add-photo" class="fab">+</label>
                        <input type="file" id="photo-uploader" multiple accept="image/*,video/*" style="display: none;">
                        <div id="photo-management-controls" class="management-controls">
                             <button data-action="select-all-photos" class="modal-button">全选</button>
                             <button data-action="move-selected-photos" class="modal-button">移动选中</button>
                             <button data-action="delete-selected-photos" class="modal-button" style="color:#f56565;">删除选中</button>
                        </div>
                    </div>
                </div>
                <!-- CLOUD DRIVE / 文件夹 -->
                <div id="cloud-drive-section" class="page">
                    <div class="page-header">
                        <button data-action="back-to-hub" class="header-btn back-btn">&#10094;</button>
                        <h1 class="title">文件夹</h1>
                        <!-- [新增] 百度网盘设置按钮 -->
                        <button data-action="open-baidu-settings" class="header-btn baidu-settings-btn" title="百度网盘设置"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24"><path d="m23,13.75v-3.5l-2.384-.841c-.176-.583-.407-1.142-.691-1.668l1.091-2.281-2.475-2.475-2.281,1.091c-.527-.284-1.086-.515-1.668-.691l-.841-2.384h-3.5l-.841,2.384c-.583.176-1.142.407-1.668.691l-2.281-1.091-2.475,2.475,1.091,2.281c-.284.527-.515,1.086-.691,1.668l-2.384.841v3.5l2.384.841c.176.583.407,1.142.691,1.668l-1.091,2.281,2.475,2.475,2.281-1.091c.527.284,1.086.515,1.668.691l.841,2.384h3.5l.841-2.384c.583-.176,1.142-.407,1.668-.691l2.281,1.091,2.475-2.475-1.091-2.281c.284-.527-.515,1.086.691-1.668l2.384-.841Zm-11,2.25c-2.206,0-4-1.794-4-4s1.794-4,4-4,4,1.794,4,4-1.794,4-4,4Z" stroke-width="0" fill="currentColor"></path></svg></button>
                    </div>
                    <div class="list-container">
                        <select id="categorySelector" class="modal-select"></select>
                        <select id="projectSelector" class="modal-select hidden"></select>
                        <div class="file-upload-section">
                            <input type="file" id="fileUploader"/>
                            <div class="file-select-wrapper">
                                <button id="selectFileBtn" class="modal-button">选择文件</button>
                                <span id="selectedFileName" class="status-text">未选择任何文件</span>
                            </div>
                            <input type="text" id="fileNameInput" class="modal-input" placeholder="可修改文件名（可选）"/>
                            
                            <!-- [重构] 将上传按钮和标签切换按钮放在一行 -->
                            <div class="upload-actions-row">
                                <button id="tag-actions-toggle-btn" class="tag-actions-toggle-btn">
                                    <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="18px" height="18px" viewBox="0 0 18 18"><path d="m2.25,4.25h5.586c.265,0,.52.105.707.293l5.1065,5.1065c.781.781.781,2.047,0,2.828l-3.172,3.172c-.781.781-2.047.781-2.828,0l-5.1065-5.1065c-.188-.188-.293-.442-.293-.707v-5.586Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"></path><path d="m3.75,1.25h5.586c.265,0,.52.105.707.293l5.7705,5.7705" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" data-color="color-2"></path><circle cx="5.75" cy="7.75" r="1.25" fill="currentColor" stroke-width="0" data-color="color-2"></circle></svg>
                                </button>
                                <button id="uploadBtn" class="modal-button">上传文件</button>
                            </div>

                            <div id="progressContainer" class="progress-container">
                                <div class="progress-bar-wrapper">
                                    <div id="uploadProgressBar" class="progress-bar"></div>
                                </div>
                                <button id="upload-cancel-btn" title="终止上传">✖</button>
                            </div>
                        </div>

                        <!-- [重构] 可向下展开的标签操作容器 -->
                        <div id="tag-actions-wrapper" class="tag-actions-container">
                            <button data-action="open-tag-manager" class="modal-button tag-action-btn">添加/管理标签</button>
                            <button data-action="toggle-tag-binding" class="modal-button tag-action-btn">批量绑定标签</button>
                            <button data-action="open-view-by-tag" class="modal-button tag-action-btn">按标签查看</button>
                        </div>
                        <div id="file-list-container">
                            <ul id="fileList"></ul>
                            <div id="fileListStatus" class="file-list-status">请选择一个分类</div>
                        </div>
                        
                        <!-- [新增] 标签批量绑定操作栏 -->
                        <div id="tag-binding-controls" class="management-controls">
                            <select id="tag-binding-selector" class="modal-select" style="flex-grow: 2;"></select>
                            <button data-action="add-tags-to-selected-files" class="modal-button" style="color:var(--hold-border); padding: 12px 15px;">添加</button>
                            <button data-action="remove-tags-from-selected-files" class="modal-button" style="color:#f56565; padding: 12px 15px;">移除</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- 文件夹(备忘录/相册)模态框 -->
    <div id="memoryFolderModal" class="modal-overlay">
        <div class="modal-content">
            <div id="folder-modal-title" class="modal-header">新文件夹</div>
            <div class="modal-body"> <input type="text" id="folder-name-input" class="modal-input" placeholder="文件夹名称"> </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button data-action="close-folder-modal" class="modal-button">取消</button>
                <button data-action="save-folder" class="modal-button" style="color:var(--hold-border)">保存</button>
            </div>
        </div>
    </div>
    <!-- 上传照片时编辑信息模态框 -->
    <div id="memoryPhotoDetailsModal" class="modal-overlay">
        <div class="modal-content">
            <div id="photo-details-modal-title" class="modal-header">添加照片信息</div>
            <div class="modal-body">
                <div id="photoset-toggle-container">
                    <label class="header-toggle-group">
                        <input type="checkbox" id="create-photoset-toggle">
                        <span>创建照片集</span>
                    </label>
                </div>
                <img id="upload-thumbnail" src="" alt="upload thumbnail">
                <input type="text" id="photo-title-input" class="modal-input" placeholder="标题 (选填)">
                <textarea id="photo-desc-input" class="modal-textarea" placeholder="描述 (选填)"></textarea>
            </div>
            <div class="modal-footer" style="justify-content: space-between;">
                <button data-action="cancel-photo-upload" class="modal-button" style="color:#f56565;">取消</button>
                <div>
                    <button data-action="skip-photo-details" class="modal-button">跳过</button>
                    <button data-action="save-photo-details" class="modal-button primary">保存</button>
                </div>
            </div>
        </div>
    </div>

    <!-- [新增] 移动照片模态框 -->
    <div id="movePhotosModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title-group">移动到...</div>
            </div>
            <div class="modal-body">
                <select id="album-destination-selector" class="modal-select"></select>
            </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button data-action="close-move-modal" class="modal-button">取消</button>
                <button data-action="confirm-move-photos" class="modal-button" style="color:var(--hold-border)">确认移动</button>
            </div>
        </div>
    </div>
    <!-- [新增] 移动备忘录模态框 -->
    <div id="moveNotesModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title-group">移动到...</div>
            </div>
            <div class="modal-body">
                <select id="memo-destination-selector" class="modal-select"></select>
            </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button data-action="close-move-notes-modal" class="modal-button">取消</button>
                <button data-action="confirm-move-notes" class="modal-button" style="color:var(--hold-border)">确认移动</button>
            </div>
        </div>
    </div>
    <!-- [新增] 备忘录文件导入模态框 -->
    <div id="memoImportModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header">
                <div class="modal-title-group">导入文本文件</div>
                <button class="close-btn" data-modal-id="memoImportModal">&times;</button>
            </div>
            <div class="modal-body" style="gap: 15px;">
                <p style="font-size: 14px; color: #889;">支持导入 .txt, .xml, .doc, .docx 文件，将提取纯文本内容。</p>
                <div class="file-select-wrapper">
                    <input type="file" id="memoFilePicker" accept=".txt,.xml,.doc,.docx" multiple style="display: none;">
                    <button id="memoFilePickerBtn" class="modal-button" style="width: 100%;">选择文件</button>
                </div>
                <div id="memoImportStatus" class="status-text" style="text-align: left; min-height: 20px; margin-bottom: 5px;"></div>
                <!-- [新增] 用于显示已选文件名的列表容器 -->
                <div id="memo-import-file-list" style="max-height: 110px; overflow-y: auto; padding: 8px; border-radius: 8px; background: rgba(0,0,0,0.03); display: none;"></div>
                <div class="progress-container" id="memoImportProgressContainer">
                    <div class="progress-bar-wrapper">
                        <div id="memoImportProgressBar" class="progress-bar"></div>
                    </div>
                    <button id="memoImportCancelBtn" title="取消导入">✖</button>
                </div>
            </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button data-action="close-memo-import-modal" class="modal-button">取消</button>
                <button id="confirmMemoImportBtn" class="modal-button" style="color:var(--hold-border)" disabled>导入</button>
            </div>
        </div>
    </div>
    <!-- [新增结束] -->
    <!-- ===== [END] MEMORY MODAL ===== -->

    <!-- 全屏照片查看器 -->
    <div id="memoryPhotoViewerOverlay">
        <div class="viewer-header"> 
            <span class="counter" id="viewer-counter"></span>
            <button data-action="close-viewer" class="viewer-btn">✕</button> 
        </div>
        <div class="viewer-content">
            <button data-action="prev-photo" id="prev-photo-btn" class="viewer-btn nav-arrow">&#10094;</button>
            <div id="viewer-img-container"><img id="viewer-img" src="" alt="渲染中..."></div>
            <button data-action="next-photo" id="next-photo-btn" class="viewer-btn nav-arrow">&#10095;</button>
        </div>
        <div class="viewer-footer">
            <h3 id="viewer-title"></h3>
            <p id="viewer-description"></p>
            <p id="viewer-timestamp"></p>
            <!-- [修改] 将下载按钮移动到页脚内部 -->
            <a id="download-photo-btn" title="下载图片"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="20px" height="20px" viewBox="0 0 20 20"><polyline points="14 8 10 12 6 8" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" data-color="color-2"></polyline><line x1="10" y1="3" x2="10" y2="12" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" data-color="color-2"></line><path d="m17,13v1c0,1.657-1.343,3-3,3H6c-1.657,0-3-1.343-3-3v-1" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></a>
        </div>
    </div>
    <!-- Wander View -->
    <div id="wanderViewOverlay">
        <div class="wander-header">
           <button class="close-btn" data-action="close-wander-view">&times;</button>
        </div>
        <div class="wander-main-content">
            <div class="wander-photo-container" id="wander-photo-container">
                <img id="wander-img" src="" alt="渲染中...">
                <div class="wander-info-container">
                    <h3 id="wander-title"></h3>
                    <p id="wander-description"></p>
                </div>
            </div>
        </div>
        <div class="wander-music-player" id="wander-music-player">
            <div class="player-handle-container" data-action="toggle-player-collapse"><div class="player-handle"></div></div>
            <div class="player-content">
                <div class="player-display" id="player-display-area"></div>
                <div class="player-progress-track">
                    <div class="player-progress-bar-bg"></div>
                    <div id="player-progress-bar"></div>
                    <div id="player-progress-handle"></div>
                </div>
                <div class="player-controls">
                    <button class="player-btn" id="playlist-btn" title="音乐列表"></button>
                    <button class="player-btn" id="prev-song-btn" title="上一首"></button>
                    <button class="player-btn" id="play-pause-btn" title="播放"></button>
                    <button class="player-btn" id="next-song-btn" title="下一首"></button>
                    <button class="player-btn" id="loop-mode-btn" title="列表循环"></button>
                </div>
            </div>
            <div class="player-popover" id="playlist-popover">
                <div class="popover-header">
                    <h4>播放列表</h4>
                    <button id="open-music-settings-btn" class="player-btn settings-btn"></button>
                </div>
                <ul id="popover-playlist-ul"></ul>
            </div>
        </div>
        <audio id="audio-player"></audio>
    </div>

    <!-- Music Settings Modal -->
    <div class="modal-overlay" id="musicSettingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title-group"><span>音乐设置</span></div>
                <button class="close-btn" data-modal-id="musicSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="toggle-section">
                    <span>进入漫游时自动播放</span>
                    <label class="toggle-switch"><input type="checkbox" id="autoplay-toggle"><span class="slider"></span></label>
                </div>
                <div class="music-upload-section">
                    <h4>上传新歌曲</h4>
                    <div class="file-select-wrapper">
                        <button id="upload-music-btn" class="modal-button">选择音乐 (.mp3, .m4a)</button>
                        <span id="upload-music-status" class="status-text"></span>
                    </div>
                     <input type="text" id="music-rename-input" class="modal-input" placeholder="歌曲名称 (自动填充)">
                    <div class="file-select-wrapper">
                        <button id="upload-lrc-btn" class="modal-button">选择歌词 (.lrc)</button>
                        <span id="upload-lrc-status" class="status-text"></span>
                    </div>
                    <div class="confirm-upload-wrapper">
                        <button id="confirm-upload-btn" class="modal-button">确认上传</button>
                    </div>
                    <input type="file" id="music-file-picker" accept=".mp3,.m4a" hidden>
                    <input type="file" id="lrc-file-picker" accept=".lrc" hidden>
                </div>
                <div class="music-playlist-section">
                    <h4>播放列表管理</h4>
                    <ul id="music-playlist-container"></ul>
                </div>
            </div>
        </div>
    </div>


    <!-- == Iframe Modal & Confirmation Toast == -->
    <div class="iframe-modal-overlay" id="iframeModal">
        <div id="returnConfirmationToast" class="return-toast">
            <span>返回 Jellyfish Island?</span>
            <div>
                <button id="cancelReturnBtn" class="toast-btn toast-btn-cancel">取消</button>
                <button id="confirmReturnBtn" class="toast-btn toast-btn-confirm">确认</button>
            </div>
        </div>
        <div class="iframe-modal-content">
            <iframe id="iframeContent" src="about:blank" frameborder="0" allow="fullscreen" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts allow-downloads"></iframe>
        </div>
        <div id="gestureCaptureZone"></div>
        <div class="swipe-hint" id="swipeHint"><div class="arrow"></div><span>从左侧向右滑动关闭</span></div>
    </div>
    
    <!-- Floating Project Windows Container -->
    <div id="floating-projects-container"></div>
<!-- ============= [ 重构：项目文件转移模态框 V2 ] ============= -->
<div class="modal-overlay" id="transferProjectModal">
    <div class="modal-content" style="max-width: 420px;">
        <div class="modal-header">
            <div class="modal-title-group"><span>转移云盘文件</span></div>
            <button class="close-btn" data-modal-id="transferProjectModal">&times;</button>
        </div>
        <div class="modal-body" style="gap: 20px;">
            <div class="form-section">
                <label>从项目</label>
                <input type="text" id="currentProjectName" class="modal-input" readonly style="opacity: 0.7;">
            </div>

            <!-- [核心新增] 转入现有项目的选择器 -->
            <div class="form-section">
                <label for="existingProjectSelector">选择一个现有项目接收文件 (可选)</label>
                <select id="existingProjectSelector" class="modal-select">
                    <option value="">-- 或 --</option>
                    <!-- JS 动态填充 -->
                </select>
            </div>

            <!-- [修改] 创建新项目部分，现在是备选方案 -->
            <div id="createNewProjectForTransfer">
                <div class="form-section">
                    <label for="transferTargetCategory">转移到新分类 (可选)</label>
                    <input type="text" id="transferTargetCategory" class="modal-input" placeholder="选择或创建新分类" list="category-datalist-transfer">
                    <datalist id="category-datalist-transfer"></datalist>
                </div>
                <div class="form-section">
                    <label for="transferNewProjectName">并创建新项目名为</label>
                    <input type="text" id="transferNewProjectName" class="modal-input" placeholder="新的项目名称">
                </div>
            </div>

            <div class="important-note" style="font-size: 13px; padding: 8px 12px; margin-top: 5px;">
                <p>文件将被移动到目标项目关联的云盘路径下，然后原项目按钮将被删除。</p>
            </div>
            <button id="confirmTransferBtn" class="modal-button">确认转移</button>
            <div class="status-text" id="transfer-status" style="text-align: center; min-height: 20px;"></div>
        </div>
    </div>
</div>
<!-- ============= [ 重构结束 ] ============= -->
    <!-- ============= [ 新增：删除项目选项模态框 ] ============= -->
    <div class="modal-overlay" id="deleteOptionsModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div id="deleteOptionsTitle" class="modal-title-group">删除项目</div>
            </div>
            <div class="modal-body" style="gap: 15px;">
                <p id="deleteOptionsMessage" style="line-height: 1.6;">您想如何处理这个项目？</p>
                <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 15px;">
                    <!-- 转移按钮, 仅在有文件时显示 -->
                    <button id="transferOptionBtn" class="modal-button" style="color: var(--hold-border);">转移文件并删除项目</button>
                    <!-- 删除按钮 -->
                    <button id="deleteOptionBtn" class="modal-button" style="color: #e53e3e;">直接删除项目和文件</button>
                    <!-- 取消按钮 -->
                    <button id="cancelOptionBtn" class="modal-button">取消</button>
                </div>
            </div>
        </div>
    </div>
    <!-- ============= [ 新增结束 ] ============= -->
    <!-- ============= [ 新增：文件标签管理模态框 ] ============= -->
    <div class="modal-overlay" id="tagManagementModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>添加/管理标签</span></div>
                <button class="close-btn" data-modal-id="tagManagementModal">&times;</button>
            </div>
            <div class="modal-body" style="gap: 15px;">
                <!-- 1. 添加新标签的输入区域 -->
                <div class="preset-row">
                    <input type="text" id="newTagNameInput" class="modal-input" placeholder="输入新标签名">
                    <button id="addNewTagBtn" class="modal-button" style="color:var(--hold-border)">添加</button>
                </div>

                <!-- 2. 已有标签的列表容器 (JS将在此填充) -->
                <div id="tag-list-editor" style="max-height: 250px; overflow-y: auto;">
                    <!-- JS will populate this list -->
                </div>
            </div>
        </div>
    </div>
    <!-- ============= [ 新增结束 ] ============= -->

    <!-- ============= [ 新增：按标签查看模态框 ] ============= -->
    <div class="modal-overlay" id="viewByTagModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>按标签查看文件</span></div>
                <button class="close-btn" data-modal-id="viewByTagModal">&times;</button>
            </div>
            <div class="modal-body" style="gap: 15px;">
                <!-- 1. 标签筛选器 (JS将在此填充) -->
                <div class="filter-section">
                    <h4 class="filter-group-title">选择一个或多个标签</h4>
                    <div id="tag-filter-selector" class="filter-options-grid">
                        <!-- JS will populate tag options here -->
                    </div>
                </div>

                <!-- 2. 查看结果的容器 (这个是为未来扩展预留的，当前需求是在外部文件列表显示) -->
                <div id="tagged-files-result-container" style="display: none;">
                    <!-- JS might populate search results here if needed inside the modal -->
                </div>
            </div>
            <!-- 3. 底部确认/取消按钮 -->
             <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 15px; flex-grow: 0; flex-shrink: 0; border-top: 1px solid rgba(128,128,128,0.2);">
                <button data-action="reset-tag-filter" class="modal-button" style="color: #889;">重置</button>
                <button data-action="confirm-tag-filter" class="modal-button" style="flex-grow: 1; margin-left: 10px; color: var(--hold-border);">确认</button>
            </div>
        </div>
    </div>
    <!-- ============= [ 新增结束 ] ============= -->
       <script>
    // [新增] 字符串哈希函数，用于检测内容变更
    function simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    }


    // [新增] 非阻塞式顶部提示框函数
    function showTopToast(message, duration = 3000) {
        // 防止重复创建
        let existingToast = document.querySelector('.top-toast');
        if (existingToast) {
            existingToast.remove();
        }

        const toast = document.createElement('div');
        toast.className = 'top-toast';
        toast.textContent = message;
        document.body.appendChild(toast);

        // 触发显示动画
        setTimeout(() => {
            toast.classList.add('show');
        }, 50);

        // 在指定时间后触发隐藏动画
        setTimeout(() => {
            toast.classList.remove('show');
            // 在动画结束后从 DOM 中移除元素
            toast.addEventListener('transitionend', () => toast.remove());
        }, duration);
    }


    // [JS - V12.5.0 "Cascade Select"]
    const CURRENT_APP_VERSION = '3.7.0';
// [新增] ==========================================================
// [新增] 数据模块化管理器 (DataManager) V1.0
// [新增] ==========================================================
const DataManager = (() => {
    // 内存缓存
    const cache = {};
    // 模块名到文件路径的映射
    const modulePaths = {
        usageTime: 'stats/usage_time.json',
        checkInData: 'widgets/checkin_data.json',
        messageBoardData: 'widgets/message_board.json' // 新增此行
    };

    // 模块的默认数据结构
    const moduleDefaults = {
        usageTime: {},
        checkInData: { 
            dates: [],
            background: { type: 'color', value: '#ffffff', blur: 5 },
            reminder: { enabled: false } 
        },
        messageBoardData: { // 新增此块
            messages: [] 
        }
    };


    /**
     * 异步获取一个数据模块
     * @param {string} moduleName - 模块名 (例如 'usageTime')
     * @returns {Promise<Object>} - 该模块的数据对象
     */
    async function get(moduleName) {
        // 1. 优先从内存缓存读取
        if (cache[moduleName]) {
            return cache[moduleName];
        }

        const path = modulePaths[moduleName];
        if (!path) {
            throw new Error(`DataManager: 未知的模块 '${moduleName}'`);
        }

        updateSyncStatus('syncing', `加载 ${moduleName} 模块...`);
        const { data, error, response } = await fetchFromGithub(path);

        if (error) {
            updateSyncStatus('error', `加载 ${moduleName} 失败: ${error}`);
            // 如果加载失败，返回默认值以保证程序运行，但不缓存
            return moduleDefaults[moduleName] || {};
        }

        let moduleData;
        // 2. 如果文件不存在(404)或内容为空，则使用默认结构
        if ((response && response.status === 404) || !data || !data.content) {
            console.log(`'${path}' not found on remote. Using default structure.`);
            moduleData = moduleDefaults[moduleName] || {};
        } else {
            // 3. 解析云端数据
            try {
                moduleData = JSON.parse(b64_to_utf8(data.content));
            } catch (e) {
                console.error(`解析 '${path}' 失败:`, e);
                updateSyncStatus('error', `解析云端 ${moduleName} 数据失败`);
                moduleData = moduleDefaults[moduleName] || {};
            }
        }
        
        // 4. 存入缓存并返回
        cache[moduleName] = moduleData;
        updateSyncStatus('synced', `模块 ${moduleName} 加载成功`);
        return moduleData;
    }

    /**
     * 异步保存一个数据模块
     * @param {string} moduleName - 模块名
     * @param {string} commitMessage - 提交信息
     */
    async function save(moduleName, commitMessage) {
        if (!cache[moduleName]) {
            console.warn(`DataManager: 尝试保存在内存中不存在的模块 '${moduleName}'`);
            return;
        }

        const path = modulePaths[moduleName];
        const dataToSave = cache[moduleName];
        const content = utf8_to_b64(JSON.stringify(dataToSave, null, 2));

        // 注意：这里的 saveToGithub 会自动获取最新的 sha，无需手动管理
        await saveToGithub(path, content, commitMessage);
    }

    return { get, save };
})();

/**
 * [新增] 一次性数据迁移函数 V1.0
 * 将旧的、臃肿的 config.json 拆分为模块化文件
 */
async function migrateToModularData(config) {
    let needsMigration = false;
    const migrationTasks = [];
    
    // 检查并准备迁移 usageTime
    if (config.settings && config.settings.usageTime) {
        needsMigration = true;
        const usageTimeData = config.settings.usageTime;
        delete config.settings.usageTime; // 从主配置中移除
        
        const content = utf8_to_b64(JSON.stringify(usageTimeData, null, 2));
        migrationTasks.push(saveToGithub('stats/usage_time.json', content, 'Migrate: Create usage_time.json'));
    }

    // 检查并准备迁移 checkInData
    if (config.settings && config.settings.checkInData) {
        needsMigration = true;
        const checkInData = config.settings.checkInData;
        delete config.settings.checkInData; // 从主配置中移除

        const content = utf8_to_b64(JSON.stringify(checkInData, null, 2));
        migrationTasks.push(saveToGithub('widgets/checkin_data.json', content, 'Migrate: Create checkin_data.json'));
    }

    if (needsMigration) {
        alert("检测到新的数据结构，将为您进行一次性数据迁移。过程可能需要一点时间，请稍候...");
        
        // 更新主配置，标记为已迁移
        config.dataStructureVersion = 2; // 添加版本号
        const configContent = utf8_to_b64(JSON.stringify(config, null, 2));
        migrationTasks.push(saveToGithub('config.json', configContent, 'Migrate: Update main config to v2 structure'));

        try {
            await Promise.all(migrationTasks);
            alert("数据迁移成功！页面将刷新以应用新结构。");
            location.reload();
            return true; // 表示已成功迁移并刷新
        } catch (error) {
            alert(`数据迁移失败: ${error.message}\n请截图联系开发者。`);
            return false;
        }
    }
    
    return false; // 表示无需迁移
}
// [新增结束] =======================================================

    let GITHUB_CONFIG = {}, configSha = null, isManagementMode = false, isEditingButton = false, editingButtonData = null;
    const navContainer = document.getElementById('navContainer'), pageOverlay = document.getElementById('pageOverlay');
    const syncStatusIndicator = document.getElementById('sync-status-indicator');
    const syncErrorModal = document.getElementById('syncErrorModal');
    const iframeModal = document.getElementById('iframeModal'), iframeModalContent = iframeModal.querySelector('.iframe-modal-content'), iframeEl = document.getElementById('iframeContent'), swipeHint = document.getElementById('swipeHint'), returnConfirmationToast = document.getElementById('returnConfirmationToast');
    let activeUploadXHR = null;
let activePhotoUploadXHRs = []; // [新增] 跟踪所有活跃的照片上传请求


window.addEventListener('beforeunload', (event) => {
    // [最终修正] 只检查真正跟踪后台网络请求的变量
    if (activeUploadXHR || activePhotoUploadXHRs.length > 0) {
        event.preventDefault();
        event.returnValue = '有文件正在上传，确定要离开吗？';
    }
});



    const secureFileCache = new Map();
    let currentCategory = '全部';
    let photoObserver;

const getDefaultConfig = () => ({
        title: 'Jellyfish Island',
        subtitle: '长按🌞打开工具栏 | By淡季水母',
        categories: [{ name: '全部', buttons: [] }],
        settings: {
            paginationEnabled: true,
            themeStyle: 'neumorphism', 
            jellyBall: { enabled: false, swipeBack: true, functions: {}, customCSS: '' },
            globalFont: { name: '', url: '' }, 
            fontPresets: [],
            // [修改] 将挂件设置移入主配置
            pendant: {
                enabled: false, // 总开关也在这里
                lineLength: '5rem',
                lineColor: '#000000',
                shapeContent: '☁️' 
            },
            backupReminder: {
                enabled: false,
                timeBasedEnabled: false,
                times: [],
                message: '是时候该备份你的项目啦！',
                onExit: false,
                projects: []
            },
            checkinSettings: {
                headerColor: '#8B4513',
                cardColor: '#ffffff'
            }
        },
        themePresets: [
            {
                name: "原生主题",
                colors: {
                    dayColor1: "#f5f7fa",
                    dayColor2: "#e4eaf5",
                    nightColor1: "#1f2a40",
                    nightColor2: "#16213e"
                }
            }
        ],
        lockscreenWidgets: {}
    });

    let currentConfig = getDefaultConfig();

    // [新增] ==========================================================
// [新增] 使用时长分类筛选 V1.0
// [新增] ==========================================================
const UsageTimeFilterManager = (() => {
    let listContainer, filterContainer, masterToggle;

    function renderCategoryList() {
        if (!listContainer) return;
        
        listContainer.innerHTML = '';
        // ★ 核心修复：直接过滤掉“全部”这个分类
        const allCategories = currentConfig.categories.map(c => c.name).filter(name => name !== '全部');
        const settings = currentConfig.settings.usageTime || {};
        const selectedCategories = settings.includedCategories || allCategories;

        allCategories.forEach(categoryName => {
            const isChecked = selectedCategories.includes(categoryName);
            const itemHtml = `
                <div class="toggle-section" style="padding: 10px 12px;">
                    <span>${categoryName}</span>
                    <label class="toggle-switch">
                        <input type="checkbox" data-category-name="${categoryName}" ${isChecked ? 'checked' : ''}>
                        <span class="slider"></span>
                    </label>
                </div>`;
            listContainer.innerHTML += itemHtml;
        });
    }

    function updateVisibility() {
        const settings = currentConfig.settings.usageTime || {};
        masterToggle.checked = settings.filterEnabled === true;
        filterContainer.style.display = masterToggle.checked ? 'block' : 'none';
    }

    function handleMasterToggle() {
        if (!currentConfig.settings.usageTime) currentConfig.settings.usageTime = {};
        currentConfig.settings.usageTime.filterEnabled = masterToggle.checked;
        updateVisibility();
        saveGlobalConfig('Toggle usage time category filter');
        renderUsageLeaderboard(); // 立即刷新排行榜
    }

    function handleCategoryToggle(event) {
        if (event.target.matches('input[type="checkbox"]')) {
            const categoryName = event.target.dataset.categoryName;
            const isEnabled = event.target.checked;
            
            if (!currentConfig.settings.usageTime) currentConfig.settings.usageTime = {};
            if (!currentConfig.settings.usageTime.includedCategories) {
                currentConfig.settings.usageTime.includedCategories = currentConfig.categories.map(c => c.name);
            }

            const included = currentConfig.settings.usageTime.includedCategories;
            
            if (isEnabled) {
                if (!included.includes(categoryName)) included.push(categoryName);
            } else {
                const index = included.indexOf(categoryName);
                if (index > -1) included.splice(index, 1);
            }
            
            saveGlobalConfig('Update usage time included categories');
            renderUsageLeaderboard();
        }
    }

    function init() {
        listContainer = document.getElementById('usage-time-category-filter');
        filterContainer = document.getElementById('usage-time-filter-container');
        masterToggle = document.getElementById('usage-time-filter-toggle');

        if (listContainer && filterContainer && masterToggle) {
            updateVisibility();
            renderCategoryList();
            masterToggle.addEventListener('change', handleMasterToggle);
            listContainer.addEventListener('change', handleCategoryToggle);
        }

        const capsuleButton = document.querySelector('[data-target="widget-page-settings"]');
        if (capsuleButton) {
            capsuleButton.addEventListener('click', () => {
                if (listContainer) renderCategoryList();
                if (masterToggle) updateVisibility();
            });
        }
    }

    return { init };
})();
// 在 CheckInManager 初始化之后调用 UsageTimeFilterManager 初始化
document.addEventListener('DOMContentLoaded', () => {
    // 确保其他模块都初始化完毕
    setTimeout(() => {
        UsageTimeFilterManager.init();
    }, 100); 
});


    // ===== [START] FLOATING PROJECT WINDOW MANAGER =====
    const FloatingProjectWindowManager = (() => {
        const container = document.getElementById('floating-projects-container');
        let windows = {};
        const Z_INDEX_BASE = 2010;

        function create(id, title, url) {
            if (windows[id]) {
                const win = windows[id].element;
                win.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                win.style.transform = `${win.style.transform.replace(/scale$[^)]+$/, '')} scale(1.05)`;
                setTimeout(() => win.style.transform = win.style.transform.replace(/scale\([^)]+\)/, 'scale(1)'), 200);
                focus(id);
                return;
            }

            const winEl = document.createElement('div');
            winEl.className = 'floating-project-window';
            winEl.id = `fpw-${id}`;
            winEl.style.zIndex = Z_INDEX_BASE + Object.keys(windows).length;
            winEl.innerHTML = `
                <div class="fpw-header">
                    <span class="fpw-title">${title}</span>
                    <div class="fpw-controls">
                        <button class="fpw-hide" title="隐藏">－</button>
                        <button class="fpw-close" title="关闭">×</button>
                    </div>
                </div>
                <div class="fpw-content">
                    <div class="fpw-resizer"></div>
                    <iframe src="${url}" frameborder="0" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts allow-downloads"></iframe>
                </div>
            `;
            container.appendChild(winEl);

            const handleEl = document.createElement('div');
            handleEl.className = 'fpw-hide-handle';
            handleEl.id = `fpw-handle-${id}`;
            handleEl.textContent = title;
            container.appendChild(handleEl);

            windows[id] = {id, title, url, element: winEl, handle: handleEl };
            
            setTimeout(() => winEl.classList.add('visible'), 50);

            _attachEventListeners(winEl, handleEl, id);
            focus(id);
        }

        function focus(id) {
            let maxZ = Z_INDEX_BASE;
            Object.values(windows).forEach(win => {
                const currentZ = parseInt(win.element.style.zIndex);
                if (currentZ > maxZ) maxZ = currentZ;
            });

            const targetWindow = windows[id].element;
            if (parseInt(targetWindow.style.zIndex) <= maxZ) {
                targetWindow.style.zIndex = maxZ + 1;
            }
        }

// <-- 开始替换为 -->

        function _attachEventListeners(winEl, handleEl, id) {
            const header = winEl.querySelector('.fpw-header');
            const resizer = winEl.querySelector('.fpw-resizer');

            // --- Drag Logic ---
 const startDrag = (e) => {
                // Prevent drag if a button was clicked
                if (e.target.closest('button')) return;
                e.preventDefault();
                focus(id);
                const isTouchEvent = e.type === 'touchstart';
                const startClientX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                const startClientY = isTouchEvent ? e.touches[0].clientY : e.clientY;
                // --- 最终的坐标系修正：使用 getComputedStyle 来获取元素的当前位置 ---
                // getComputedStyle 读取的是渲染后的实际CSS值，与 style.left 的坐标系一致
                const computedStyle = window.getComputedStyle(winEl);
                const initialLeft = parseFloat(computedStyle.left) || 0;
                const initialTop = parseFloat(computedStyle.top) || 0;
                
                // 计算手指按下的点与元素当前位置的差值，作为拖动过程中的固定偏移量
                const offsetX = startClientX - initialLeft;
                const offsetY = startClientY - initialTop;
                const onDragMove = (moveEvent) => {
                    const moveClientX = isTouchEvent ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const moveClientY = isTouchEvent ? moveEvent.touches[0].clientY : moveEvent.clientY;
                    
                    // 新位置 = 当前手指在视口的位置 - 初始的固定偏移量
                    let newX = moveClientX - offsetX;
                    let newY = moveClientY - offsetY;
                    winEl.style.left = `${newX}px`;
                    winEl.style.top = `${newY}px`;
                };
                const onDragEnd = () => {
                    if (isTouchEvent) {
                        document.removeEventListener('touchmove', onDragMove);
                        document.removeEventListener('touchend', onDragEnd);
                    } else {
                        document.removeEventListener('mousemove', onDragMove);
                        document.removeEventListener('mouseup', onDragEnd);
                    }
                };
                if (isTouchEvent) {
                    document.addEventListener('touchmove', onDragMove, { passive: false });
                    document.addEventListener('touchend', onDragEnd);
                } else {
                    document.addEventListener('mousemove', onDragMove);
                    document.addEventListener('mouseup', onDragEnd);
                }
            };
            header.addEventListener('mousedown', startDrag);
            header.addEventListener('touchstart', startDrag, { passive: false });

            // --- Resize Logic ---
            const startResize = (e) => {
                e.preventDefault();
                const isTouchEvent = e.type === 'touchstart';
                let startX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                let startWidth = winEl.offsetWidth;
                let startHeight = winEl.offsetHeight;
                const aspectRatio = startWidth / startHeight;

                const onResizeMove = (moveEvent) => {
                    const moveClientX = isTouchEvent ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const dx = moveClientX - startX;
                    const newWidth = startWidth + dx;
                    if (newWidth >= parseFloat(winEl.style.minWidth || 250)) {
                        winEl.style.width = newWidth + 'px';
                        winEl.style.height = (newWidth / aspectRatio) + 'px';
                    }
                };

                const onResizeEnd = () => {
                     if (isTouchEvent) {
                        document.removeEventListener('touchmove', onResizeMove);
                        document.removeEventListener('touchend', onResizeEnd);
                    } else {
                        document.removeEventListener('mousemove', onResizeMove);
                        document.removeEventListener('mouseup', onResizeEnd);
                    }
                };

                if (isTouchEvent) {
                    document.addEventListener('touchmove', onResizeMove, { passive: false });
                    document.addEventListener('touchend', onResizeEnd);
                } else {
                    document.addEventListener('mousemove', onResizeMove);
                    document.addEventListener('mouseup', onResizeEnd);
                }
            };
            
            resizer.addEventListener('mousedown', startResize);
            resizer.addEventListener('touchstart', startResize, { passive: false });

            // --- Controls & Focus ---
            winEl.querySelector('.fpw-close').addEventListener('click', () => close(id));
            winEl.querySelector('.fpw-hide').addEventListener('click', () => hide(id));
            handleEl.addEventListener('click', () => show(id));
            winEl.addEventListener('mousedown', () => focus(id));
            winEl.addEventListener('touchstart', () => focus(id), { passive: true });

            // [新增] 在窗口创建时，开始计时
            startUsageTracking(windows[id].url);
        }


// <-- 结束替换为 -->


                const BASE_TOP_OFFSET = 20; // 第一个标签距离屏幕顶部的距离
        const HANDLE_SPACING = 25;  // 每个标签之间的垂直间距

        /**
         * 重新计算并排列所有可见的隐藏标签位置
         */
        function _restackHandles() {
            const visibleHandles = Array.from(container.querySelectorAll('.fpw-hide-handle.visible'));
            visibleHandles.forEach((handle, index) => {
                handle.style.top = `${BASE_TOP_OFFSET + (index * HANDLE_SPACING)}px`;
            });
        }

        function hide(id) {
            const win = windows[id];
            if (!win) return;
            win.element.classList.remove('visible');
            
            setTimeout(() => {
                win.element.style.display = 'none';
                // 设置固定的基础样式
                win.handle.style.left = '0px';
                win.handle.style.borderRadius = '0 8px 8px 0';
                win.handle.classList.add('visible');
                
                // 调用新的排列函数来确定最终位置
                _restackHandles();
            }, 300);
        }

        function show(id) {
            const win = windows[id];
            if (!win) return;

            // 先隐藏标签，然后重新排列剩下的标签
            win.handle.classList.remove('visible');
            _restackHandles();

            win.element.style.display = 'flex';
            setTimeout(() => {
                win.element.classList.add('visible');
                focus(id);
            }, 50);
        }

        function close(id) {
            // [新增] 停止计时
            if (currentTrackedProject && currentTrackedProject.href === windows[id]?.url) {
                stopUsageTracking();
            }

            const win = windows[id];
            if (!win) return;

            
            // 标记标签为不可见，以便在关闭动画期间，其他标签可以先移动到位
            const wasVisible = win.handle.classList.contains('visible');
            if(wasVisible) {
                win.handle.classList.remove('visible');
            }

            win.element.classList.remove('visible');
            
            setTimeout(() => {
                win.element.remove();
                win.handle.remove();
                delete windows[id];
                
                // 只有当被关闭的窗口之前是隐藏状态时，才需要重新排列
                if (wasVisible) {
                    _restackHandles();
                }
            }, 300);
        }

        function closeAll() {
            for (const id in windows) {
                close(id);
            }
        }

        
        return { create, closeAll };
    })();
    // ===== [END] FLOATING PROJECT WINDOW MANAGER =====
    // [新增] ==========================================================
    // [新增] 使用时长功能核心模块
    // [新增] ==========================================================

    // [核心修复] 将计时器追踪变量移至全局作用域
    let currentTrackedProject = null;

    /**
     * 将毫秒数格式化为人类可读的字符串 (例如: "12小时 30分钟 5秒")
     * @param {number} ms - 毫秒数
     * @returns {string} 格式化后的时间字符串
     */
    function formatDuration(ms) {

        if (ms < 1000) {
            return "不足1秒";
        }
        let seconds = Math.floor(ms / 1000);
        const hours = Math.floor(seconds / 3600);
        seconds %= 3600;
        const minutes = Math.floor(seconds / 60);
        seconds %= 60;

        const parts = [];
        if (hours > 0) parts.push(`${hours}小时`);
        if (minutes > 0) parts.push(`${minutes}分钟`);
        if (seconds > 0 || parts.length === 0) parts.push(`${seconds}秒`);
        
        return parts.join(' ');
    }



    /**
     * 开始追踪一个项目的使用时长
     * @param {string} projectHref - 项目的唯一链接
     */
    function startUsageTracking(projectHref) {
        // 如果当前有正在计时的项目，先停止并保存它
        if (currentTrackedProject) {
            stopUsageTracking();
        }
        // 开始追踪新项目
        currentTrackedProject = {
            href: projectHref,
            startTime: Date.now()
        };
        console.log(`开始计时: ${projectHref}`);
    }

    /**
     * 渲染使用时长排行榜 (V2 - 异步加载)
     */
    async function renderUsageLeaderboard() {
        const listContainer = document.getElementById('usage-leaderboard-list');
        const placeholder = document.getElementById('usage-leaderboard-placeholder');
        if (!listContainer || !placeholder) return;

        const usageData = await DataManager.get('usageTime');
        const usageSettings = currentConfig.settings.usageTime || {};

        if (!usageData || Object.keys(usageData).length === 0) {
            placeholder.textContent = '暂无使用记录';
            placeholder.style.display = 'block';
            listContainer.innerHTML = '';
            return;
        }
        
        let allEntries = Object.entries(usageData);

        // 核心筛选逻辑
        if (usageSettings.filterEnabled === true) {
            const includedCategories = usageSettings.includedCategories || [];
            allEntries = allEntries.filter(([href]) => {
                const project = findButtonConfigByHref(href);
                return project && includedCategories.includes(project.categoryName);
            });
        }

        const leaderboardData = allEntries.map(([href, time]) => {
                const project = findButtonConfigByHref(href);
                // 如果项目被删除，findButtonConfigByHref会返回null
                return project ? { name: project.text, time: time } : null;
            })
            .filter(Boolean) // 过滤掉找不到的项目
            .sort((a, b) => b.time - a.time);

        if (leaderboardData.length === 0) {
            placeholder.textContent = '当前筛选条件下无记录';
            placeholder.style.display = 'block';
            listContainer.innerHTML = '';
            return;
        }

        placeholder.style.display = 'none';
        listContainer.innerHTML = leaderboardData.map((item, index) => {
            const rank = index + 1;
            let rankClass = `leaderboard-rank`;
            if (rank <= 3) rankClass += ` rank-${rank}`;
            return `
                <li class="leaderboard-item">
                    <div class="${rankClass}">${rank}</div>
                    <div class="leaderboard-info">
                        <div class="leaderboard-info-name">${item.name}</div>
                        <div class="leaderboard-info-time">${formatDuration(item.time)}</div>
                    </div>
                </li>
            `;
        }).join('');
    }


    /**
     * 停止当前项目的计时并保存数据 (V4 - 模块化)
     */
    async function stopUsageTracking() {
        if (!currentTrackedProject) return;

        const duration = Date.now() - currentTrackedProject.startTime;
        const href = currentTrackedProject.href;

        // [修改] 异步获取 usageTime 数据
        const usageData = await DataManager.get('usageTime');
        
        // 累加时间
        usageData[href] = (usageData[href] || 0) + duration;
        
        console.log(`停止计时: ${href}, 本次使用: ${duration}ms, 总计: ${usageData[href]}ms`);
        
        // [修改] 调用 DataManager 保存独立的 usage_time.json 文件
        await DataManager.save('usageTime', 'Update project usage time');
        
        // 重置追踪器
        currentTrackedProject = null;
    }


    // ===== [START] FLOATING JELLYFISH BALL LOGIC (MODIFIED) =====
    const FloatingBallManager = (() => {
        let wrapper = null;
        let ball = null;
        let isDragging = false;
        let isLongPressActive = false;
        let startPos = { x: 0, y: 0 };
        let offset = { x: 0, y: 0 };
        let idleTimer = null;
        let longPressTimer = null;
        let activeMenuBtn = null;
        const LONG_PRESS_DURATION = 400; /* MODIFICATION: Shortened long-press time */
        const DRAG_THRESHOLD = 10;
        const ALL_FUNCTIONS = [
            { id: 'album', icon: '🖼️', title: '相册' },
            { id: 'folder', icon: '📁', title: '文件夹' },
            { id: 'return', icon: '🔙', title: '返回' },
            { id: 'fullscreen', icon: '⛶', title: '全屏' }, // <-- [新增] 全屏功能
            { id: 'memo', icon: '📝', title: '备忘录' },
            { id: 'quick_switch', icon: '🔗', title: '快速切换' }
        ];

        function _create() {
            if (currentConfig.settings.jellyBall?.enabled !== true) return;
            if (document.getElementById('floating-jellyfish-ball')) return;
            
            wrapper = document.createElement('div');
            wrapper.className = 'jelly-ball-wrapper';
            wrapper.innerHTML = `
                <div class="jelly-ball-glow"></div>
                <div id="floating-jellyfish-ball">
                   <span>🪼</span>
                   <div class="jelly-menu"></div>
                </div>
            `;
            document.body.appendChild(wrapper);
            ball = document.getElementById('floating-jellyfish-ball');
            
            _renderMenuButtons();
             
            let startPos = localStorage.getItem('jellyBallPosition');
            if (startPos) {
                startPos = JSON.parse(startPos);
                wrapper.style.top = `${startPos.y}px`;
                wrapper.style.left = `${startPos.x}px`;
            } else {
                wrapper.style.top = '80%';
                wrapper.style.left = '90%';
            }
            
            _addEventListeners();
            _resetIdleTimer();
        }

        function _renderMenuButtons() {
            if (!ball) return;
            const menu = ball.querySelector('.jelly-menu');
            menu.innerHTML = '';
            const enabledFunctions = _getEnabledFunctions();

            enabledFunctions.forEach(func => {
                const btnEl = document.createElement('button');
                btnEl.className = 'jelly-menu-btn';
                btnEl.innerHTML = func.icon;
                btnEl.title = func.title;
                btnEl.dataset.actionId = func.id;
                menu.appendChild(btnEl);
            });
        }
        
        function _destroy() { if (ball) { ball.parentElement.remove(); ball = null; wrapper = null; } clearTimeout(idleTimer); clearTimeout(longPressTimer); document.removeEventListener('mousemove', _onDragMove); document.removeEventListener('touchmove', _onDragMove); document.removeEventListener('mouseup', _onDragEnd); document.removeEventListener('touchend', _onDragEnd); }
        function _addEventListeners() { ball.addEventListener('mousedown', _onDragStart); ball.addEventListener('touchstart', _onDragStart, { passive: false }); document.addEventListener('click', (e) => { if (ball && !ball.contains(e.target)) _closeMenu(); }, true); }

        function _onDragStart(e) {
            if (ball.classList.contains('menu-open') && e.target.closest('.jelly-menu-btn')) return;
            e.preventDefault();
            
            clearTimeout(idleTimer);
            wrapper.classList.remove('idle', 'snap-left', 'snap-right');
            isDragging = false;
            isLongPressActive = false;
            activeMenuBtn = null;
            
            const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            startPos = { x: clientX, y: clientY };
            const rect = wrapper.getBoundingClientRect();
            offset.x = clientX - rect.left;
            offset.y = clientY - rect.top;

            longPressTimer = setTimeout(() => { isLongPressActive = true; _toggleMenu(); longPressTimer = null; }, LONG_PRESS_DURATION);
            
            document.addEventListener('mousemove', _onDragMove);
            document.addEventListener('touchmove', _onDragMove, { passive: false });
            document.addEventListener('mouseup', _onDragEnd);
            document.addEventListener('touchend', _onDragEnd);
        }

        function _onDragMove(e) {
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

            if (isLongPressActive) { _handleMenuInteraction(clientX, clientY); return; }
            const dx = clientX - startPos.x;
            const dy = clientY - startPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (!isDragging && distance > DRAG_THRESHOLD) {
                e.preventDefault();
                isDragging = true;
                if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
                ball.classList.add('dragging');
                wrapper.classList.add('dragging');
                _closeMenu();
            }

            if (isDragging) {
                e.preventDefault();
                let newX = clientX - offset.x;
                let newY = clientY - offset.y;
                const ballSize = wrapper.offsetWidth;
                newX = Math.max(0, Math.min(newX, window.innerWidth - ballSize));
                newY = Math.max(0, Math.min(newY, window.innerHeight - ballSize));
                wrapper.style.left = `${newX}px`;
                wrapper.style.top = `${newY}px`;
            }
        }
        
        function _handleMenuInteraction(clientX, clientY) { const menuBtn=document.elementFromPoint(clientX,clientY)?.closest('.jelly-menu-btn'); if(activeMenuBtn&&activeMenuBtn!==menuBtn){activeMenuBtn.classList.remove('hovered');} if(menuBtn){menuBtn.classList.add('hovered'); activeMenuBtn=menuBtn;}else{activeMenuBtn=null;} }
        
        function _onDragEnd(e) {
            clearTimeout(longPressTimer);
            if (isLongPressActive) { if (activeMenuBtn) { _onMenuClick(activeMenuBtn); } _closeMenu(); } 
            else if (!isDragging) { /* Short click, do nothing for now */ } 
            else { _snapToEdge(); }
            
            ball.classList.remove('dragging');
            wrapper.classList.remove('dragging');
            if (activeMenuBtn) activeMenuBtn.classList.remove('hovered');

            isDragging = isLongPressActive = false; activeMenuBtn = null;
            _resetIdleTimer();

            document.removeEventListener('mousemove', _onDragMove);
            document.removeEventListener('touchmove', _onDragMove);
            document.removeEventListener('mouseup', _onDragEnd);
            document.removeEventListener('touchend', _onDragEnd);
        }
        
        function _snapToEdge() { const rect=wrapper.getBoundingClientRect(); const isRight=rect.left+rect.width/2>window.innerWidth/2; wrapper.style.left=`${isRight?window.innerWidth-rect.width:0}px`; localStorage.setItem('jellyBallPosition',JSON.stringify({x:wrapper.offsetLeft,y:wrapper.offsetTop})); }
        function _resetIdleTimer() { clearTimeout(idleTimer); wrapper.classList.remove('idle','snap-left','snap-right'); idleTimer=setTimeout(()=>{const rect=wrapper.getBoundingClientRect(); wrapper.classList.add((rect.left+rect.width/2)>window.innerWidth/2?'snap-right':'snap-left','idle'); _closeMenu(); },3000); }
        function _toggleMenu() { const isOpen=ball.classList.toggle('menu-open'); const menuBtns=ball.querySelectorAll('.jelly-menu-btn'); if(isOpen){const rect=wrapper.getBoundingClientRect();const n=menuBtns.length,r=65,m=10;let s,e;const c={x:rect.left+rect.width/2,y:rect.top+rect.height/2};if(c.x<r+m){s=-Math.PI/2;e=Math.PI/2;}else if(c.x>window.innerWidth-r-m){s=Math.PI/2;e=3*Math.PI/2;}else if(c.y<r+m){s=0;e=Math.PI;}else if(c.y>window.innerHeight-r-m){s=Math.PI;e=2*Math.PI;}else{s=-Math.PI/2;e=3*Math.PI/2;} const a=n>1?(e-s)/(n-1):0; menuBtns.forEach((b,i)=>{const t=s+i*a;b.style.setProperty('--transform-end',`translate(${Math.cos(t)*r}px, ${Math.sin(t)*r}px)`);});}}
        function _closeMenu(){ if(ball&&ball.classList.contains('menu-open')) ball.classList.remove('menu-open'); }
        
        function _onMenuClick(button){
            if(!button) return;
            const actionId = button.dataset.actionId;
            const memoryModal = document.getElementById('memoryModal');
            
            function openMemoryAndSwitch(viewName) {
                MemoryApp.open();
                memoryModal.style.zIndex = '2015'; // Ensure it's above floating windows
                const closeHandler=()=>{memoryModal.style.zIndex='';memoryModal.querySelector('.close-btn').removeEventListener('click',closeHandler);};
                memoryModal.querySelector('.close-btn').addEventListener('click',closeHandler,{once:true});
                memoryModal.querySelector(`[data-action="goto-${viewName}"]`)?.click();
            }

            switch(actionId) {
                case 'album': openMemoryAndSwitch('album'); break;
                case 'memo': openMemoryAndSwitch('memo'); break;
                case 'folder': openMemoryAndSwitch('cloud'); break;
                case 'return':
                    if (iframeModal.classList.contains('active')) {
                        // ★ 新增：在这里同样触发退出提醒
                        BackupReminderManager.triggerOnExitReminder();
                        closeIframeModal();
                    }
                    break;
                case 'quick_switch': _showQuickSwitchMenu(); break;
                // ============= [新增] 全屏功能逻辑 =============
                case 'fullscreen':
                    const iframeModalEl = document.getElementById('iframeModal');
                    if (iframeModalEl && iframeModalEl.classList.contains('active')) {
                        // 目标是当前活动的 iframe
                        const iframeToFullscreen = document.getElementById('iframeContent');
                        
                        try {
                            // 尝试调用标准的 Fullscreen API
                            if (iframeToFullscreen.requestFullscreen) {
                                iframeToFullscreen.requestFullscreen();
                            } else if (iframeToFullscreen.webkitRequestFullscreen) { // Safari 浏览器前缀
                                iframeToFullscreen.webkitRequestFullscreen();
                            } else if (iframeToFullscreen.msRequestFullscreen) { // IE11 浏览器前缀
                                iframeToFullscreen.msRequestFullscreen();
                            } else {
                                // 如果浏览器完全不支持，则提示用户
                                showTopToast('您的浏览器不支持全屏功能。', 2500);
                            }
                        } catch (error) {
                            console.error("全屏请求失败:", error);
                            showTopToast('全屏请求失败，请稍后再试。', 2500);
                        }
                    } else {
                        // 如果没有打开项目，则提示用户
                        showTopToast('当前没有可全屏的项目。', 2500);
                    }
                    break;
                // ============= [新增结束] =============
            }

            _closeMenu();
        }


        function _showQuickSwitchMenu() {
            let existingMenu = document.getElementById('quick-switch-menu-overlay');
            if(existingMenu) existingMenu.remove();

            const overlay = document.createElement('div');
            overlay.id = 'quick-switch-menu-overlay';
            overlay.className = 'page-overlay show';
            overlay.style.zIndex = '9997';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            
            const menuContainer = document.createElement('div');
            menuContainer.id = 'quick-switch-menu';
            menuContainer.className = 'modal-content';
            menuContainer.style.maxWidth = '320px';
            menuContainer.style.maxHeight = '400px';

            menuContainer.innerHTML = `
                <div class="modal-header" style="padding-bottom: 10px; margin-bottom: 10px;">
                    <div class="modal-title-group">快速切换</div>
                    <button class="close-btn" style="width:30px; height:30px; font-size:20px;">&times;</button>
                </div>
                <div class="modal-body" style="gap: 12px; padding-bottom: 10px;">
                    <select id="qs-category-select" class="modal-select">
                        <option value="">-- 请选择分类 --</option>
                    </select>
                    <select id="qs-project-select" class="modal-select" disabled>
                        <option value="">-- 请选择项目 --</option>
                    </select>
                    <div id="qs-actions" style="display:none; justify-content: space-around; gap: 10px; margin-top: 10px;">
                        <button id="qs-open-float" class="modal-button" style="flex:1;">悬浮窗</button>
                        <button id="qs-open-full" class="modal-button" style="flex:1;">全屏</button>
                    </div>
                </div>
            `;
            
            overlay.appendChild(menuContainer);
            document.body.appendChild(overlay);

            const categorySelect = menuContainer.querySelector('#qs-category-select');
            const projectSelect = menuContainer.querySelector('#qs-project-select');
            const actionsDiv = menuContainer.querySelector('#qs-actions');
            
            currentConfig.categories.forEach(cat => {
                categorySelect.innerHTML += `<option value="${cat.name}">${cat.name}</option>`;
            });

            categorySelect.onchange = () => {
                projectSelect.innerHTML = '<option value="">-- 请选择项目 --</option>';
                projectSelect.disabled = true;
                actionsDiv.style.display = 'none';
                const catName = categorySelect.value;
                if (!catName) return;

                const category = currentConfig.categories.find(c => c.name === catName);
                if (category && category.buttons.length > 0) {
                     category.buttons.forEach(btn => {
                        projectSelect.innerHTML += `<option value="${btn.href}" data-text="${btn.text}">${btn.text}</option>`;
                     });
                     projectSelect.disabled = false;
                }
            };
            
            let selectedProject = null;
            projectSelect.onchange = () => {
                const selectedOption = projectSelect.options[projectSelect.selectedIndex];
                if (projectSelect.value) {
                    selectedProject = { url: selectedOption.value, title: selectedOption.dataset.text };
                    actionsDiv.style.display = 'flex';
                } else {
                    selectedProject = null;
                    actionsDiv.style.display = 'none';
                }
            };
            
            const closeMenu = () => { document.body.removeChild(overlay); };
            overlay.onclick = (e) => { if (e.target === overlay) closeMenu(); };
            menuContainer.querySelector('.close-btn').onclick = closeMenu;
            
            menuContainer.querySelector('#qs-open-float').onclick = () => {
                if(selectedProject) FloatingProjectWindowManager.create(Date.now(), selectedProject.title, selectedProject.url);
                closeMenu();
            };
            menuContainer.querySelector('#qs-open-full').onclick = () => {
                if(selectedProject) openIframeModal(selectedProject.url);
                closeMenu();
            };
        }


        function _getEnabledFunctions() { const settings=currentConfig.settings.jellyBall?.functions||{}; return ALL_FUNCTIONS.filter(func=>settings[func.id]!==false); }

         function initSettings() {
            const toggle = document.getElementById('jellyBallToggle');
            const settingsEntry = document.getElementById('jellyBallSettingsEntry');
            const openSettingsBtn = document.getElementById('openJellyBallSettingsBtn');
            const customStyleTag = document.getElementById('custom-jelly-ball-styles');

            // 确保配置对象存在
            if (!currentConfig.settings.jellyBall) {
                currentConfig.settings.jellyBall = { enabled: false, swipeBack: true, functions: {}, customCSS: '' };
            }
            const settings = currentConfig.settings.jellyBall;
            
             // 动态创建悬浮球设置窗口 (V3, 简洁UI版)
            function openJellyBallSettingsWindow() {
                const modalId = 'jelly-ball-settings-modal';
                
                const modalOverlay = document.createElement('div');
                modalOverlay.id = modalId;
                modalOverlay.className = 'modal-overlay show';
                modalOverlay.style.zIndex = '1002';

                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                
                modalContent.innerHTML = `
                    <div class="modal-header">
                        <div class="modal-title-group"><span>悬浮球设置</span></div>
                        <button class="close-btn">&times;</button>
                    </div>
                    <div class="modal-body" id="jelly-ball-options-container" style="display: flex; flex-direction: column; gap: 15px;">
                        <div class="toggle-section">
                            <span>启用左滑返回 (应用内网页)</span>
                            <label class="toggle-switch"><input type="checkbox" id="jellySwipeBackToggle"><span class="slider"></span></label>
                        </div>
                        <div class="toggle-section">
                            <span>每次启动时随机应用预设</span>
                            <label class="toggle-switch"><input type="checkbox" id="jellyRandomCssToggle"><span class="slider"></span></label>
                        </div>
                        <div class="toggle-section" style="flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                            <label style="font-size: 14px; color: #5a6778; font-weight: 600;">自定义功能</label>
                            <div id="jelly-function-checkboxes" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px 15px; width: 100%;"></div>
                        </div>
                        <div class="toggle-section" style="flex-direction: column; align-items: flex-start; gap: 10px;">
                            <label for="jellyBallCssTextarea" style="font-size: 14px; color: #5a6778; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                <span>自定义CSS</span>
                               <button id="show-jelly-css-help" style="background:none; border:none; font-size: 20px; cursor:pointer; padding:0; line-height: 1;" title="CSS提示词向导"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="13px" height="13px" viewBox="0 0 24 24"><path d="m20,15v-6c0-4.411-3.589-8-8-8S4,4.589,4,9v6c0,1.103-.897,2-2,2v2h20v-2c-1.103,0-2-.897-2-2Z" stroke-width="0" fill="rgba(255, 240, 0, 1)"></path><path d="m8.538,21l.875,1.503c.537.924,1.528,1.497,2.587,1.497s2.05-.573,2.587-1.497l.875-1.503h-6.924Z" fill="rgba(255, 240, 0, 1)" stroke-width="0" data-color="color-2"></path></svg></button>
                            </label>
                            <!-- ★ 修改：全新简洁的预设管理UI ★ -->
                            <div class="preset-row" style="width:100%;">
                                <select id="jellyCssPresetSelector" class="modal-select" style="flex-grow: 1;"></select>
                                <button id="addJellyCssPresetBtn" title="添加新预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;">+</button>
                               <button id="editJellyCssPresetBtn" title="修改当前预设" class="modal-button" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 24 24" style="vertical-align: middle;"><rect x="1" y="20" width="22" height="2" fill="currentColor" stroke-width="0" data-color="color-2"></rect><path d="m18.875,2.125c-1.492-1.493-3.922-1.493-5.414,0L4.079,11.507l-1.354,6.768,6.768-1.354,9.382-9.382c1.493-1.493,1.493-3.921,0-5.414Zm-1.414,4l-.875.875-2.586-2.586.875-.875c.713-.713,1.873-.713,2.586,0s.713,1.873,0,2.586Z" stroke-width="0" fill="currentColor"></path></svg></button>
                                <button id="deleteJellyCssPresetBtn" title="删除当前预设" class="modal-button delete" style="width: auto; padding: 12px; font-size: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 24 24" style="vertical-align: middle;"><path d="m4.458,9l.463,11.125c.067,1.612,1.384,2.875,2.998,2.875h8.163c1.613,0,2.93-1.263,2.998-2.875l.463-11.125H4.458Z" stroke-width="0" fill="currentColor"></path><path d="m16,5V1h-8v4H2v2h20v-2h-6Zm-6-2h4v2h-4v-2Z" fill="currentColor" stroke-width="0" data-color="color-2"></path></svg></button>
                            </div>
                            <div style="display: flex; gap: 15px; width:100%; align-items: center;">
                                <textarea id="jellyBallCssTextarea" class="modal-textarea" rows="5" placeholder="在此粘贴CSS代码，或清空以恢复默认样式" style="flex: 1;"></textarea>
                                <!-- [修改] 将预览框和预览按钮包裹在一个垂直布局的容器中 -->
                                <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                                    <div id="jelly-css-preview-container">
                                        <div class="jelly-ball-wrapper">
                                            <div class="jelly-ball-glow"></div>
                                            <div id="floating-jellyfish-ball"><span>🪼</span></div>
                                        </div>
                                    </div>
                                    <!-- [新增] “预览”按钮 -->
                                    <button id="previewJellyBallCssBtn" class="modal-button" style="padding: 5px 10px; font-size: 12px; width: auto;">预览</button>
                                </div>
                            </div>
                            <!-- [修改] 按钮文本改为“应用并刷新” -->
                            <button id="applyJellyBallCssBtn" class="modal-button" style="width: 100%;">应用并刷新</button>
                        </div>
                    </div>
                `;
                
                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);

                // UI元素获取
                const closeBtn = modalContent.querySelector('.close-btn');
                const swipeBackToggle = modalContent.querySelector('#jellySwipeBackToggle');
                const randomCssToggle = modalContent.querySelector('#jellyRandomCssToggle');
                const checkboxContainer = modalContent.querySelector('#jelly-function-checkboxes');
                const cssTextarea = modalContent.querySelector('#jellyBallCssTextarea');
                const applyCssBtn = modalContent.querySelector('#applyJellyBallCssBtn');
                const previewWrapper = modalContent.querySelector('#jelly-css-preview-container .jelly-ball-wrapper');
                
                // ★ 修改：获取新的预设UI元素
                const presetSelector = modalContent.querySelector('#jellyCssPresetSelector');
                const addPresetBtn = modalContent.querySelector('#addJellyCssPresetBtn');
                const editPresetBtn = modalContent.querySelector('#editJellyCssPresetBtn');
                const deletePresetBtn = modalContent.querySelector('#deleteJellyCssPresetBtn');
                
                // 初始化
                if (!settings.cssPresets) settings.cssPresets = [];
                
                const closeModal = () => { modalOverlay.classList.remove('show'); modalOverlay.addEventListener('transitionend', () => modalOverlay.remove(), { once: true }); };
                closeBtn.onclick = closeModal;
                modalOverlay.onclick = (e) => { if (e.target === modalOverlay) closeModal(); };

                // 填充UI
                swipeBackToggle.checked = settings.swipeBack !== false;
                randomCssToggle.checked = localStorage.getItem('jellyRandomCssEnabled') === 'true';
                checkboxContainer.innerHTML = '';
                ALL_FUNCTIONS.forEach(func => {
                    const isChecked = settings.functions?.[func.id] !== false;
                    checkboxContainer.innerHTML += `<div style="display:flex;justify-content:space-between;align-items:center;"><label for="jelly_func_${func.id}" style="cursor:pointer;">${func.icon} ${func.title}</label><label class="toggle-switch"><input type="checkbox" id="jelly_func_${func.id}" data-function-id="${func.id}" ${isChecked?'checked':''}><span class="slider"></span></label></div>`;
                });
                cssTextarea.value = settings.customCSS || '';

                function populateCssPresetDropdown() {
                    const currentVal = presetSelector.value;
                    presetSelector.innerHTML = '<option value="">选择或管理预设...</option>';
                    settings.cssPresets.forEach((preset, index) => {
                        presetSelector.innerHTML += `<option value="${index}">${preset.name}</option>`;
                    });
                    if(currentVal) presetSelector.value = currentVal;
                }
                populateCssPresetDropdown();

                // ★ 修复：为预览功能提供正确的实现
                function updatePreview() {
                    // 获取用于应用自定义CSS的style标签
                    const customStyleTag = document.getElementById('custom-jelly-ball-styles');
                    // 确保style标签和css文本框都存在
                    // cssTextarea 变量是在这个函数外部定义的，在当前作用域中可用
                    if (customStyleTag && cssTextarea) {
                        // 将文本框中的CSS内容直接写入style标签，浏览器会自动应用
                        customStyleTag.innerHTML = cssTextarea.value;
                    }
                }
                // 在弹窗打开时立即调用一次，以显示当前已保存的CSS效果
                updatePreview(); 


                // 获取新按钮
                const previewCssBtn = modalContent.querySelector('#previewJellyBallCssBtn');

                // 事件监听 (通用部分)
                
                // cssTextarea.addEventListener('input', updatePreview); // 1. [修改] 移除或注释掉此行，以关闭实时预览
                
                // 2. [新增] 为新添加的“预览”按钮绑定点击事件，调用原有的 updatePreview 函数
                if (previewCssBtn) {
                    previewCssBtn.addEventListener('click', updatePreview);
                }

                // 其他监听器保持不变
                swipeBackToggle.addEventListener('change', () => { settings.swipeBack = swipeBackToggle.checked; saveGlobalConfig('Update Jellyfish Ball settings'); });
                randomCssToggle.addEventListener('change', () => { localStorage.setItem('jellyRandomCssEnabled', randomCssToggle.checked); });
                checkboxContainer.addEventListener('change', e => { if (e.target.dataset.functionId) { if (!settings.functions) settings.functions = {}; settings.functions[e.target.dataset.functionId] = e.target.checked; _renderMenuButtons(); saveGlobalConfig('Update Jellyfish Ball settings'); } });
                
                // 3. [修改] “应用并刷新”按钮的功能
                applyCssBtn.addEventListener('click', async () => {
                    // ★ 修复：立即弹出提示，然后再执行保存和刷新操作
                    showTopToast("设置已保存，正在刷新...", 2000);
                    
                    settings.customCSS = cssTextarea.value;
                    await saveGlobalConfig('Update Jellyfish Ball CSS');
                    
                    // 延迟刷新以确保用户能看到提示
                    setTimeout(() => location.reload(), 500);
                });


                modalContent.querySelector('#show-jelly-css-help').addEventListener('click', () => document.getElementById('jelly-css-help-modal').classList.add('show'));


                // ★ 新增：修改预设的弹窗函数 ★
                function _createModifyPresetModal(preset, index) {
                    const editModal = document.createElement('div');
                    editModal.className = 'modal-overlay show';
                    editModal.style.zIndex = '1003';
                    editModal.innerHTML = `
                        <div class="modal-content" style="max-width: 400px;">
                            <div class="modal-header"><div class="modal-title-group">修改预设</div><button class="close-edit-btn">&times;</button></div>
                            <div class="modal-body" style="gap: 15px;">
                                <input type="text" id="editPresetName" class="modal-input" value="${preset.name}">
                                <textarea id="editPresetCss" class="modal-textarea" rows="8">${preset.css}</textarea>
                                <button id="saveEditBtn" class="modal-button">保存更改</button>
                            </div>
                        </div>`;
                    document.body.appendChild(editModal);
                    const closeEditModal = () => editModal.remove();
                    editModal.querySelector('.close-edit-btn').onclick = closeEditModal;
                    editModal.onclick = (e) => { if(e.target === editModal) closeEditModal(); };

                    editModal.querySelector('#saveEditBtn').onclick = () => {
                        const newName = editModal.querySelector('#editPresetName').value.trim();
                        const newCss = editModal.querySelector('#editPresetCss').value;
                        if (!newName) return alert('预设名称不能为空');
                        if (newName !== preset.name && settings.cssPresets.some(p => p.name === newName)) {
                            return alert('该预设名称已存在');
                        }
                        settings.cssPresets[index] = { name: newName, css: newCss };
                        saveGlobalConfig(`Update Jelly CSS preset: ${newName}`);
                        populateCssPresetDropdown();
                        presetSelector.value = index;
                        cssTextarea.value = newCss;
                        updatePreview();
                        closeEditModal();
                    };
                }

                // ★ 修改：简洁版预设管理事件监听 ★
                addPresetBtn.addEventListener('click', () => {
                    const name = prompt('请输入新预设的名称：');
                    if (!name || name.trim() === '') return;
                    if (settings.cssPresets.some(p => p.name === name.trim())) return alert('预设名称已存在');
                    settings.cssPresets.push({ name: name.trim(), css: cssTextarea.value });
                    saveGlobalConfig(`Save Jelly CSS preset: ${name.trim()}`);
                    populateCssPresetDropdown();
                    presetSelector.value = settings.cssPresets.length - 1;
                });
                
                editPresetBtn.addEventListener('click', () => {
                    const index = presetSelector.value;
                    if (index === '') return alert('请先从下拉框中选择一个要修改的预设');
                    _createModifyPresetModal(settings.cssPresets[index], index);
                });

                deletePresetBtn.addEventListener('click', () => {
                    const index = presetSelector.value;
                    if (index === '') return alert('请先从下拉框中选择一个要删除的预设');
                    const presetName = settings.cssPresets[index].name;
                    if (!confirm(`确定要删除预设 "${presetName}" 吗？`)) return;
                    settings.cssPresets.splice(index, 1);
                    saveGlobalConfig(`Delete Jelly CSS preset: ${presetName}`);
                    populateCssPresetDropdown();
                    cssTextarea.value = settings.customCSS || '';
                    updatePreview();
                });
                
                presetSelector.addEventListener('change', () => {
                    const index = presetSelector.value;
                    if (index === '') {
                        cssTextarea.value = settings.customCSS || '';
                    } else {
                        cssTextarea.value = settings.cssPresets[index].css;
                    }
                    updatePreview();
                });
            }

            // 主开关的UI和逻辑控制
            const updateUIVisibility = () => {
                settingsEntry.style.display = toggle.checked ? 'block' : 'none';
            };
            
            toggle.checked = settings.enabled || false;
            customStyleTag.innerHTML = settings.customCSS || ''; // 初始加载CSS

            toggle.addEventListener('change', () => {
                settings.enabled = toggle.checked;
                updateUIVisibility();
                if (settings.enabled) _create(); else _destroy();
                saveGlobalConfig('Toggle Jellyfish Ball');
            });

            openSettingsBtn.addEventListener('click', openJellyBallSettingsWindow);
            
            updateUIVisibility();
        }


        return { init: initSettings, create: _create, destroy: _destroy };
    })();
    // ===== [END] FLOATING JELLYFISH BALL LOGIC =====
        /* =============================================================== */
        /* ============== [最终修正] 备份提醒功能管理器 V3.0 =============== */
        /* =============================================================== */
        const BackupReminderManager = (() => {
            // [核心修改1] 将 ui 对象声明为空，延迟初始化
            let ui = {}; 
            let activeTimers = [];

            // [核心修改2] 新增一个专门用于获取DOM元素的函数
            function initUI() {
                ui = {
                    // 入口
                    toggle: document.getElementById('backupReminderToggle'),
                    settingsEntry: document.getElementById('backupSettingsEntry'),
                    openSettingsBtn: document.getElementById('openBackupSettingsBtn'),
                    // 设置弹窗 V2
                    modal: document.getElementById('backupReminderSettingsModal'),
                    timeBasedToggle: document.getElementById('backupTimeBasedToggle'),
                    timeContainer: document.getElementById('backupTimeContainer'),
                    timeListContainer: document.getElementById('backupTimeListContainer'),
                    messageTextarea: document.getElementById('backupMessageTextarea'),
                    onExitToggle: document.getElementById('backupOnExitToggle'),
                    projectsSection: document.getElementById('backupProjectsSection'),
                    projectList: document.getElementById('backupProjectList'),
                    saveBtn: document.getElementById('saveBackupSettingsBtn'),
                };
            }

            function getSettings() {
                if (!currentConfig.settings.backupReminder) {
                    currentConfig.settings.backupReminder = getDefaultConfig().settings.backupReminder;
                }
                return currentConfig.settings.backupReminder;
            }
            
            function renderTimeRows(times = []) {
                ui.timeListContainer.innerHTML = '';
                if (times.length > 0) {
                    times.forEach(time => addTimeRow(time));
                } else {
                    addTimeRow();
                }
            }

            function addTimeRow(timeValue = '') {
                const row = document.createElement('div');
                row.className = 'time-input-row';
                row.innerHTML = `
                    <input type="time" class="modal-input" value="${timeValue}">
                    <button class="time-action-btn add" title="添加新一行">+</button>
                    <button class="time-action-btn remove" title="删除此行">-</button>
                `;
                row.querySelector('.add').addEventListener('click', () => addTimeRow());
                row.querySelector('.remove').addEventListener('click', (e) => {
                    if (ui.timeListContainer.childElementCount <= 1) {
                         e.currentTarget.parentElement.querySelector('input[type="time"]').value = '';
                    } else {
                         e.currentTarget.parentElement.remove();
                    }
                });
                ui.timeListContainer.appendChild(row);
            }

            function renderProjectList() {
                ui.projectList.innerHTML = '';
                const reminderSettings = getSettings();
                const allButtons = currentConfig.categories.flatMap(c => c.buttons);
                const uniqueButtons = Array.from(new Map(allButtons.map(item => [item.href, item])).values());
                if (uniqueButtons.length === 0) {
                    ui.projectList.innerHTML = '<p style="color: #889; text-align: center;">暂无项目</p>';
                    return;
                }
                uniqueButtons.forEach(btn => {
                    const isChecked = reminderSettings.projects.includes(btn.href);
                    const itemHtml = `<label class="project-checkbox-item"><input type="checkbox" data-href="${btn.href}" ${isChecked ? 'checked' : ''}><span>${btn.text}</span></label>`;
                    ui.projectList.innerHTML += itemHtml;
                });
            }

            function populateSettingsModal() {
                const settings = getSettings();
                ui.messageTextarea.value = settings.message;
                ui.timeBasedToggle.checked = settings.timeBasedEnabled;
                ui.timeContainer.style.display = settings.timeBasedEnabled ? 'flex' : 'none';
                renderTimeRows(settings.times);
                ui.onExitToggle.checked = settings.onExit;
                ui.projectsSection.style.display = settings.onExit ? 'block' : 'none';
                renderProjectList();
            }

            function openSettingsModal() {
                populateSettingsModal();
                ui.modal.classList.add('show');
            }

            function saveSettings() {
                const times = Array.from(ui.timeListContainer.querySelectorAll('.time-input-row input[type="time"]'))
                                .map(input => input.value)
                                .filter(Boolean);

                const newSettings = {
                    enabled: getSettings().enabled,
                    timeBasedEnabled: ui.timeBasedToggle.checked,
                    times: [...new Set(times)],
                    message: ui.messageTextarea.value.trim() || '是时候该备份你的项目啦！',
                    onExit: ui.onExitToggle.checked,
                    projects: Array.from(ui.projectList.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.dataset.href)
                };

                currentConfig.settings.backupReminder = newSettings;
                saveGlobalConfig('Update backup reminder settings');
                startTimers();
                ui.modal.classList.remove('show');
                showTopToast('备份提醒设置已保存！', 2000);
            }
            
            function clearTimers() {
                activeTimers.forEach(timerId => clearTimeout(timerId));
                activeTimers = [];
            }

            function startTimers() {
                clearTimers();
                const settings = getSettings();
                if (!settings.enabled || !settings.timeBasedEnabled || settings.times.length === 0) return;
                const now = new Date();
                settings.times.forEach(timeStr => {
                    const [hours, minutes] = timeStr.split(':').map(Number);
                    let reminderTime = new Date();
                    reminderTime.setHours(hours, minutes, 0, 0);
                    if (reminderTime < now) reminderTime.setDate(reminderTime.getDate() + 1);
                    const delay = reminderTime.getTime() - now.getTime();
                    const createReminder = () => {
                        showTopToast(settings.message);
                        activeTimers.push(setTimeout(createReminder, 24 * 60 * 60 * 1000));
                    };
                    activeTimers.push(setTimeout(createReminder, delay));
                });
            }

            function triggerOnExitReminder() {
                const settings = getSettings();
                if (!settings.enabled || !settings.onExit) return;
                const originalUrl = iframeModal.dataset.originalUrl;
                if (!originalUrl) return;
                const targetProjects = settings.projects;
                if (targetProjects.length === 0 || targetProjects.includes(originalUrl)) {
                    showTopToast(settings.message);
                }
            }

            // [核心修改3] init 函数现在只负责绑定事件监听器
            function init() {
                const initialSettings = getSettings();
                ui.toggle.checked = initialSettings.enabled;
                ui.settingsEntry.style.display = initialSettings.enabled ? 'block' : 'none';

                ui.toggle.addEventListener('change', () => {
                    const settings = getSettings();
                    settings.enabled = ui.toggle.checked;
                    ui.settingsEntry.style.display = settings.enabled ? 'block' : 'none';
                    saveGlobalConfig('Toggle backup reminder');
                    if (settings.enabled) startTimers(); else clearTimers();
                });

                ui.openSettingsBtn.addEventListener('click', openSettingsModal);
                ui.timeBasedToggle.addEventListener('change', () => {
                    ui.timeContainer.style.display = ui.timeBasedToggle.checked ? 'flex' : 'none';
                });
                ui.onExitToggle.addEventListener('change', () => {
                    ui.projectsSection.style.display = ui.onExitToggle.checked ? 'block' : 'none';
                });
                ui.saveBtn.addEventListener('click', saveSettings);

                startTimers();
            }

            // [核心修改4] 导出 initUI 和 init
            return {
                init,
                initUI,
                triggerOnExitReminder
            };

        })();


    const utf8_to_b64 = (str) => btoa(unescape(encodeURIComponent(str)));
    const b64_to_utf8 = (str) => decodeURIComponent(escape(atob(str)));

    function b64toBlob(b64Data, contentType = '', sliceSize = 512) {
        contentType = contentType || 'application/octet-stream';
        const byteCharacters = atob(b64Data);
        const byteArrays = [];
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            const slice = byteCharacters.slice(offset, offset + sliceSize);
            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        return new Blob(byteArrays, { type: contentType });
    }

    async function handleApiError(context, error) {
        let userMessage = `${context}失败，请稍后重试。`;
        const errorString = error.message || String(error);

        try {
            const errorJson = JSON.parse(errorString.substring(errorString.indexOf('{')));
            if (errorJson.message) {
                if (errorJson.message.includes("Not Found")) {
                    userMessage = `${context}失败：找不到目标文件或路径。请检查您的仓库配置和路径是否正确。`;
                } else if (errorJson.message.includes("Bad credentials")) {
                    userMessage = `认证失败：您的 Personal Access Token 无效或已过期。`;
                } else if (errorJson.message.includes("requires authentication")) {
                    userMessage = `认证失败：此操作需要有效的 Personal Access Token。`;
                } else if (errorJson.message.includes("sha doesn't match")) {
                    userMessage = `同步冲突：云端数据已被更新，请使用“手动同步与修复”功能后再试。`;
                } else if (errorJson.message.includes("path exists")) {
                    userMessage = `${context}失败：云端已存在同名文件或文件夹。`;
                } else {
                     userMessage = `${context}失败：${errorJson.message}`;
                }
            }
        } catch (e) {
            if (errorString.includes('401') || errorString.includes('403')) {
                userMessage = `认证失败：请检查您的 Personal Access Token 是否正确且拥有 'repo' 权限。`;
            } else if (errorString.includes('404')) {
                userMessage = `${context}失败：找不到对应的文件或仓库。请检查您的仓库配置是否正确。`;
            } else if (errorString.toLowerCase().includes('failed to fetch') || errorString.toLowerCase().includes('networkerror')) {
                userMessage = '网络连接失败，请检查您的网络并重试。';
            } else if (errorString.includes('rate limit exceeded')) {
                userMessage = 'API请求频率过高，请稍等片刻再试。';
            }
        }
        
        console.error(`API Error in context "${context}":`, error);
        return userMessage;
    }

    let syncStatusTimeout;
    function updateSyncStatus(status, message = '') {
        syncStatusIndicator.className = status;
        syncStatusIndicator.title = message || `云同步状态: ${status}`;
        clearTimeout(syncStatusTimeout);
        if (status === 'synced') {
            syncStatusTimeout = setTimeout(() => {
                syncStatusIndicator.className = '';
                syncStatusIndicator.title = '云同步状态';
            }, 3000);
            syncErrorModal.classList.remove('show');
        } else if (status === 'error') {
            // [核心修改] 只有在已配置的情况下才弹出错误框
            const isConfigured = GITHUB_CONFIG.owner && GITHUB_CONFIG.repo && GITHUB_CONFIG.token;
            if (isConfigured) {
                document.getElementById('sync-error-message').textContent = message;
                syncErrorModal.classList.add('show');
            }
        }
    }

    
    async function fetchFromGithub(path, method = 'GET', body = null, signal = null) {
        if (!checkConfig(false)) return { data: null, error: "GitHub未配置" };
        
        let endpoint, displayContext, showSyncIndicator = false;
        if(method === 'contents' || method === 'git') { // Legacy compatibility
            endpoint = method;
            method = 'GET';
        } else {
            endpoint = 'contents';
        }

        if(path.startsWith('git/blobs')) {
            endpoint = 'git'; // Override for blob fetches
            path = path.substring(4);
            displayContext = '读取文件内容';
        } else {
            displayContext = `读取 ${path}`;
            showSyncIndicator = true;
        }

        if (showSyncIndicator) updateSyncStatus('syncing', `正在从云端读取...`);

        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/${endpoint}/${path}`;
        
        try {
            const response = await fetch(url, {
                method: method,
                headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` },
                body: body ? JSON.stringify(body) : null,
                signal: signal, // Pass the signal to fetch
                cache: 'no-cache'
            });

            if (response.status === 404) return { data: null, error: null, response };
            if (!response.ok) {
                 const errorData = await response.json().catch(() => ({}));
                 throw new Error(`${response.status}: ${JSON.stringify(errorData)}`);
            }
            
            const data = await response.json();

            // ========================= [ 最终修正 V3 - 兼容空字符串判断 START ] =========================
            // 检查这是否是一个需要二次请求的大文件。
            // 核心修正：API 可能返回 content: null 或 content: ""，我们都需要处理。
            if (data && (data.content === null || data.content === "") && data.type === 'file' && data.sha) {
                // 对二次请求进行独立的 try...catch，防止其失败影响整个函数
                try {
                    console.log(`File "${path}" is >1MB (content is emptyish). Fetching content via Blobs API using SHA: ${data.sha}`); // 日志更新
                    if (showSyncIndicator) updateSyncStatus('syncing', `文件较大，正在获取内容...`);

                    const blobUrl = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/git/blobs/${data.sha}`;
                    const blobResponse = await fetch(blobUrl, {
                        method: 'GET',
                        headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` },
                        signal: signal,
                        cache: 'no-cache'
                    });

                    if (!blobResponse.ok) {
                        const errorData = await blobResponse.json().catch(() => ({}));
                        throw new Error(`Blobs API fetch failed with status ${blobResponse.status}: ${JSON.stringify(errorData)}`);
                    }

                    const blobData = await blobResponse.json();
                    
                    if (blobData && blobData.content) {
                        data.content = blobData.content;
                        console.log('Successfully fetched large file content and patched the data object.');
                    } else {
                        console.warn(`Blobs API response for SHA ${data.sha} was successful but did not contain a 'content' field.`);
                    }

                } catch (blobError) {
                    console.error(`[IMPORTANT] Failed to fetch large file content via Blobs API for file "${path}". The function will return the original metadata without the content.`, blobError);
                }
            }
            // ========================= [ 最终修正 V3 - 兼容空字符串判断 END ] =========================

            if (showSyncIndicator) updateSyncStatus('synced', '读取成功');
            return { data, response };

        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Fetch aborted by user.');
                return { data: null, error: '用户取消了操作' };
            }
            const userMessage = await handleApiError(displayContext, error);
            if (showSyncIndicator) updateSyncStatus('error', userMessage);
            return { data: null, error: userMessage, response: null };
        }
    }

    async function saveToGithub(path, content, commitMessage, sha = null) { // sha is now effectively a fallback
        if (!checkConfig(true)) {
            updateSyncStatus('error', '配置不完整，无法同步。');
            return { sha: null, error: "配置不完整" };
        }
        updateSyncStatus('syncing', `正在同步: ${commitMessage}`);
        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;
        const body = { message: commitMessage, content: content, branch: 'main' };

        // ============ [核心修复逻辑 V2] ============
        // 在每次写入前，都主动获取最新的 sha，从根本上解决冲突问题
        try {
            const { data: remoteFileData, response: fetchResponse } = await fetchFromGithub(path);
            // 如果文件存在(响应不是404)，就使用它的 sha
            if (fetchResponse && fetchResponse.status !== 404 && remoteFileData && remoteFileData.sha) {
                console.log(`Fetched latest sha for "${path}" before saving.`);
                body.sha = remoteFileData.sha;
            } else {
                // 如果文件不存在 (404)，则不提供 sha，这是创建新文件的正确行为
                console.log(`File "${path}" not found on remote. Proceeding with creation.`);
            }
        } catch (e) {
            // 如果在获取 sha 的过程中出错，则中止保存操作
            const userMessage = await handleApiError(`准备写入 ${path} 时`, e);
            updateSyncStatus('error', userMessage);
            return { sha: null, error: userMessage };
        }
        // =========================================

        try {
            const response = await fetch(url, {
                method: 'PUT',
                headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` },
                body: JSON.stringify(body),
                cache: 'no-cache'
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                // 专门处理仍然可能发生的、极小概率的竞争条件
                if (response.status === 409 || response.status === 422 || (errorData.message && errorData.message.includes("sha "))) {
                    const conflictMessage = `同步冲突：在您保存的瞬间，云端数据被另一处修改。请稍后重试。`;
                    updateSyncStatus('error', conflictMessage);
                    return { sha: null, error: conflictMessage };
                }
                throw new Error(`${response.status}: ${JSON.stringify(errorData)}`);
            }

            const data = await response.json();
            updateSyncStatus('synced', '同步成功！');
            
            // [重要] 返回新的 sha，以便全局变量可以更新
            const newSha = data.content.sha;
            if (path === 'config.json') configSha = newSha;
            if (path === 'memory/data.json') MemoryApp.updateSha(newSha); // 需要在MemoryApp中添加一个更新sha的函数
            
            return { sha: newSha, error: null };
            
        } catch (error) {
            const userMessage = await handleApiError(`写入 ${path}`, error);
            updateSyncStatus('error', userMessage);
            return { sha: null, error: userMessage };
        }
    }

    
    async function uploadFileViaGitData({ file, path, commitMessage, onProgress }) {
        if (!checkConfig(true)) throw new Error("GitHub未配置");
        
        // 1. 将文件读取为 Base64 编码的 Data URL
        const contentB64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            //  reader.onload 的结果是 'data:image/jpeg;base64,....'，我们需要去掉头部
            reader.onload = () => resolve(reader.result.split(',')[1]); 
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });

        // 2. 调用我们已经非常稳定的 saveToGithub 函数
        // 这个函数内部使用了 Contents API (PUT /.../contents/:path)，是原子操作，更可靠。
        // 它还会自动处理文件已存在时的 SHA 更新，避免冲突。
        
        // 尽管 onProgress 不再被精确调用，我们仍然可以在关键步骤调用它来更新UI
        if (onProgress) onProgress(50); // 表示文件已读取，准备上传

        const result = await saveToGithub(path, contentB64, commitMessage);

        if (onProgress) onProgress(100);

        // 3. 检查结果并返回
        if (result.sha) {
            // 上传成功，返回与旧函数兼容的格式
            return { sha: result.sha, path: path };
        } else {
            // 如果 saveToGithub 失败，它内部已经处理了错误提示，这里我们抛出错误以便上层捕获
            throw new Error(result.error || "未知上传错误");
        }
    }

    async function deleteFromGithub(path, commitMessage, sha, ignoreNotFound = false) {
        if (!checkConfig(true)) return false;
        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;
        try {
            const response = await fetch(url, {
                method: 'DELETE',
                headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` },
                body: JSON.stringify({ message: commitMessage, sha: sha, branch: 'main' }),
                cache: 'no-cache'
            });
            if (response.status === 404 && ignoreNotFound) {
                console.log(`File ${path} not found during deletion, which is acceptable.`);
                return true;
            }
            if (!response.ok) {
                 const errorData = await response.json().catch(() => ({}));
                 throw new Error(`${response.status}: ${JSON.stringify(errorData)}`);
            }
            return true;
        } catch (error) {
            const userMessage = await handleApiError(`删除文件 ${path.split('/').pop()}`, error);
            console.error(userMessage);
            return false;
        }
    }

    async function fetchConfigFromGithub() {
        const { data, error } = await fetchFromGithub('config.json');
        if (error && error !== "GitHub未配置") {
             navContainer.innerHTML = `<p id="loading-status" style="text-align: center; color: #e53e3e;">加载配置失败：${error}</p>`;
             return null;
        }
        if (data) {
            configSha = data.sha;
            try {
                return JSON.parse(b64_to_utf8(data.content));
            } catch (e) {
                alert('云端 config.json 文件格式错误，请尝试使用“手动同步与修复”功能。');
                return null;
            }
        }
        return null;
    }
    
async function saveGlobalConfig(commitMessage) {
        // [核心修改] 在保存到云端前，立即更新本地缓存
        // 这样可以确保即使用户在保存完成前刷新，也能看到最新的更改
        localStorage.setItem('currentConfig', JSON.stringify(currentConfig));
        const content = utf8_to_b64(JSON.stringify(currentConfig, null, 2));
        const result = await saveToGithub('config.json', content, commitMessage, configSha);
        if (result.sha) {
            configSha = result.sha;
            console.log('Global configuration saved successfully.');
        } else {
            // 错误处理已在 saveToGithub 内部完成
        }
    }


    function toggleManagementMode(forceState) {
        isManagementMode = forceState !== undefined ? forceState : !isManagementMode;
        
        // [核心修复] 移除对 pageOverlay 的所有操作，不再显示那层“透明膜”
        // pageOverlay.classList.toggle('show', isManagementMode);
        // pageOverlay.classList.toggle('management-overlay', isManagementMode);

        document.body.classList.toggle('management-active', isManagementMode);
        document.querySelectorAll('.nav-btn').forEach(btn => {
            const deleteIcon = btn.querySelector('.delete-icon');
            if (isManagementMode) {
                 btn.title = '点击编辑，点击 × 删除';
                if (!deleteIcon) {
                    const icon = document.createElement('span');
                    icon.className = 'delete-icon';
                    icon.innerHTML = '&times;';
                    icon.title = '删除此按钮';
                    btn.appendChild(icon);
                }
            } else {
                btn.title = '';
                if (deleteIcon) {
                    deleteIcon.remove();
                }
            }
        });
    }

    const fabContainer = document.getElementById('fabContainer'), fabMainBtn = document.getElementById('themeBtn');
    let fabPressTimer = null, isFabLongPress = false;
    function toggleFabMenu(forceState) { const isActive = forceState !== undefined ? forceState : !fabContainer.classList.contains('active'); fabContainer.classList.toggle('active', isActive); if (!isManagementMode) pageOverlay.classList.toggle('show', isActive); }
    fabMainBtn.addEventListener('mousedown', (e) => { e.preventDefault(); isFabLongPress = false; fabPressTimer = setTimeout(() => { isFabLongPress = true; toggleFabMenu(true); }, 300); });
    fabMainBtn.addEventListener('mouseup', () => { clearTimeout(fabPressTimer); if (!isFabLongPress) { fabContainer.classList.contains('active') ? toggleFabMenu(false) : toggleTheme(); } });
    fabMainBtn.addEventListener('contextmenu', e => e.preventDefault());
    fabMainBtn.addEventListener('touchstart', e => { e.preventDefault(); fabMainBtn.dispatchEvent(new MouseEvent('mousedown')); }, { passive: false });
    fabMainBtn.addEventListener('touchend', e => { e.preventDefault(); fabMainBtn.dispatchEvent(new MouseEvent('mouseup')); }, { passive: false });

        // [核心修复 V2] 使用 body 监听全局点击，以精准退出管理模式
    document.body.addEventListener('click', (e) => {
        // 如果 fab 菜单是打开的，点击任何地方都应该关闭它
        if (fabContainer.classList.contains('active') && !e.target.closest('.fab-container')) {
            toggleFabMenu(false);
        }

        // 如果不是管理模式，则不执行后续逻辑
        if (!isManagementMode) return;

        // 定义哪些元素被认为是“管理区域”，点击它们不应退出管理模式
        const isClickInsideManagementArea = 
            e.target.closest('.nav-btn') ||         // 点击了导航按钮本身
            e.target.closest('.modal-overlay') ||   // 点击了任何弹窗
            e.target.closest('.fab-container') ||   // 点击了右下角悬浮按钮
            e.target.closest('#addNavModalTitle');  // 兼容点击弹窗标题

        // 只有当点击事件不在“管理区域”内时，才退出管理模式
        if (!isClickInsideManagementArea) {
            toggleManagementMode(false);
        }
    }, true); // 使用捕获阶段，确保比其他点击事件更早执行，避免冲突

    function attachButtonListeners(btn) {
        btn.addEventListener('click', async function(e) {
            if (isManagementMode) {
                const href = this.dataset.href;
                if (!e.target.classList.contains('delete-icon')) {
                    e.preventDefault();
                    const buttonData = findButtonConfigByHref(href);
                    if (buttonData) {
                        openEditModal(buttonData);
                    }
                }
                return;
            }
            const href = this.dataset.href;
            if (!href) return;

            const buttonConfig = findButtonConfigByHref(href);

            if (buttonConfig && buttonConfig.openExternally) {
                window.open(href, '_blank', 'noopener,noreferrer');
                return;
            }

            if (href.startsWith('projects/')) {
                e.preventDefault();
                const secureUrl = await getSecureFileUrl(href);
                if(secureUrl) {
                    openIframeModal(secureUrl);
                } else {
                     alert('无法加载项目文件，请检查您的网络和GitHub配置。');
                }
                        } else if (href.startsWith('http')) {
                e.preventDefault();
                const isGithubLink = ['github.com', 'raw.githack.com', 'github.io'].some(domain => href.includes(domain));
                if (isGithubLink) {
                    // 调用新的非阻塞提示框函数
                    showTopToast('GitHub链接加载中，如遇缓慢请开启VPN');
                }
                openIframeModal(href);
            } else {

                window.location.href = href;
            }
        });
    }

    function findButtonConfigByHref(href) {
        for (const category of currentConfig.categories) {
            const button = category.buttons.find(b => b.href === href);
            if (button) return { ...button, categoryName: category.name };
        }
        return null;
    }

    document.getElementById('enterManageModeBtn').addEventListener('click', () => { document.getElementById('addNavModal').classList.remove('show'); setTimeout(() => toggleManagementMode(true), 150); });
    navContainer.addEventListener('click', async (e) => {
        if (!e.target.classList.contains('delete-icon')) return;
        e.stopPropagation();
        
        const btnToDelete = e.target.closest('.nav-btn');
        const buttonName = btnToDelete.firstChild.textContent.trim();
        const href = btnToDelete.dataset.href;
        
        const hasCloudFiles = await checkProjectFolderForFiles(buttonName);

        showDeleteOptionsDialog(buttonName, hasCloudFiles, async (choice) => {
            if (choice === 'transfer') {
                const buttonData = findButtonConfigByHref(href);
                if (buttonData) {
                    openTransferProjectModal(buttonData);
                } else {
                    alert('找不到项目数据，无法进行转移。');
                }
            } else if (choice === 'delete') {
                // 即使是自定义弹窗，对破坏性操作进行二次确认仍然是好习惯
                if (!confirm(`再次确认：确定要永久删除 "${buttonName}" 及其所有关联文件吗？此操作不可逆！`)) return;

                showTopToast(`正在删除 "${buttonName}"...`, 2000);
                btnToDelete.style.cssText = 'transition: all 0.3s ease; transform: scale(0.8); opacity: 0;';
                
                setTimeout(async () => {
                    btnToDelete.remove();
                    
                    // 从配置中移除按钮
                    currentConfig.categories.forEach(cat => {
                        cat.buttons = cat.buttons.filter(b => b.href !== href);
                    });
                    currentConfig.categories = currentConfig.categories.filter(cat => cat.name === '全部' || cat.buttons.length > 0);

                    // 删除云端文件和文件夹
                    if (href.startsWith('projects/')) {
                        const projectFolderPath = href.substring(0, href.lastIndexOf('/'));
                        await deleteGithubFolder(projectFolderPath);
                    }
                    const cloudFolderName = buttonName.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-");
                    await deleteGithubFolder(`jellyfish_drive/${cloudFolderName}`);

                    // 保存更新后的配置
                    await saveGlobalConfig(`Delete project: ${buttonName}`);
                    renderCategories();
                    renderButtonsForCategory(currentCategory);
                }, 300);
            }
            // 如果 choice 是 'cancel'，则什么也不做
        });
    });

    document.getElementById('title').addEventListener('click', () => { if(isManagementMode) return; const newTitle = prompt('新标题：', currentConfig.title); if (newTitle?.trim() && newTitle.trim() !== currentConfig.title) { document.getElementById('title').textContent = newTitle.trim(); currentConfig.title = newTitle.trim(); saveGlobalConfig('Update main title'); } });
    document.getElementById('subtitle').addEventListener('click', () => { if(isManagementMode) return; const newSubtitle = prompt('新描述：', currentConfig.subtitle); if (newSubtitle !== null && newSubtitle.trim() !== currentConfig.subtitle) { document.getElementById('subtitle').textContent = newSubtitle.trim(); currentConfig.subtitle = newSubtitle.trim(); saveGlobalConfig('Update subtitle'); } });
    
    function applyAllBackgrounds() {
        const isDark = document.body.classList.contains('dark-mode');
        const bodyBgKey = isDark ? 'nightBgImage' : 'dayBgImage';
        const bodyBgImage = localStorage.getItem(bodyBgKey);
        
        if (bodyBgImage) {
            document.body.style.backgroundImage = `url(${bodyBgImage})`;
        } else {
            const color1 = getComputedStyle(document.documentElement).getPropertyValue(isDark ? '--night-color1' : '--day-color1').trim();
            const color2 = getComputedStyle(document.documentElement).getPropertyValue(isDark ? '--night-color2' : '--day-color2').trim();
            document.body.style.backgroundImage = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
        }

        const titleCardBgKey = isDark ? 'nightTitleCardBgImage' : 'dayTitleCardBgImage';
        const titleCardBgImage = localStorage.getItem(titleCardBgKey);
        const titleCard = document.getElementById('titleCard');
        if (titleCardBgImage) {
            titleCard.style.backgroundImage = `url(${titleCardBgImage})`;
            titleCard.style.backgroundSize = 'cover';
            titleCard.style.backgroundPosition = 'center';
        } else {
            titleCard.style.backgroundImage = isDark ? 'var(--bg-night-element)' : 'var(--bg-day-element)';
        }
    }
    

    function toggleTheme() { 
        document.body.classList.toggle('dark-mode'); 
        const i=document.body.classList.contains('dark-mode'); 
        fabMainBtn.textContent=i?'🌜':'🌞'; 
        localStorage.setItem('theme', i?'dark':'light');
        applyAllBackgrounds();
        WanderView.updateTheme();
        renderLockscreenWidgets(); // 新增：切换主题时重新渲染组件

        // [新增] 联动Giscus主题
        const giscusFrame = document.querySelector('.giscus-frame');
        if (giscusFrame) {
            const newTheme = PhoneCollectionManager.getGiscusTheme();
            giscusFrame.contentWindow.postMessage({ giscus: { setConfig: { theme: newTheme } } }, 'https://giscus.app');
        }
    };

     function setThemeStyle(styleName) {
        const pneumorphismSettings = document.getElementById('pneumorphism-settings');
        if (styleName === 'glass') {
            document.body.classList.add('theme-glass');
            document.documentElement.style.setProperty('--shadow-dark-night', 'rgba(0, 0, 0, 0.1)');
            document.documentElement.style.setProperty('--shadow-dark-day', 'rgba(0, 0, 0, 0.1)');

            pneumorphismSettings.classList.add('hidden');
            document.getElementById('theme-style-glass').checked = true;
        } else { // 默认或 neumorphism
            document.body.classList.remove('theme-glass');
            document.documentElement.style.setProperty('--shadow-dark-day', 'rgba(174, 190, 212, 0.4)');
             document.documentElement.style.setProperty('--shadow-dark-night', 'rgba(0, 0, 0, 0.3)');
            pneumorphismSettings.classList.remove('hidden');
            document.getElementById('theme-style-neumorphism').checked = true;
        }
        
        // [修改] 将设置存入 config 文件并触发保存，而不是 localStorage
        if (currentConfig.settings.themeStyle !== styleName) {
            currentConfig.settings.themeStyle = styleName;
            saveGlobalConfig('Update theme style');
        }

        // [新增] 联动Giscus主题
        const giscusFrame = document.querySelector('.giscus-frame');
        if (giscusFrame) {
            const newTheme = PhoneCollectionManager.getGiscusTheme();
            giscusFrame.contentWindow.postMessage({ giscus: { setConfig: { theme: newTheme } } }, 'https://giscus.app');
        }
    }


    document.querySelectorAll('input[name="theme-style"]').forEach(radio => {
        radio.addEventListener('change', (e) => setThemeStyle(e.target.value));
    });

    const colorModal = { 
        pickerD1: document.getElementById('dayColor1Picker'), hexD1: document.getElementById('dayColor1HexInput'),
        pickerD2: document.getElementById('dayColor2Picker'), hexD2: document.getElementById('dayColor2HexInput'),
        pickerN1: document.getElementById('nightColor1Picker'), hexN1: document.getElementById('nightColor1HexInput'),
        pickerN2: document.getElementById('nightColor2Picker'), hexN2: document.getElementById('nightColor2HexInput'),
        presetSelector: document.getElementById('presetSelector'), 
        randomToggle: document.getElementById('randomPaletteToggle'),
        dayPreview: document.getElementById('dayPreview'), nightPreview: document.getElementById('nightPreview') 
    };
    const root = document.documentElement;
    function applyColors(colors, saveToLocal = true) { 
        Object.entries(colors).forEach(([key, value]) => { 
            const cssVar = `--${key.replace('Color', '-color')}`; 
            root.style.setProperty(cssVar, value); 
            if (saveToLocal) localStorage.setItem(key, value); 
        }); 
        updateColorUI(colors); 
        applyAllBackgrounds(); 
        WanderView.updateTheme(); 
    }
    function updateColorUI(colors) { 
        colorModal.pickerD1.value = colors.dayColor1; colorModal.hexD1.value = colors.dayColor1;
        colorModal.pickerD2.value = colors.dayColor2; colorModal.hexD2.value = colors.dayColor2;
        colorModal.pickerN1.value = colors.nightColor1; colorModal.hexN1.value = colors.nightColor1;
        colorModal.pickerN2.value = colors.nightColor2; colorModal.hexN2.value = colors.nightColor2;
        colorModal.dayPreview.style.background = `linear-gradient(135deg, ${colors.dayColor2}, ${colors.dayColor1})`; 
        colorModal.nightPreview.style.background = `linear-gradient(135deg, ${colors.nightColor2}, ${colors.nightColor1})`; 
    }
    function getCurrentColors(fromLocalStorage = true) { 
        const source = fromLocalStorage ? localStorage : { getItem: (key) => getComputedStyle(root).getPropertyValue(`--${key.replace('Color', '-color')}`).trim() }; 
        return { 
            dayColor1: source.getItem('dayColor1') || '#f5f7fa', 
            dayColor2: source.getItem('dayColor2') || '#e4eaf5', 
            nightColor1: source.getItem('nightColor1') || '#1f2a40', 
            nightColor2: source.getItem('nightColor2') || '#16213e', 
        }; 
    }
    function setupColorSync(picker, hexInput, key) { 
        picker.addEventListener('input', () => { 
            hexInput.value = picker.value; 
            applyColors({ ...getCurrentColors(), [key]: picker.value }); 
        }); 
    }
    // [V2 优化] 函数，用于同步十六进制输入框的更改，并增加UX交互
    function setupHexInputSync(hexInput, colorPicker, key) {
        const handleHexInput = () => {
            let value = hexInput.value.trim();
            if (!value.startsWith('#')) value = '#' + value;
            if (/^#([0-9a-f]{3}){1,2}$/i.test(value)) {
                colorPicker.value = value;
                applyColors({ ...getCurrentColors(false), [key]: value });
            } else {
                hexInput.value = colorPicker.value;
            }
            hexInput.classList.add('confirmed-color');
        };
        hexInput.addEventListener('focus', function() { this.classList.remove('confirmed-color'); this.select(); });
        hexInput.addEventListener('blur', handleHexInput);
        hexInput.addEventListener('keydown', e => { if (e.key === 'Enter') { handleHexInput(); hexInput.blur(); } });
        hexInput.classList.add('confirmed-color');
    }

    function loadColorState() { populatePresetDropdown(); const randomPaletteEnabled = localStorage.getItem('randomPaletteEnabled') === 'true'; colorModal.randomToggle.checked = randomPaletteEnabled; if (randomPaletteEnabled && currentConfig.themePresets && currentConfig.themePresets.length > 0) { const randomPreset = currentConfig.themePresets[Math.floor(Math.random() * currentConfig.themePresets.length)]; applyColors(randomPreset.colors, false); } else { applyColors(getCurrentColors()); } }
    function populatePresetDropdown() { colorModal.presetSelector.innerHTML = '<option value="">选择或管理预设...</option>'; (currentConfig.themePresets || []).forEach((p, i) => { const opt = document.createElement('option'); opt.value = i; opt.textContent = p.name; colorModal.presetSelector.appendChild(opt); }); }
    
    // ★ 全新的预设管理逻辑 ★
    const addPresetBtn = document.getElementById('addColorPresetBtn');
    const updatePresetBtn = document.getElementById('updateColorPresetBtn');
    const deletePresetBtn = document.getElementById('deleteColorPresetBtn');

    addPresetBtn.addEventListener('click', () => {
        const name = prompt("请输入新预设的名称：");
        if (!name || name.trim() === '') return;
        const trimmedName = name.trim();
        if ((currentConfig.themePresets || []).some(p => p.name === trimmedName)) return alert('预设名称已存在');
        
        if (!currentConfig.themePresets) currentConfig.themePresets = [];
        currentConfig.themePresets.push({ name: trimmedName, colors: getCurrentColors(false) });
        saveGlobalConfig(`Save theme preset: ${trimmedName}`);
        populatePresetDropdown();
        colorModal.presetSelector.value = currentConfig.themePresets.length - 1;
    });

    updatePresetBtn.addEventListener('click', () => {
        const index = colorModal.presetSelector.value;
        if (index === '') return alert('请先从下拉框中选择一个要更新的预设');
        
        currentConfig.themePresets[index].colors = getCurrentColors(false);
        const presetName = currentConfig.themePresets[index].name;
        saveGlobalConfig(`Update theme preset: ${presetName}`);
        showTopToast(`预设 "${presetName}" 已更新！`, 2000);
    });

    deletePresetBtn.addEventListener('click', () => {
        const index = colorModal.presetSelector.value;
        if (index === '') return alert('请先从下拉框中选择一个要删除的预设');
        
        const presetName = currentConfig.themePresets[index].name;
        if (!confirm(`确定要删除预设 "${presetName}" 吗？`)) return;
        
        currentConfig.themePresets.splice(index, 1);
        saveGlobalConfig(`Delete theme preset: ${presetName}`);
        populatePresetDropdown();
    });

    colorModal.presetSelector.addEventListener('change', () => {
        const index = colorModal.presetSelector.value;
        if (index === '') return;
        applyColors(currentConfig.themePresets[index].colors);
    });
    
    colorModal.randomToggle.addEventListener('change', () => { localStorage.setItem('randomPaletteEnabled', colorModal.randomToggle.checked); });

    
    function setupBgImageManager() {
        const setupPicker = (pickerId, uploadBtnId, clearBtnId, statusId, storageKey, storageNameKey) => {
            const picker = document.getElementById(pickerId);
            document.getElementById(uploadBtnId).addEventListener('click', () => picker.click());
            document.getElementById(clearBtnId).addEventListener('click', () => {
                localStorage.removeItem(storageKey);
                localStorage.removeItem(storageNameKey);
                applyAllBackgrounds();
                updateBgStatus();
            });
            picker.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    localStorage.setItem(storageKey, event.target.result);
                    localStorage.setItem(storageNameKey, file.name);
                    applyAllBackgrounds();
                    updateBgStatus();
                };
                reader.readAsDataURL(file);
            });
        };
        setupPicker('dayBgImagePicker', 'uploadDayBgBtn', 'clearDayBgBtn', 'dayBgStatus', 'dayBgImage', 'dayBgImageName');
        setupPicker('nightBgImagePicker', 'uploadNightBgBtn', 'clearNightBgBtn', 'nightBgStatus', 'nightBgImage', 'nightBgImageName');
        setupPicker('dayTitleCardBgImagePicker', 'uploadDayTitleCardBgBtn', 'clearDayTitleCardBgBtn', 'dayTitleCardBgStatus', 'dayTitleCardBgImage', 'dayTitleCardBgImageName');
        setupPicker('nightTitleCardBgImagePicker', 'uploadNightTitleCardBgBtn', 'clearNightTitleCardBgBtn', 'nightTitleCardBgStatus', 'nightTitleCardBgImage', 'nightTitleCardBgImageName');
    }
    
    function updateBgStatus() {
        document.getElementById('dayBgStatus').textContent = localStorage.getItem('dayBgImageName') || '未设置';
        document.getElementById('nightBgStatus').textContent = localStorage.getItem('nightBgImageName') || '未设置';
        document.getElementById('dayTitleCardBgStatus').textContent = localStorage.getItem('dayTitleCardBgImageName') || '未设置';
        document.getElementById('nightTitleCardBgStatus').textContent = localStorage.getItem('nightTitleCardBgImageName') || '未设置';
    }
    
    const settingsModalElements = { githubRepoInput: document.getElementById("githubRepoInput"), githubTokenInput: document.getElementById("githubTokenInput"), saveSettingsBtn: document.getElementById("saveSettingsBtn"), manualSyncBtn: document.getElementById('manualSyncBtn') };
    function setupModals(){document.querySelectorAll(".close-btn").forEach(e=>e.addEventListener("click",()=>{document.getElementById(e.dataset.modalId).classList.remove("show")})),document.querySelectorAll(".modal-overlay").forEach(e=>e.addEventListener("click",t=>e===t.target&&e.classList.remove("show"))),document.getElementById("helpBtn").addEventListener("click", () => {
    // 切换弹窗和菜单的显示
    document.getElementById("helpModal").classList.add("show");
    toggleFabMenu(false);
})

,document.getElementById("dataSyncBtn").addEventListener("click",()=>{GITHUB_CONFIG.owner&&GITHUB_CONFIG.repo&&(settingsModalElements.githubRepoInput.value=`${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}`),settingsModalElements.githubTokenInput.value=GITHUB_CONFIG.token||"",document.getElementById("settingsModal").classList.add("show"),toggleFabMenu(!1)}),document.getElementById("addNavBtn").addEventListener("click",()=>{openAddModal(); toggleFabMenu(false);}),document.getElementById("colorBtn").addEventListener("click", ()=>{document.getElementById("colorPaletteModal").classList.add("show"); updateColorUI(getCurrentColors()); updateBgStatus(); toggleFabMenu(false);}),document.getElementById("memoryBtn").addEventListener('click', () => { MemoryApp.open(); toggleFabMenu(false); }), document.getElementById('jelly-css-help-modal').querySelectorAll('.copy-btn').forEach(btn => { btn.addEventListener('click', async (e) => { const textBlock = e.target.parentElement; const textToCopy = textBlock.innerText.replace(e.target.innerText, '').trim(); try { await navigator.clipboard.writeText(textToCopy); const originalText = e.target.textContent; e.target.textContent = '已复制!'; setTimeout(() => { e.target.textContent = originalText; }, 1500); } catch (err) { alert('复制失败，请手动复制。'); } }); });}
    function saveGithubConfig(e){localStorage.setItem("githubConfig",JSON.stringify(e)),GITHUB_CONFIG=e}function loadGithubConfig(){const e=localStorage.getItem("githubConfig");e&&(GITHUB_CONFIG=JSON.parse(e))}function checkConfig(e=!0){return!GITHUB_CONFIG.owner||!GITHUB_CONFIG.repo||!GITHUB_CONFIG.token?(e&&alert("请先配置GitHub仓库信息。\n(打开菜单 -> 数据同步)"),!1):!0}
    
    function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
    function mergeDeep(target, ...sources) {
        if (!sources.length) return target;
        const source = sources.shift();
        if (isObject(target) && isObject(source)) {
            for (const key in source) {
                if (isObject(source[key])) {
                    if (!target[key]) Object.assign(target, { [key]: {} });
                    mergeDeep(target[key], source[key]);
                } else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        return mergeDeep(target, ...sources);
    }
    
    function migrateLegacyConfig(config) {
        if (!config) return { migratedConfig: config, wasMigrated: false };

        let wasModified = false;

        if (!Array.isArray(config.categories)) {
            config.categories = [];
            wasModified = true;
            console.log("Migration: 'categories' array not found, created a new one.");
        }

        let allCategory = config.categories.find(c => c.name === '全部');
        if (!allCategory) {
            allCategory = { name: '全部', buttons: [] };
            config.categories.unshift(allCategory);
            wasModified = true;
            console.log("Migration: Default '全部' category not found, created a new one.");
        }

        if (Array.isArray(config.buttons) && config.buttons.length > 0) {
            console.log(`Migration: Found ${config.buttons.length} orphaned buttons at the root level. Merging...`);
            const allCategoryButtonHrefs = new Set(allCategory.buttons.map(b => b.href));

            config.buttons.forEach(orphanButton => {
                if (!allCategoryButtonHrefs.has(orphanButton.href)) {
                    allCategory.buttons.push(orphanButton);
                    console.log(`  -> Merged button: "${orphanButton.text}"`);
                } else {
                    console.log(`  -> Skipped duplicate button: "${orphanButton.text}"`);
                }
            });
            
            wasModified = true;
        }

        if (config.hasOwnProperty('buttons')) {
            delete config.buttons;
            console.log("Migration: Cleaned up legacy root 'buttons' array.");
        }

        return { migratedConfig: config, wasMigrated: wasModified };
    }


    // [V2 修改] 增加几个新的辅助函数
    /**
     * 获取指定文件的提交历史
     * @param {string} path - 文件路径, e.g., 'config.json'
     * @returns {Promise<Array|null>} - 包含提交对象的数组或null
     */
    async function getHistoryForFile(path) {
        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/commits?path=${path}&per_page=5`;
        try {
            const response = await fetch(url, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` } });
            if (!response.ok) throw new Error(`API error: ${response.status}`);
            return await response.json();
        } catch (error) {
            console.error(`Failed to get history for ${path}:`, error);
            return null;
        }
    }

    /**
     * 获取文件在某次特定提交时的内容
     * @param {string} path - 文件路径
     * @param {string} commitSha - 提交的SHA值
     * @returns {Promise<string|null>} - 文件的UTF-8字符串内容或null
     */
    async function getContentAtCommit(path, commitSha) {
        const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}?ref=${commitSha}`;
        try {
            const response = await fetch(url, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` } });
            if (response.status === 404) return null; // 该版本不存在此文件
            if (!response.ok) throw new Error(`API error: ${response.status}`);
            const data = await response.json();
            return data.content ? b64_to_utf8(data.content) : null;
        } catch (error) {
            console.error(`Failed to get content for ${path} at commit ${commitSha}:`, error);
            return null;
        }
    }

    settingsModalElements.manualSyncBtn.addEventListener("click", async () => {
        if (!checkConfig(true)) return;
        
        const btn = settingsModalElements.manualSyncBtn;
        const originalText = btn.textContent;
        const recoveryModal = document.getElementById('dataRecoveryModal');
        const versionsListContainer = document.getElementById('recovery-versions-list');
        const confirmRecoveryBtn = document.getElementById('confirmRecoveryBtn');
        const cancelRecoveryBtn = document.getElementById('cancelRecoveryBtn');

        btn.disabled = true;
        btn.textContent = '正在检查云端数据...';

        try {
            const currentConfigData = await fetchConfigFromGithub();
            const isDataEmpty = !currentConfigData || !currentConfigData.categories || currentConfigData.categories.length === 0 || 
                                (currentConfigData.categories.length === 1 && currentConfigData.categories[0].buttons.length === 0);

            if (isDataEmpty) {
                btn.textContent = '检测到数据为空，正在查找历史版本...';
                
                const history = await getHistoryForFile('config.json');
                const historyToConsider = history ? history.slice(1, 5) : []; // 跳过最新的错误提交，取最多4个历史版本

                if (!historyToConsider || historyToConsider.length === 0) {
                    throw new Error('未找到足够的历史记录来进行恢复。');
                }

                btn.textContent = '正在解析历史数据...';

                const versions = [];
                await Promise.all(historyToConsider.map(async (commit) => {
                    const commitSha = commit.sha;
                    const [configContent, memoryContent] = await Promise.all([
                        getContentAtCommit('config.json', commitSha),
                        getContentAtCommit('memory/data.json', commitSha)
                    ]);
                    if (!configContent) return;

                    let summary = { buttons: 0, categories: 0, photos: 0, albums: 0, memos: 0, memoFolders: 0 };
                    try {
                        const parsedConfig = JSON.parse(configContent);
                        summary.categories = parsedConfig.categories?.length || 0;
                        summary.buttons = parsedConfig.categories?.reduce((acc, cat) => acc + (cat.buttons?.length || 0), 0) || 0;
                    } catch (e) { /* ignore */ }
                    if (memoryContent) {
                        try {
                            const parsedMemory = JSON.parse(memoryContent);
                            summary.albums = parsedMemory.album?.folders?.length || 0;
                            summary.photos = parsedMemory.album?.items?.reduce((acc, item) => acc + (item.type === 'photoset' ? item.photos.length : 1), 0) || 0;
                            summary.memoFolders = parsedMemory.memo?.folders?.length || 0;
                            summary.memos = parsedMemory.memo?.notes?.length || 0;
                        } catch (e) { /* ignore */ }
                    }
                    versions.push({sha:commitSha,message:commit.commit.message,date:new Date(commit.commit.author.date).toLocaleString('zh-CN'),summary,configContent,memoryContent});
                }));

                if (versions.length === 0) {
                    throw new Error('无法解析任何有效的历史版本。');
                }
                
                // 渲染版本列表
                versionsListContainer.innerHTML = '';
                versions.forEach((version, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'recovery-version-item';
                    itemEl.innerHTML = `
                        <input type="radio" name="recovery-version" id="version-${index}" value="${version.sha}">
                        <label for="version-${index}">
                            <div class="version-meta">${version.message} <span>(${version.date})</span></div>
                            <div class="version-summary">
                                <span><pre>按钮: ${version.summary.buttons}</pre></span>
                                <span><pre>分类: ${version.summary.categories}</pre></span>
                                <span><pre>备忘录: ${version.summary.memos}</pre></span>
                                <span><pre>相册: ${version.summary.albums}</pre></span>
                                <span><pre>照片: ${version.summary.photos}</pre></span>
                            </div>
                        </label>
                    `;
                    versionsListContainer.appendChild(itemEl);
                });
                
                document.getElementById('settingsModal').classList.remove('show');
                recoveryModal.classList.add('show');
                btn.textContent = '请选择恢复版本...';
                confirmRecoveryBtn.disabled = true;

                return new Promise(resolve => {
                    const handleSelectionChange = () => confirmRecoveryBtn.disabled = false;
                    versionsListContainer.addEventListener('change', handleSelectionChange);

                    const handleConfirm = async () => {
                        const selectedSha = versionsListContainer.querySelector('input[name="recovery-version"]:checked')?.value;
                        if (!selectedSha) return;

                        const selectedVersion = versions.find(v => v.sha === selectedSha);
                        if (!selectedVersion) return alert('无法找到所选版本的数据。');

                        recoveryModal.classList.remove('show');
                        btn.textContent = '正在恢复数据...';

                        const commitMsg = `Recover data from commit ${selectedVersion.sha.substring(0, 7)}`;
                        const configPromise = saveToGithub('config.json', utf8_to_b64(selectedVersion.configContent), commitMsg);
                        const memoryPromise = selectedVersion.memoryContent ? saveToGithub('memory/data.json', utf8_to_b64(selectedVersion.memoryContent), commitMsg) : Promise.resolve();
                        
                        await Promise.all([configPromise, memoryPromise]);
                        alert('数据恢复成功！页面将刷新以应用新数据。');
                        location.reload();
                        resolve();
                    };

                    const handleCancel = () => {
                        recoveryModal.classList.remove('show');
                        btn.disabled = false;
                        btn.textContent = originalText;
                        resolve();
                    };
                    
                    confirmRecoveryBtn.onclick = handleConfirm;
                    cancelRecoveryBtn.onclick = handleCancel;
                });

            } else {
                btn.textContent = '数据完整，执行常规同步...';
                let fetchedConfig = currentConfigData;
                const defaultConfig = getDefaultConfig();
                let needsSave = false;
                let wasMigrated = false;

                const migrationResult = migrateLegacyConfig(fetchedConfig);
                fetchedConfig = migrationResult.migratedConfig;
                wasMigrated = migrationResult.wasMigrated;
                if (wasMigrated) btn.textContent = '迁移旧版配置...';

                const mergedConfig = mergeDeep({}, defaultConfig, fetchedConfig);
                if (JSON.stringify(mergedConfig) !== JSON.stringify(fetchedConfig) || wasMigrated) {
                    currentConfig = mergedConfig;
                    needsSave = true;
                }
                
                if (needsSave) {
                    btn.textContent = '正在保存至云端...';
                    await saveGlobalConfig(wasMigrated ? 'Manual sync: Migrated legacy config' : 'Manual sync and repair');
                    btn.textContent = '同步完成，即将刷新';
                    alert("同步与修复完成！页面将刷新以应用最新配置。");
                    location.reload();
                } else {
                    btn.textContent = '配置已是最新';
                    alert("配置已是最新，无需修复。");
                }
            }
        } catch (e) {
            btn.textContent = '发生错误';
            alert(`操作失败: ${e.message}`);
        } finally {
            setTimeout(() => {
                if(btn.textContent.includes('...')) { // 只在未完成最终操作时恢复按钮
                   btn.disabled = false;
                   btn.textContent = originalText;
                }
            }, 3000);
        }
    });

// <-- 开始替换为 -->
    async function loadInitialData() {
        // --- 阶段 1: 瞬间从本地缓存加载并渲染UI ---
        const cachedConfigStr = localStorage.getItem('currentConfig');
        let isCacheAvailable = false;

        // 设置默认主题，避免闪烁
        const t = localStorage.getItem('theme');
        if (t === 'dark' || (!t && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.body.classList.add('dark-mode');
            fabMainBtn.textContent = '🌜';
        } else {
            fabMainBtn.textContent = '🌞';
        }

        if (cachedConfigStr) {
            try {
                // 使用缓存数据快速填充全局变量和UI
                currentConfig = JSON.parse(cachedConfigStr);
                isCacheAvailable = true;

                // 立即渲染基础UI
                setThemeStyle(currentConfig.settings.themeStyle || 'neumorphism');
                applyAllBackgrounds();
                document.getElementById('title').textContent = currentConfig.title;
                document.getElementById('subtitle').textContent = currentConfig.subtitle;
                document.querySelector('.editable-title').style.opacity = 1;
                document.querySelector('.editable-subtitle').style.opacity = 1;
                currentCategory = localStorage.getItem('lastSelectedCategory') || '全部';
                if (!currentConfig.categories.some(c => c.name === currentCategory)) {
                    currentCategory = '全部';
                }
                renderCategories();
                loadColorState();
            } catch (e) {
                console.error("解析本地缓存配置失败:", e);
                isCacheAvailable = false;
            }
        }

        if (!isCacheAvailable) {
            navContainer.innerHTML = '<p id="loading-status" style="text-align: center; color: #889;">首次加载，正在从云端初始化配置...</p>';
        }

        // --- 阶段 2: 异步在后台与云端同步 ---
        try {
            const fetchedConfig = await fetchConfigFromGithub();
            let needsSave = false;
            let wasMigrated = false;
            let finalConfig;

            if (fetchedConfig) {
                 if (!fetchedConfig.dataStructureVersion || fetchedConfig.dataStructureVersion < 2) {
                    const migrationCompleted = await migrateToModularData(fetchedConfig);
                    if (migrationCompleted) return; 
                }

                const migrationResult = migrateLegacyConfig(fetchedConfig);
                const migratedConfig = migrationResult.migratedConfig;
                wasMigrated = migrationResult.wasMigrated;
                
                const defaultConfig = getDefaultConfig();
                finalConfig = mergeDeep({}, defaultConfig, migratedConfig);

                if (JSON.stringify(finalConfig) !== JSON.stringify(fetchedConfig) || wasMigrated) {
                    needsSave = true;
                }
            } else {
                // 云端无配置，通常是新用户或数据被清空
                finalConfig = getDefaultConfig();
                finalConfig.dataStructureVersion = 2;
                configSha = null;
                needsSave = true;
            }

            // 比较云端与缓存，仅在必要时更新UI和缓存
            if (JSON.stringify(finalConfig) !== JSON.stringify(currentConfig)) {
                console.log("云端配置与当前显示不一致，正在更新...");
                currentConfig = finalConfig;
                localStorage.setItem('currentConfig', JSON.stringify(currentConfig)); // 更新本地快照
                
                // 重新渲染UI以反映最新数据
                if (!isCacheAvailable) {
                    // 如果之前没有缓存，这是第一次渲染
                     setThemeStyle(currentConfig.settings.themeStyle || 'neumorphism');
                    applyAllBackgrounds();
                    document.getElementById('title').textContent = currentConfig.title;
                    document.getElementById('subtitle').textContent = currentConfig.subtitle;
                    document.querySelector('.editable-title').style.opacity = 1;
                    document.querySelector('.editable-subtitle').style.opacity = 1;
                }
                renderCategories(); 
                loadColorState();
            }

            if (needsSave) {
                await saveGlobalConfig(wasMigrated ? 'Auto-migrate legacy config format' : 'Auto-create or repair config.json');
            }

            // --- 阶段 3: 静默预加载其他数据模块 ---
            // 这些请求在后台发起，不阻塞任何UI交互
            console.log("后台静默加载非核心数据模块...");
            DataManager.get('usageTime');
            DataManager.get('checkInData');
            DataManager.get('messageBoardData'); // 新增此行


        } catch (error) {
            console.error("后台同步失败:", error);
            if (!isCacheAvailable) {
                navContainer.innerHTML = `<p id="loading-status" style="text-align: center; color: #e53e3e;">加载配置失败，请检查网络和GitHub配置。</p>`;
            }
        }
    }
// <-- 结束替换为 -->

    function renderCategories() {
        const navContainerEl = document.getElementById('categoryNavContainer');
        if (!currentConfig.settings) {
            currentConfig.settings = { paginationEnabled: true };
        }
        const paginationEnabled = currentConfig.settings.paginationEnabled !== false; // Default to true
        navContainerEl.style.display = paginationEnabled ? 'block' : 'none';
        
        const categoryNav = document.getElementById('categoryNav');
        categoryNav.innerHTML = '';

        if(paginationEnabled) {
            currentConfig.categories.forEach(cat => {
                const pill = document.createElement('button');
                pill.className = 'category-pill';
                pill.textContent = cat.name;
                pill.dataset.category = cat.name;
                if (cat.name === currentCategory) {
                    pill.classList.add('active');
                }
                categoryNav.appendChild(pill);
            });
        }
        
        const categoryToRender = paginationEnabled ? currentCategory : '全部';
        renderButtonsForCategory(categoryToRender);
    }

    document.getElementById('categoryNav').addEventListener('click', (e) => {
        if (e.target.classList.contains('category-pill')) {
            const categoryName = e.target.dataset.category;
            currentCategory = categoryName;
            localStorage.setItem('lastSelectedCategory', categoryName);
            document.querySelectorAll('.category-pill').forEach(p => p.classList.remove('active'));
            e.target.classList.add('active');
            renderButtonsForCategory(categoryName);
        }
    });

    function renderButtonsForCategory(categoryName) {
        navContainer.innerHTML = '';
        let buttons = [];

        if (currentConfig.settings.paginationEnabled === false) {
             categoryName = '全部';
        }
        
        if (categoryName === '全部') {
            const allButtons = new Map();
            currentConfig.categories.forEach(cat => {
                cat.buttons.forEach(btn => {
                    if (!allButtons.has(btn.href)) {
                        allButtons.set(btn.href, btn);
                    }
                });
            });
            buttons = Array.from(allButtons.values());
        } else {
            const category = currentConfig.categories.find(c => c.name === categoryName);
            buttons = category ? category.buttons : [];
        }

        if (buttons.length === 0) {
            navContainer.innerHTML = '<p id="loading-status" style="text-align: center; color: #889;">该分类下暂无项目。</p>';
        } else {
            buttons.forEach(item => addNewButtonToDOM(item.text, item.href, false));
        }
    }

    async function deleteGithubFolder(folderPath) { if (!checkConfig(true)) return false; const contentsUrl = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${folderPath}`; try { const contentsResponse = await fetch(contentsUrl, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` }, cache: 'no-cache' }); if (contentsResponse.status === 404) { console.log(`Folder "${folderPath}" not found, nothing to delete.`); return true; } if (!contentsResponse.ok) throw new Error(`Could not list folder: ${contentsResponse.statusText}`); const files = await contentsResponse.json(); for (const file of files) { await deleteFromGithub(file.path, `Recursive delete: ${file.path}`, file.sha); } return true; } catch (error) { console.error(`Failed to delete folder "${folderPath}":`, error); return false; } }
    
    settingsModalElements.saveSettingsBtn.addEventListener("click",async()=>{const[e,t]=settingsModalElements.githubRepoInput.value.trim().split("/").map(e=>e.trim()),n=settingsModalElements.githubTokenInput.value.trim();if(e&&t&&n){saveGithubConfig({owner:e,repo:t,token:n,branch:"main"}),alert("配置已保存！正在刷新..."),document.getElementById("settingsModal").classList.remove("show"), location.reload() }else{alert("请填写完整信息。")}});

    const addNavModalElements={modal: document.getElementById('addNavModal'), title: document.getElementById('addNavModalTitle'), typeLinkRadio:document.getElementById("type-link"),typeUploadRadio:document.getElementById("type-upload"),linkSection:document.getElementById("link-section"),uploadSection:document.getElementById("upload-section"),categoryInput:document.getElementById("newButtonCategoryInput"),nameInput:document.getElementById("newButtonNameInput"),urlInput:document.getElementById("newButtonUrlInput"),openExternallyToggle:document.getElementById("openExternallyToggle"),filePickerBtn:document.getElementById("filePickerBtn"),projectHtmlPicker:document.getElementById("projectHtmlPicker"),fileStatus:document.getElementById("file-picker-status"),createBtn:document.getElementById("createNavBtn"),uploadStatus:document.getElementById("upload-status"),stayOpenToggle:document.getElementById("stayOpenToggle"), paginationToggle: document.getElementById('paginationToggle'), categoryMgmtSection: document.getElementById('category-management-section'), deleteCategoryBtn: document.getElementById('deleteCategoryBtn')};
    
    function updateAddNavModalUI() {
        const paginationEnabled = currentConfig.settings.paginationEnabled !== false;
        addNavModalElements.paginationToggle.checked = paginationEnabled;
        const selectedCategory = addNavModalElements.categoryInput.value.trim();
        const showDeleteBtn = selectedCategory && selectedCategory !== '全部' && currentConfig.categories.some(c => c.name === selectedCategory);
        addNavModalElements.categoryMgmtSection.style.display = showDeleteBtn ? 'block' : 'none';
    }
    
    addNavModalElements.paginationToggle.addEventListener('change', () => {
        currentConfig.settings.paginationEnabled = addNavModalElements.paginationToggle.checked;
        saveGlobalConfig('Toggle pagination setting');
        renderCategories();
    });

    addNavModalElements.categoryInput.addEventListener('input', updateAddNavModalUI);
    addNavModalElements.deleteCategoryBtn.addEventListener('click', async () => {
        const categoryNameToDelete = addNavModalElements.categoryInput.value.trim();
        if (!categoryNameToDelete || categoryNameToDelete === '全部') return;

        const choice = prompt(`您想如何处理 "${categoryNameToDelete}" 分类？\n\n1: 仅删除分类 (项目保留在"全部"中)\n2: 删除分类和其下所有项目 (危险！)\n\n请输入数字 1 或 2。`);

        if (choice === '1') {
            const categoryObj = currentConfig.categories.find(c => c.name === categoryNameToDelete);
            currentConfig.categories = currentConfig.categories.filter(c => c.name !== categoryNameToDelete);
            await saveGlobalConfig(`Delete category (keep items): ${categoryNameToDelete}`);
            alert(`分类 "${categoryNameToDelete}" 已删除，其项目现在仅在“全部”中显示。`);
        } else if (choice === '2') {
            if (confirm(`⚠️ 再次确认：\n您确定要永久删除分类 "${categoryNameToDelete}" 以及其中的所有项目吗？此操作不可逆！`)) {
                currentConfig.categories = currentConfig.categories.filter(c => c.name !== categoryNameToDelete);
                await saveGlobalConfig(`Delete category and items: ${categoryNameToDelete}`);
                alert(`分类 "${categoryNameToDelete}" 及其所有项目已被删除。`);
            }
        } else {
            alert("操作已取消。");
            return;
        }
        
        addNavModalElements.categoryInput.value = '';
        currentCategory = '全部';
        localStorage.setItem('lastSelectedCategory', '全部');
        renderCategories();
        populateCategoryDatalist();
        updateAddNavModalUI();
    });

    function addNewButtonToDOM(text, href) { 
        navContainer.querySelector("#loading-status")?.remove(); 
        const btn = document.createElement("button"); 
        btn.className = "nav-btn"; 
        btn.dataset.href = href; 
        const textNode = document.createTextNode(text); 
        btn.appendChild(textNode); 
        navContainer.appendChild(btn); 
        attachButtonListeners(btn); 
        if (isManagementMode) { 
            btn.title = '点击编辑，点击 × 删除';
            const icon = document.createElement('span'); 
            icon.className = 'delete-icon'; 
            icon.innerHTML = '&times;'; 
            icon.title = '删除此按钮'; 
            btn.appendChild(icon); 
        } 
    }
    function resetAddNavForm() { addNavModalElements.nameInput.value = ""; addNavModalElements.urlInput.value = ""; addNavModalElements.openExternallyToggle.checked = false; addNavModalElements.fileStatus.textContent = "未选择任何文件"; addNavModalElements.uploadStatus.textContent = ""; addNavModalElements.projectHtmlPicker.value = ""; isEditingButton = false; editingButtonData = null; }
    
    function populateCategoryDatalist() {
        const datalist = document.getElementById('category-datalist');
        datalist.innerHTML = '';
        currentConfig.categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.name;
            datalist.appendChild(option);
        });
    }

    document.querySelectorAll('input[name="nav-type"]').forEach(radio => {
        radio.addEventListener('change', function() {
            addNavModalElements.linkSection.style.display = this.value === 'link' ? 'block' : 'none';
            addNavModalElements.uploadSection.style.display = this.value === 'upload' ? 'flex' : 'none';
        });
    });

    addNavModalElements.filePickerBtn.addEventListener("click", () => addNavModalElements.projectHtmlPicker.click()); addNavModalElements.projectHtmlPicker.addEventListener("change", () => { if (addNavModalElements.projectHtmlPicker.files.length > 0) { const projectFile = addNavModalElements.projectHtmlPicker.files[0]; addNavModalElements.fileStatus.textContent = `已选择: ${projectFile.name}`; } else { addNavModalElements.fileStatus.textContent = '未选择任何文件'; }});
    addNavModalElements.createBtn.addEventListener("click",async()=>{
        const categoryName = addNavModalElements.categoryInput.value.trim() || '全部';
        const name = addNavModalElements.nameInput.value.trim();
        if(!name) return alert("请输入按钮名称。");
        const type=document.querySelector('input[name="nav-type"]:checked').value;
        addNavModalElements.createBtn.disabled = true;
        addNavModalElements.createBtn.textContent="处理中...";

        try {
            let newButtonData;
            if (type === "link") {
                const url = addNavModalElements.urlInput.value.trim();
                let finalUrl = url;
                 try {
                    new URL(url);
                } catch (_) {
                    if (!url.startsWith('https://') && !url.startsWith('http://') && url.includes('.')) {
                        finalUrl = 'https://' + url;
                    } else if (!url) {
                        alert("请输入网址链接。"); throw new Error("URL is required.");
                    }
                }
                 newButtonData = { text: name, href: finalUrl, openExternally: addNavModalElements.openExternallyToggle.checked };
            } else if (type === "upload") {
                 if (isEditingButton) {
                    alert("已上传的项目无法编辑，请删除后重新上传。"); return;
                 }
                 if (!checkConfig()) return;
                 const projectFile = addNavModalElements.projectHtmlPicker.files[0]; 
                 if(!projectFile) { alert("请选择一个HTML文件。"); throw new Error("File is required."); }
                 addNavModalElements.uploadStatus.textContent="正在上传文件...";
                 const path=`projects/${name.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g,"").replace(/\s+/g,"-")||`project-${Date.now()}`}/index.html`;
                 await uploadFileViaGitData({ file: projectFile, path, commitMessage: `Create project: ${name}`, onProgress: (p) => { addNavModalElements.uploadStatus.textContent = `上传中: ${Math.round(p)}%`; } });
                 addNavModalElements.uploadStatus.textContent="正在处理...";
                 newButtonData= { text:name, href: path, openExternally: false }; // **FIX**: Store the path, not the githack URL
                 alert("项目上传成功！");
            }
            
            let commitMsg;
            // [修改] 优化编辑逻辑
            if (isEditingButton && editingButtonData) {
                commitMsg = `Edit button: ${name}`;
                const oldCategoryName = editingButtonData.categoryName;
                const oldCategory = currentConfig.categories.find(c => c.name === oldCategoryName);
                const buttonIndex = oldCategory ? oldCategory.buttons.findIndex(b => b.href === editingButtonData.href) : -1;

                if (oldCategory && buttonIndex > -1) {
                    if (oldCategoryName === categoryName) {
                        // 类别未变，在原位更新
                        oldCategory.buttons[buttonIndex] = newButtonData;
                    } else {
                        // 类别改变，从旧类别移除，添加到新类别
                        oldCategory.buttons.splice(buttonIndex, 1);
                        let newCategoryObj = currentConfig.categories.find(c => c.name === categoryName);
                        if (!newCategoryObj) {
                            newCategoryObj = { name: categoryName, buttons: [] };
                            currentConfig.categories.push(newCategoryObj);
                        }
                        newCategoryObj.buttons.push(newButtonData);
                    }
                }
            } else {
                // 新增按钮逻辑保持不变
                commitMsg = `Add button: ${name} to ${categoryName}`;
                let categoryObj = currentConfig.categories.find(c => c.name === categoryName);
                if (!categoryObj) {
                    categoryObj = { name: categoryName, buttons: [] };
                    currentConfig.categories.push(categoryObj);
                }
                categoryObj.buttons.push(newButtonData);
            }

            await saveGlobalConfig(commitMsg); 
            
            resetAddNavForm(); 
            populateCategoryDatalist();
            renderCategories();
            
            if(!addNavModalElements.stayOpenToggle.checked || isEditingButton) { 
                addNavModalElements.modal.classList.remove("show");
            } 
        } catch(o) {
            addNavModalElements.uploadStatus.textContent="操作失败!";
            if(o.message !== "URL is required." && o.message !== "File is required.") {
                 alert(await handleApiError("创建/编辑项目", o));
            }
        } finally {
            addNavModalElements.createBtn.disabled = false;
            addNavModalElements.createBtn.textContent = isEditingButton ? "保存更改" : "加入新项目";
        }
    });
    function showDeleteOptionsDialog(projectName, hasCloudFiles, callback) {
        const modal = document.getElementById('deleteOptionsModal');
        const titleEl = document.getElementById('deleteOptionsTitle');
        const messageEl = document.getElementById('deleteOptionsMessage');
        const transferBtn = document.getElementById('transferOptionBtn');
        const deleteBtn = document.getElementById('deleteOptionBtn');
        const cancelBtn = document.getElementById('cancelOptionBtn');

        // 填充内容
        titleEl.textContent = `删除项目 "${projectName}"`;
        messageEl.innerHTML = `您想如何处理这个项目？${hasCloudFiles ? '<br><strong style="color: #e53e3e;">警告：此项目关联的云盘中有文件。</strong>' : ''}`;

        // 根据是否有文件显示/隐藏“转移”按钮
        transferBtn.style.display = hasCloudFiles ? 'block' : 'none';

        // 定义一次性事件处理器
        const handler = (choice) => {
            modal.classList.remove('show');
            // 移除监听器以防止内存泄漏
            transferBtn.removeEventListener('click', transferHandler);
            deleteBtn.removeEventListener('click', deleteHandler);
            cancelBtn.removeEventListener('click', cancelHandler);
            // 调用回调函数并传入用户的选择
            callback(choice);
        };

        const transferHandler = () => handler('transfer');
        const deleteHandler = () => handler('delete');
        const cancelHandler = () => handler('cancel');

        // 绑定事件
        transferBtn.addEventListener('click', transferHandler);
        deleteBtn.addEventListener('click', deleteHandler);
        cancelBtn.addEventListener('click', cancelHandler);

        // 显示模态框
        modal.classList.add('show');
    }


    function openAddModal() {
        isEditingButton = false;
        editingButtonData = null;
        const els = addNavModalElements;
        els.modal.classList.add('show');
        els.title.textContent = '管理项目';
        els.createBtn.textContent = '加入新项目';
        
        els.uploadSection.style.pointerEvents = 'auto';
        els.uploadSection.style.opacity = '1';
        document.querySelector('label[for="type-upload"]').style.display = 'block';

        resetAddNavForm();
        populateCategoryDatalist();
        updateAddNavModalUI();
    }

function openEditModal(buttonData) {
    isEditingButton = true;
    editingButtonData = buttonData;
    const els = addNavModalElements;
    
    els.modal.classList.add('show');
    els.title.textContent = '编辑项目';
    els.createBtn.textContent = '保存更改';
    
    els.categoryInput.value = buttonData.categoryName;
    els.nameInput.value = buttonData.text;
    
    const isUploadedProject = buttonData.href.startsWith('projects/');
    
    // --- [核心修改开始] ---
    // 移除可能存在的旧“转移”按钮，防止重复添加
    const oldTransferBtn = els.modal.querySelector('#transferProjectBtn');
    if (oldTransferBtn) oldTransferBtn.remove();
    
    if (isUploadedProject) {
        els.urlInput.value = "已上传的项目，路径不可编辑。";
        els.typeUploadRadio.checked = true;
        els.linkSection.style.display = 'none';
        els.uploadSection.style.display = 'flex';
        els.uploadSection.style.pointerEvents = 'none';
        els.uploadSection.style.opacity = '0.5';
        document.querySelector('label[for="type-upload"]').style.display = 'none';
        
        // 动态创建并插入“转移项目文件”按钮
        const transferBtn = document.createElement('button');
        transferBtn.id = 'transferProjectBtn';
        transferBtn.className = 'modal-button';
        transferBtn.textContent = '转移项目文件…';
        transferBtn.style.marginTop = '10px';
        transferBtn.style.color = '#5a6778'; // 使用一个比较柔和的颜色
        
        // 为按钮绑定新的转移功能函数 (我们将在下一步创建这个函数)
        transferBtn.onclick = () => openTransferProjectModal(editingButtonData);
        
        // 将按钮插入到“加入新项目/保存更改”按钮的上方
        els.createBtn.parentNode.insertBefore(transferBtn, els.createBtn);
        
    } else {
        els.urlInput.value = buttonData.href;
        els.typeLinkRadio.checked = true;
        els.linkSection.style.display = 'block';
        els.uploadSection.style.display = 'none';
    }
    // --- [核心修改结束] ---
    
    els.openExternallyToggle.checked = buttonData.openExternally || false;
    
    populateCategoryDatalist();
    updateAddNavModalUI();
}

    
    function openIframeModal(url) { 
        if (!localStorage.getItem('swipeHintShown')) { swipeHint.classList.add('show'); setTimeout(() => { swipeHint.classList.remove('show'); localStorage.setItem('swipeHintShown', 'true'); }, 4000); } 
        
        // [新增] 开始使用时长计时
        startUsageTracking(url);

        iframeEl.src = url; 
        iframeModal.dataset.originalUrl = url; // [新增] 记录原始URL
        iframeModal.classList.add('active'); 
    }

// --- [核心新增] 文件转移功能的所有相关函数 ---

let transferProjectData = null; // 用于存储待转移的项目数据

/**
 * 检查指定项目的云盘文件夹是否含有文件
 * @param {string} projectName - 项目的显示名称
 * @returns {Promise<boolean>} - 如果文件夹存在且非空，则返回 true
 */
async function checkProjectFolderForFiles(projectName) {
    if (!projectName) return false;
    // 根据项目名称生成云盘文件夹路径
    const folderName = projectName.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-");
    const projectPath = `jellyfish_drive/${folderName}`;
    
    // 使用 GitHub API 获取文件夹内容
    const { data: files, response } = await fetchFromGithub(projectPath);

    // 如果文件夹不存在 (404)，或者API调用出错，都认为没有文件
    if (response && response.status === 404) {
        return false;
    }
    
    // 如果文件夹存在，并且返回的文件列表是数组且长度大于0，则认为有文件
    return Array.isArray(files) && files.length > 0;
}

/**
 * [V2] 打开文件转移模态框并初始化
 * @param {object} buttonData - 当前正在编辑的项目数据
 */
function openTransferProjectModal(buttonData) {
    transferProjectData = buttonData;
    const modal = document.getElementById('transferProjectModal');
    const currentNameInput = document.getElementById('currentProjectName');
    const newNameInput = document.getElementById('transferNewProjectName');
    const categoryInput = document.getElementById('transferTargetCategory');
    const transferStatus = document.getElementById('transfer-status');
    const confirmBtn = document.getElementById('confirmTransferBtn');
    
    // [新增] 获取新UI元素
    const existingProjectSelector = document.getElementById('existingProjectSelector');
    const createNewProjectSection = document.getElementById('createNewProjectForTransfer');

    // 初始化UI
    currentNameInput.value = buttonData.text;
    newNameInput.value = '';
    categoryInput.value = buttonData.categoryName;
    transferStatus.textContent = '';
    confirmBtn.disabled = false;
    confirmBtn.textContent = '确认转移';

    // 填充分类datalist
    const datalist = document.getElementById('category-datalist-transfer');
    datalist.innerHTML = '';
    currentConfig.categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.name;
        datalist.appendChild(option);
    });
    
    // [新增] 填充现有项目下拉菜单
    existingProjectSelector.innerHTML = '<option value="">不选择现有项目</option>'; // 重置并添加默认选项
    currentConfig.categories.forEach(cat => {
        cat.buttons.forEach(btn => {
            if (btn.href !== buttonData.href) { // 排除自身
                 const option = document.createElement('option');
                 option.value = btn.text; // 使用项目名称作为值
                 option.textContent = `${btn.text} (${cat.name})`;
                 existingProjectSelector.appendChild(option);
            }
        });
    });

    // [新增] 联动逻辑：当选择现有项目时，禁用“创建新项目”部分
    existingProjectSelector.onchange = () => {
        const shouldDisable = !!existingProjectSelector.value;
        createNewProjectSection.style.opacity = shouldDisable ? '0.5' : '1';
        createNewProjectSection.style.pointerEvents = shouldDisable ? 'none' : 'auto';
        if (shouldDisable) {
            newNameInput.value = '';
        }
    };
    // 初始状态
    createNewProjectSection.style.opacity = '1';
    createNewProjectSection.style.pointerEvents = 'auto';

    modal.classList.add('show');
}


/**
 * [V2] 执行文件转移的核心逻辑
 */
async function executeProjectTransfer() {
    if (!transferProjectData) return;

    const existingProjectName = document.getElementById('existingProjectSelector').value;
    const newName = document.getElementById('transferNewProjectName').value.trim();
    const newCategoryName = document.getElementById('transferTargetCategory').value.trim() || '全部';
    const transferStatus = document.getElementById('transfer-status');
    const confirmBtn = document.getElementById('confirmTransferBtn');

    // [修改] 验证逻辑：必须选择一个现有项目 或 输入一个新项目名
    if (!existingProjectName && !newName) {
        alert('请选择一个现有项目或输入一个新项目名称！');
        return;
    }
    if (existingProjectName && newName) {
        alert('不能同时选择现有项目和创建新项目！');
        return;
    }

    const targetProjectName = existingProjectName || newName;
    
    confirmBtn.disabled = true;
    confirmBtn.textContent = '转移中，请稍候...';

    try {
        // ... (从 "try" 到 "await deleteGithubFolder(oldFolderPath);" 的所有代码保持不变) ...

        // 1. 生成旧文件夹路径
        const oldProjectName = transferProjectData.text;
        const oldFolderNameBasedOnName = oldProjectName.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-");
        const oldFolderPath = `jellyfish_drive/${oldFolderNameBasedOnName}`;

        // 2. 获取旧文件夹内容
        transferStatus.textContent = '正在读取原项目文件...';
        const { data: oldFiles, response } = await fetchFromGithub(oldFolderPath);
        if (response.status === 404 || !Array.isArray(oldFiles) || oldFiles.length === 0) {
            throw new Error('原项目云盘文件夹为空或不存在，无需转移。');
        }

        // 3. 生成新文件夹路径
        const newFolderNameBasedOnName = targetProjectName.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-");
        const newFolderPath = `jellyfish_drive/${newFolderNameBasedOnName}`;
        
        // 4. 检查新文件夹是否已存在且非空，防止覆盖
        transferStatus.textContent = '正在检查目标位置...';
        const { data: existingNewFiles } = await fetchFromGithub(newFolderPath);
        if (Array.isArray(existingNewFiles) && existingNewFiles.length > 0) {
             // 如果是转入现有项目，且该项目已有文件，则询问是否合并
            if (existingProjectName) {
                if (!confirm(`目标项目 "${targetProjectName}" 已存在文件。确定要将文件合并过去吗？（同名文件将被覆盖！）`)) {
                    throw new Error('用户取消了合并操作。');
                }
            } else {
                throw new Error(`新项目名称 "${targetProjectName}" 已被占用，请更换。`);
            }
        }

        // 5. 逐个文件进行“读取-创建”操作，实现移动
        for (let i = 0; i < oldFiles.length; i++) {
            const file = oldFiles[i];
            transferStatus.textContent = `正在迁移文件 (${i + 1}/${oldFiles.length}): ${file.name}`;
            
            const fileResponse = await fetch(file.download_url);
            if (!fileResponse.ok) throw new Error(`无法读取文件 ${file.name} 的内容。`);
            
            const fileBlob = await fileResponse.blob();
            const contentB64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(fileBlob);
            });

            const newFilePath = `${newFolderPath}/${file.name}`;
            await saveToGithub(newFilePath, contentB64, `Transfer: Create ${file.name}`);
        }

        // 6. 删除旧文件夹
        transferStatus.textContent = '正在清理旧文件...';
        await deleteGithubFolder(oldFolderPath);

        // 7. [修改] 更新 config.json 的逻辑
        transferStatus.textContent = '正在更新配置...';

        // 从旧分类中移除原项目按钮
        const oldCategory = currentConfig.categories.find(c => c.name === transferProjectData.categoryName);
        if (oldCategory) {
            oldCategory.buttons = oldCategory.buttons.filter(b => b.href !== transferProjectData.href);
        }

        // 如果是创建新项目，则需要添加到配置中
        if (newName) {
            const newButtonData = {
                text: newName,
                href: transferProjectData.href,
                openExternally: transferProjectData.openExternally
            };
            let newCategory = currentConfig.categories.find(c => c.name === newCategoryName);
            if (!newCategory) {
                newCategory = { name: newCategoryName, buttons: [] };
                currentConfig.categories.push(newCategory);
            }
            newCategory.buttons.push(newButtonData);
        }
        
        // 保存最终配置
        await saveGlobalConfig(`Move project files from "${oldProjectName}" to "${targetProjectName}"`);

        transferStatus.textContent = '转移成功！';
        showTopToast('项目文件转移成功！', 3000);

        // 8. 关闭弹窗并刷新界面
        setTimeout(() => {
            document.getElementById('transferProjectModal').classList.remove('show');
            document.getElementById('addNavModal')?.classList.remove('show');
            renderCategories();
            renderButtonsForCategory(currentCategory); // 刷新当前分类视图
        }, 1500);

    } catch (err) {
        const userMessage = await handleApiError("文件转移操作", err);
        transferStatus.textContent = `转移失败: ${userMessage}`;
        alert(`转移失败: ${userMessage}`);
        confirmBtn.disabled = false;
        confirmBtn.textContent = '确认转移';
    }
}


// 为新模态框的确认按钮绑定事件
document.addEventListener('DOMContentLoaded', () => {
    const confirmBtn = document.getElementById('confirmTransferBtn');
    if (confirmBtn) {
        confirmBtn.addEventListener('click', executeProjectTransfer);
    }
});

// --- [核心新增结束] ---


     function closeIframeModal() { 
        // [新增] 停止计时
        stopUsageTracking();

        FloatingProjectWindowManager.closeAll();
        hideReturnConfirmation(); 
        iframeModal.classList.remove('active'); 
    }

    function showReturnConfirmation() { returnConfirmationToast.classList.add('show'); }
    function hideReturnConfirmation() { returnConfirmationToast.classList.remove('show'); }
    document.getElementById('confirmReturnBtn').addEventListener('click', () => {
        // [新增] 触发退出提醒
        BackupReminderManager.triggerOnExitReminder();
        closeIframeModal();
    });
    document.getElementById('cancelReturnBtn').addEventListener('click', hideReturnConfirmation);
    
    const gestureCaptureZone = document.getElementById('gestureCaptureZone');
    let startX = 0, startY = 0, currentX = 0, isIframeDragging = false, isSwipeIntent = false;
    gestureCaptureZone.addEventListener('touchstart', (e) => {
        if(currentConfig.settings?.jellyBall?.swipeBack === false) return;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        isIframeDragging = true;
        isSwipeIntent = false;
        iframeModalContent.classList.add('dragging');
    }, { passive: true });
    window.addEventListener('touchmove', (e) => {
        if (!isIframeDragging || returnConfirmationToast.classList.contains('show')) return;
        currentX = e.touches[0].clientX;
        const diffX = currentX - startX;
        if (diffX > 0) {
            if (!isSwipeIntent) {
                const diffY = Math.abs(e.touches[0].clientY - startY);
                if (diffX > 10 && diffX > diffY) {
                    isSwipeIntent = true;
                } else if (diffY > 10) {
                    isIframeDragging = false;
                    return;
                }
            }
            if (isSwipeIntent) {
                e.preventDefault();
                iframeModalContent.style.transform = `translateX(${diffX}px)`;
            }
        }
    }, { passive: false });
    window.addEventListener('touchend', (e) => {
        if (!isIframeDragging) return;
        isIframeDragging = false;
        iframeModalContent.classList.remove('dragging');
        iframeModalContent.style.transform = '';
        const diffX = currentX - startX;
        const closeThreshold = window.innerWidth / 3.5;
        if (isSwipeIntent && diffX > closeThreshold && !returnConfirmationToast.classList.contains('show')) {
            showReturnConfirmation();
        }
        startX = 0; currentX = 0; startY = 0; isSwipeIntent = false;
    });

    async function nukeAllData() {
        if (!checkConfig(true)) return;
        const btn = document.getElementById('nukeDataBtn');
        const originalText = btn.textContent;

        const confirmation = confirm("⚠️ 极度危险操作！\n\n这将永久删除您的所有数据，包括：\n\n- 所有本地设置 (主题、GitHub配置等)\n- GitHub仓库中的 `config.json` (所有按钮和设置)\n- GitHub仓库中的所有上传的项目和文件\n\n此操作不可逆，将使应用恢复到空白的初始状态。确定要继续吗？");
        if (!confirmation) return;
        
        btn.disabled = true;
        
        try {
            btn.textContent = '获取仓库内容...';
            updateSyncStatus('syncing', '正在执行重置...');
            
            const rootContentsUrl = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/`;
            const rootContentsRes = await fetch(rootContentsUrl, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` } });
            
            if (!rootContentsRes.ok) {
                let errorMsg = '无法获取仓库内容。';
                try {
                    const errorData = await rootContentsRes.json();
                    errorMsg = errorData.message || errorMsg;
                } catch (e) { /* ignore json parsing error */ }
                throw new Error(errorMsg);
            }

            const items = await rootContentsRes.json();
            const foldersToNuke = ['projects', 'memory', 'data_sync'];
            
            let i = 0;
            for (const item of items) {
                i++;
                btn.textContent = `删除中 (${i}/${items.length})...`;
                if (item.path === 'config.json') {
                    await deleteFromGithub(item.path, 'NUKE: Deleting config file', item.sha, true);
                } else if (item.type === 'dir' && foldersToNuke.includes(item.name)) {
                    await deleteGithubFolder(item.path);
                }
            }
            btn.textContent = '正在清空本地...';
            localStorage.clear();
            
            alert('所有云端及本地数据已清空。页面将刷新。');
            location.reload();

        } catch (error) {
            const userMessage = await handleApiError("重置操作", error);
            updateSyncStatus('error', userMessage);
            alert(`重置失败: ${userMessage}`);
            btn.textContent = '重置失败';
        } finally {
            setTimeout(() => {
                btn.disabled = false;
                btn.textContent = originalText;
            }, 3000);
        }
    }
// [新增] 用于处理选择性数据清理的函数
async function selectiveClearData() {
    const modal = document.getElementById('selectiveClearModal');
    const checkboxes = modal.querySelectorAll('#clear-options-container input[type="checkbox"]:checked');
    if (checkboxes.length === 0) {
        alert('请至少选择一个要清理的项目。');
        return;
    }

    const targets = Array.from(checkboxes).map(cb => cb.dataset.clearTarget);
    const targetNames = {
        config: '主配置和按钮',
        memory: '记忆数据',
        photos: '相册照片文件',
        music: '漫游音乐文件',
        projects: '上传的项目文件',
        drive: '文件夹(云盘)文件',
        local: '浏览器本地缓存'
    };
    const selectedNames = targets.map(t => targetNames[t]).join('、');

    if (!confirm(`⚠️ 再次确认！\n\n您确定要永久删除以下数据吗？\n\n【${selectedNames}】\n\n此操作不可逆！`)) {
        return;
    }

    const btn = document.getElementById('confirmSelectiveClearBtn');
    const originalText = btn.textContent;
    btn.disabled = true;
    btn.textContent = '正在删除...';
    showTopToast('正在执行清理操作...', 60000); // 长期提示

    try {
        if (targets.includes('photos')) {
            btn.textContent = '删除相册照片...';
            await deleteGithubFolder('memory/photos');
        }
        if (targets.includes('music')) {
            btn.textContent = '删除音乐文件...';
            await deleteGithubFolder('memory/music');
            const musicData = await fetchFromGithub('memory/music_data.json');
            if (musicData.data) await deleteFromGithub('memory/music_data.json', 'NUKE: Deleting music data', musicData.data.sha, true);
        }
        if (targets.includes('memory')) {
            btn.textContent = '删除记忆数据...';
            const memoryData = await fetchFromGithub('memory/data.json');
            if (memoryData.data) await deleteFromGithub('memory/data.json', 'NUKE: Deleting memory data', memoryData.data.sha, true);
        }
        if (targets.includes('projects')) {
            btn.textContent = '删除项目文件...';
            await deleteGithubFolder('projects');
        }
        if (targets.includes('drive')) {
            btn.textContent = '删除云盘文件...';
            await deleteGithubFolder('jellyfish_drive');
        }
        if (targets.includes('config')) {
            btn.textContent = '删除主配置...';
            const configData = await fetchFromGithub('config.json');
            if (configData.data) await deleteFromGithub('config.json', 'NUKE: Deleting config file', configData.data.sha, true);
        }
        if (targets.includes('local')) {
            btn.textContent = '清空本地缓存...';
            localStorage.clear();
        }

        alert('选定的数据已清理。页面将刷新。');
        location.reload();

    } catch (error) {
        const userMessage = await handleApiError("数据清理操作", error);
        alert(`清理失败: ${userMessage}`);
        btn.disabled = false;
        btn.textContent = originalText;
    }
}

// [新增 V2] 为 "高级数据清理" 弹窗添加完整的交互逻辑
document.addEventListener('DOMContentLoaded', () => {
    const openClearModalBtn = document.getElementById('openClearDataModalBtn');
    const confirmClearBtn = document.getElementById('confirmSelectiveClearBtn');
    const selectAllCheckbox = document.getElementById('selectAllClearOptions');
    const optionsContainer = document.getElementById('clear-options-container');

    // 打开高级清理弹窗
    openClearModalBtn?.addEventListener('click', () => {
        document.getElementById('settingsModal').classList.remove('show');
        document.getElementById('selectiveClearModal').classList.add('show');
    });

    // 确认执行清理
    confirmClearBtn?.addEventListener('click', selectiveClearData);

    // "一键全选" 的核心逻辑
    if (selectAllCheckbox && optionsContainer) {
        // 监听 "一键全选" 复选框的变化
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const individualCheckboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
            individualCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });
        });

        // 监听下方所有独立复选框的变化，以联动 "一键全选" 的状态
        optionsContainer.addEventListener('change', (e) => {
            if (e.target.matches('input[type="checkbox"]')) {
                const individualCheckboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
                const total = individualCheckboxes.length;
                const checkedCount = optionsContainer.querySelectorAll('input[type="checkbox"]:checked').length;
                
                // 如果所有都被选中，则"一键全选"也勾选上；否则取消勾选
                selectAllCheckbox.checked = total === checkedCount;
            }
        });
    }
});


// <-- 开始替换为 -->
    /* =============================================================== */
    /* ============= [新增] 百度网盘集成模块 V1.0 ================ */
    /* =============================================================== */
    const BaiduNetdisk = (() => {
        // [核心] 你的应用API Key，请务必保密
        const API_CONFIG = {
            APP_ID: '120616269',
            APP_KEY: 'VHrQX0UtfM1Aaqzwzx3Wo0CRLJjMqieL',
            SECRET_KEY: 'zu8jPA3JvCI7QNgEW9m0RfLTI2VwtD2u',
            SIGN_KEY: 'QfHII+cYCKx@0JlKwtrJBFgy$*Dmy2+p',
            // 重要：这个重定向URL必须与你在百度开发者平台设置的“安全设置”中的回调地址完全一致！
            // 对于纯前端应用，通常设置为一个你自己的、可访问的空白页面。
            // 这里我们用一个通用值，你需要去百度开发者官网后台将它添加进去。
            REDIRECT_URI: 'https://yeexein.github.io/Jellyfish/',
            // 应用在网盘中的文件夹名
            APP_FOLDER_NAME: 'JellyfishDrive'
        };

        // [核心修改] 在模块顶层声明一个空对象，用于存储UI元素
        let UI = {};

        // 从localStorage获取所有账户信息
        function getAccounts() {
            try {
                return JSON.parse(localStorage.getItem('baidu_netdisk_accounts') || '[]');
            } catch (e) {
                return [];
            }
        }

        // 保存账户信息到localStorage
        function saveAccounts(accounts) {
            localStorage.setItem('baidu_netdisk_accounts', JSON.stringify(accounts));
        }

        // 渲染账户列表
        function renderAccountList() {
            const accounts = getAccounts();
            UI.accountList.innerHTML = '';

            if (accounts.length === 0) {
                UI.accountList.innerHTML = `<p style="text-align: center; color: #889; padding: 20px 0;">暂未关联任何账户</p>`;
                return;
            }

            accounts.forEach((account, index) => {
                const li = document.createElement('li');
                li.className = 'baidu-account-item';
                li.innerHTML = `
                    <div class="baidu-account-info">
                        <img src="${account.avatar_url || 'icons/icon-192x192.png'}" alt="avatar" class="baidu-account-avatar">
                        <span class="baidu-account-name">${account.baidu_name || '未知用户'}</span>
                    </div>
                    <button class="modal-button delete" data-index="${index}" style="padding: 8px 12px; font-size: 14px;">解除绑定</button>
                `;
                li.querySelector('.delete').addEventListener('click', (e) => {
                    const indexToRemove = parseInt(e.target.dataset.index, 10);
                    if (confirm(`确定要解除与用户 "${accounts[indexToRemove].baidu_name}" 的绑定吗？`)) {
                        removeAccount(indexToRemove);
                    }
                });
                UI.accountList.appendChild(li);
            });
        }
        
        // 移除指定账户
        function removeAccount(index) {
            let accounts = getAccounts();
            accounts.splice(index, 1);
            saveAccounts(accounts);
            renderAccountList();
            showTopToast("账户已解除绑定。", 2000);
        }

        // 打开设置弹窗
        function openSettingsModal() {
            renderAccountList();
            UI.statusText.textContent = '';
            UI.modal.classList.add('show');
        }

        // 初始化函数，绑定事件
        function init() {
            // [核心修改] 将UI元素的获取操作移到init函数内部
            // 此时页面已加载完毕，可以安全地获取元素
            UI = {
                modal: document.getElementById('baiduNetdiskSettingsModal'),
                accountList: document.getElementById('baidu-account-list'),
                addBtn: document.getElementById('add-baidu-account-btn'),
                statusText: document.getElementById('baidu-auth-status'),
            };

            UI.addBtn.addEventListener('click', () => {
                // 构建百度OAuth2.0授权URL
                const authUrl = `https://openapi.baidu.com/oauth/2.0/authorize?response_type=code&client_id=${API_CONFIG.APP_KEY}&redirect_uri=${API_CONFIG.REDIRECT_URI}&scope=basic,netdisk&display=popup`;
                
                // 打开一个新窗口进行授权
                const authWindow = window.open(authUrl, 'baidu_auth', 'width=600,height=500,scrollbars=yes');
                 
                 // 轮询检查授权窗口是否已关闭或重定向
                const timer = setInterval(() => {
                    // [修复] 增加对 authWindow 是否存在的检查
                    if (!authWindow || authWindow.closed) {
                        clearInterval(timer);
                         if (UI.statusText.textContent === '') { // 仅在没有其他状态时显示
                            UI.statusText.textContent = '授权窗口已关闭。';
                         }
                        return;
                    }
                    try {
                        // 检查窗口的URL是否是我们期望的回调地址
                        if (authWindow.location.href.startsWith(API_CONFIG.REDIRECT_URI)) {
                            const url = new URL(authWindow.location.href);
                            const code = url.searchParams.get('code');
                            
                            if (code) {
                                UI.statusText.textContent = '授权成功，正在获取凭证...';
                                exchangeCodeForToken(code); // 获取到code后，用它交换token
                            } else {
                                UI.statusText.textContent = '授权失败，未获取到授权码。';
                                console.error("OAuth Error:", url.searchParams.get('error_description'));
                            }

                            authWindow.close(); // 关闭授权窗口
                            clearInterval(timer); // 停止轮询
                        }
                    } catch (e) {
                        // 跨域错误是正常的，因为在跳转到百度页面时我们无法访问其location。
                        // 我们只需要等到它跳回到我们的redirect_uri时即可。
                    }
                }, 500);
            });
        }
        
        // 用授权码交换Access Token
        async function exchangeCodeForToken(code) {
            const tokenUrl = `https://openapi.baidu.com/oauth/2.0/token?grant_type=authorization_code&code=${code}&client_id=${API_CONFIG.APP_KEY}&client_secret=${API_CONFIG.SECRET_KEY}&redirect_uri=${API_CONFIG.REDIRECT_URI}`;
            
            try {
                // 注意：由于浏览器CORS策略，此请求很可能会失败。
                // 百度OAuth的token获取步骤通常需要在服务器端完成，以保护Secret Key。
                // 在纯前端环境中，这是一个主要的障碍。
                // 我们使用你创建的Cloudflare Worker作为CORS代理来绕过这个问题。
                const proxiedTokenUrl = `https://myjellyfishcors.iixye827.workers.dev/${tokenUrl.replace('://', ':/')}`;
                const response = await fetch(proxiedTokenUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
                });


                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error_description || '获取Token失败');
                }

                const data = await response.json();
                
                UI.statusText.textContent = '凭证获取成功，正在获取用户信息...';

                // 获取用户信息
                const userInfo = await getUserInfo(data.access_token);

                if (!userInfo) {
                    throw new Error('获取用户信息失败');
                }

                const accounts = getAccounts();
                // 检查用户是否已绑定
                const existingAccountIndex = accounts.findIndex(acc => acc.uk === userInfo.uk);
                
                const newAccountData = {
                    ...data,
                    ...userInfo,
                    added_at: Date.now()
                };

                if (existingAccountIndex > -1) {
                    // 更新已存在账户的token
                    accounts[existingAccountIndex] = newAccountData;
                    showTopToast(`账户 "${userInfo.baidu_name}" 的授权已更新！`, 3000);
                } else {
                    // 添加新账户
                    accounts.push(newAccountData);
                    showTopToast(`成功关联账户: ${userInfo.baidu_name}`, 3000);
                }
                
                saveAccounts(accounts);
                renderAccountList();
                UI.statusText.textContent = '';

            } catch (error) {
                console.error("Error exchanging code for token or fetching user info:", error);
                UI.statusText.textContent = `操作失败：${error.message}。请检查网络或CORS代理。`;
                alert(`操作失败: ${error.message}\n\n这可能是由于CORS跨域问题。请确保你的CORS代理服务(如cors-anywhere)是开启状态，或考虑在后端完成此步骤。`);
            }
        }

        // 获取用户信息
        async function getUserInfo(accessToken) {
            const infoUrl = `https://pan.baidu.com/rest/2.0/xpan/api?method=user.getinfo&access_token=${accessToken}`;
            // 同样，使用你创建的Cloudflare Worker作为代理
            const proxiedInfoUrl = `https://myjellyfishcors.iixye827.workers.dev/${infoUrl.replace('://', ':/')}`;
            const response = await fetch(proxiedInfoUrl);

            if (!response.ok) return null;
            return await response.json();
        }


        // 模块的公共接口
        return {
            init,
            openSettingsModal,
        };
    })();

    /* =============================================================== */
    /* ========================= [新增结束] ========================== */
    /* =============================================================== */

    
    // ===== [START] MEMORY APP LOGIC =====
    let memoryCache = null; // [修复] 将 memoryCache 提升到模块共享作用域
    // [新增] 基于 IndexedDB 的图片持久化缓存
    const ImageCacheDB = (() => {
        let db;
        const DB_NAME = 'JellyfishImageCache';
        const STORE_NAME = 'photo_blobs';
        const DB_VERSION = 1;

        // 初始化/打开数据库
        async function init() {
            return new Promise((resolve, reject) => {
                if (db) {
                    resolve(db);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.error);
                    reject("IndexedDB 初始化失败。");
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB 图片缓存库已准备就绪。");
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    // 当数据库首次创建或版本升级时调用
                    const store = event.target.result.createObjectStore(STORE_NAME, { keyPath: 'path' });
                    console.log("IndexedDB 对象存储空间已创建。");
                };
            });
        }

        // 存储图片 Blob
        async function set(path, blob) {
            if (!db) await init();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put({ path, blob });
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error('无法将图片存入 IndexedDB:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // 获取图片 Blob
        async function get(path) {
            if (!db) await init();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(path);
                request.onsuccess = () => {
                    resolve(request.result ? request.result.blob : null);
                };
                request.onerror = (event) => {
                    console.error('无法从 IndexedDB 读取图片:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        return { init, set, get };
    })();

    const MemoryApp = (() => {
        const MEMORY_DATA_PATH = 'memory/data.json';
        const MEMORY_PHOTOS_PATH = 'memory/photos/';
        let memoryDataSha = null;
        let isSaving = false;
        let saveTimeout = null;

        const ui = {
            modal: document.getElementById('memoryModal'),
            appContainer: document.getElementById('memoryAppContainer'),
            status: document.getElementById('memory-sync-status'),
            folderList: document.getElementById('folder-list-container'),
            notesList: document.getElementById('notes-list-container'),
            albumList: document.getElementById('album-list-container'),
            photoList: document.getElementById('photo-list-container'),
            photoUploader: document.getElementById('photo-uploader'),
        memoManageControls: document.getElementById('memo-management-controls'),
        albumManageControls: document.getElementById('album-management-controls'),
        photoManageControls: document.getElementById('photo-management-controls'),
        noteManageControls: document.getElementById('note-management-controls'),
            folderModal: document.getElementById('memoryFolderModal'),
            photoDetailsModal: document.getElementById('memoryPhotoDetailsModal'),
            photoViewer: document.getElementById('memoryPhotoViewerOverlay'),
            photosetToggleContainer: document.getElementById('photoset-toggle-container'),
            photosetToggle: document.getElementById('create-photoset-toggle'),
            categorySelector: document.getElementById("categorySelector"),
            projectSelector: document.getElementById("projectSelector"),
            fileList: document.getElementById("fileList"), 
            fileListStatus: document.getElementById("fileListStatus"), 
            fileUploader: document.getElementById("fileUploader"), 
            selectFileBtn: document.getElementById("selectFileBtn"), 
            selectedFileName: document.getElementById("selectedFileName"), 
            fileNameInput: document.getElementById("fileNameInput"), 
            uploadBtn: document.getElementById("uploadBtn"), 
            progressContainer: document.getElementById("progressContainer"), 
            progressBar: document.getElementById("uploadProgressBar")
        };

    const state = {
        currentSection: null,
        isMemoManageMode: false, memoFoldersToDelete: [],
        isAlbumManageMode: false, albumFoldersToDelete: [],
        isPhotoManageMode: false, photosToDelete: [],
        isNoteManageMode: false, notesToDelete: [],
        currentMemoFolderId: null, currentNoteId: null, currentAlbumId: null,
        folderModalContext: null,
        viewerContext: { items: [], index: -1 },
        photoUploadQueue: [],
        isSavingPhoto: false,
        skipAllPhotoDetails: false, // [新增] 用于标记是否跳过后续所有照片详情
        cloudDriveRequestToken: null, // [新增] 为文件夹加载请求创建一个唯一令牌
    };

        function getInitialData() {
            return {
                memo: { folders: [{ id: Date.now(), name: "默认文件夹" }], notes: [] },
                album: { folders: [{ id: Date.now() + 1, name: "我的照片" }], items: [] },
                // [新增] 标签数据结构
                allTags: [], // 存储所有标签对象, e.g., [{id: 123, name: '重要'}]
                driveTags: {} // 存储文件路径到标签ID数组的映射, e.g., {'path/to/file.txt': [123, 456]}
            };
        }

        function updateStatus(text, isError = false, reason = '') { ui.status.textContent = isError && reason ? `${text}: ${reason}` : text; ui.status.style.color = isError ? '#e53e3e' : 'inherit'; }

        async function syncWithGithub() {
            if (!checkConfig(false)) return;
            updateStatus('同步中...');
            const { data, error, response } = await fetchFromGithub(MEMORY_DATA_PATH);

            if (error) {
                updateStatus('同步失败', true, error);
                return;
            }

            if (response && response.status === 404) {
                // 文件不存在，是新用户或数据被清空，安全地初始化
                memoryCache = getInitialData();
                memoryDataSha = null;
                updateStatus('已同步');
                return;
            }

            if (data && data.content && data.content.trim() !== '') {
                // [核心修复] 只有在文件内容真实存在且不为空时，才尝试解析
                try {
                    const parsedData = JSON.parse(b64_to_utf8(data.content));
                    // 使用 mergeDeep 确保数据结构的完整性，避免因版本迭代缺少键而报错
                    memoryCache = mergeDeep({}, getInitialData(), parsedData);

                    // [核心修复] 再次确保标签数据结构存在，以防 mergeDeep 未能正确处理顶级空对象
                    if (!memoryCache.allTags) {
                        memoryCache.allTags = [];
                    }
                    if (!memoryCache.driveTags) {
                        memoryCache.driveTags = {};
                    }


                    // 兼容旧版 photos 字段

                    if (memoryCache.album.photos && !memoryCache.album.items) {
                        memoryCache.album.items = memoryCache.album.photos.map(p => ({...p, type: 'photo'}));
                        delete memoryCache.album.photos;
                    }

                    memoryDataSha = data.sha;
                    updateStatus('已同步');
                } catch (e) {
                    // 如果内容不为空，但解析仍然失败，说明文件确实损坏
                    console.error('Memory data is corrupted:', e);
                    updateStatus('数据损坏', true, '云端记忆文件格式错误');
                    await handleDataCorruption();
                }
            } else {
                // [核心修复] 文件不存在、存在但无内容、或内容为空字符串，都视为安全初始化
                if (response && response.status !== 404) {
                     console.log('File exists but is empty. Initializing with default data.');
                }
                memoryCache = getInitialData();
                memoryDataSha = data ? data.sha : null; // 如果文件存在但为空，也需要记录sha以便后续保存
                updateStatus('已同步');
            }
        }

        // [新增] 数据损坏处理函数
        async function handleDataCorruption() {
            const recoveryModal = document.getElementById('memoryDataRecoveryModal');
            if (!recoveryModal) {
                alert('检测到记忆数据文件损坏，但恢复组件未找到！请检查代码。');
                return;
            }
            
            const versionsListContainer = recoveryModal.querySelector('#memory-recovery-versions-list');
            const confirmBtn = recoveryModal.querySelector('#confirmMemoryRecoveryBtn');
            const cancelBtn = recoveryModal.querySelector('#cancelMemoryRecoveryBtn');

            versionsListContainer.innerHTML = '<p>正在查找历史版本...</p>';
            recoveryModal.classList.add('show');

            const history = await getHistoryForFile(MEMORY_DATA_PATH);
            const historyToConsider = history ? history.slice(0, 5) : []; // 最多获取最近5个版本

            if (historyToConsider.length === 0) {
                versionsListContainer.innerHTML = '<p>未找到任何有效的历史版本。很抱歉，可能无法恢复数据。</p>';
                confirmBtn.disabled = true;
                return;
            }

            versionsListContainer.innerHTML = '';
            const versionPromises = historyToConsider.map(async (commit) => {
                const content = await getContentAtCommit(MEMORY_DATA_PATH, commit.sha);
                if (content) {
                    try {
                        const parsed = JSON.parse(content);
                        const summary = {
                            memos: parsed.memo?.notes?.length || 0,
                            albums: parsed.album?.folders?.length || 0,
                            photos: parsed.album?.items?.length || 0,
                        };
                        return { sha: commit.sha, message: commit.commit.message, date: new Date(commit.commit.author.date).toLocaleString('zh-CN'), summary, content };
                    } catch (e) {
                        return null; // 忽略解析失败的历史版本
                    }
                }
                return null;
            });

            const versions = (await Promise.all(versionPromises)).filter(Boolean);

            if (versions.length === 0) {
                versionsListContainer.innerHTML = '<p>无法解析任何历史版本。数据可能已严重损坏。</p>';
                confirmBtn.disabled = true;
                return;
            }

            versions.forEach((version, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'recovery-version-item';
                itemEl.innerHTML = `
                    <input type="radio" name="memory-recovery-version" id="mem-version-${index}" value="${version.sha}">
                    <label for="mem-version-${index}">
                        <div class="version-meta">${version.message} <span>(${version.date})</span></div>
                        <div class="version-summary">
                            <span><pre>备忘录: ${version.summary.memos}</pre></span>
                            <span><pre>相册: ${version.summary.albums}</pre></span>
                            <span><pre>照片/集: ${version.summary.photos}</pre></span>
                        </div>
                    </label>
                `;
                versionsListContainer.appendChild(itemEl);
            });

            confirmBtn.disabled = true;

            const selectionHandler = () => confirmBtn.disabled = false;
            versionsListContainer.addEventListener('change', selectionHandler);

            return new Promise(resolve => {
                const confirmHandler = async () => {
                    const selectedSha = versionsListContainer.querySelector('input:checked')?.value;
                    if (!selectedSha) return;

                    confirmBtn.textContent = '恢复中...';
                    confirmBtn.disabled = true;

                    const selectedVersion = versions.find(v => v.sha === selectedSha);
                    const result = await saveToGithub(MEMORY_DATA_PATH, utf8_to_b64(selectedVersion.content), `Recover memory data from commit ${selectedSha.substring(0, 7)}`);

                    if (result.sha) {
                        alert('数据恢复成功！页面将刷新以应用新数据。');
                        location.reload();
                    } else {
                        alert('恢复失败，请检查网络后重试。');
                        confirmBtn.textContent = '恢复选中版本';
                        confirmBtn.disabled = false;
                    }
                    cleanup();
                    resolve();
                };

                const cancelHandler = () => {
                    recoveryModal.classList.remove('show');
                    cleanup();
                    resolve();
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', confirmHandler);
                    cancelBtn.removeEventListener('click', cancelHandler);
                    versionsListContainer.removeEventListener('change', selectionHandler);
                };

                confirmBtn.addEventListener('click', confirmHandler);
                cancelBtn.addEventListener('click', cancelHandler);
            });
        }

        
         function scheduleSave() {
            if (isSaving) return;
            clearTimeout(saveTimeout);
            updateStatus('有未保存的更改');
            saveTimeout = setTimeout(async () => {
                isSaving = true;
                updateStatus('保存中...');
                const content = utf8_to_b64(JSON.stringify(memoryCache, null, 2));
                const result = await saveToGithub(MEMORY_DATA_PATH, content, 'Update memory data'); 
                
                // [修改] 增加保存成功或失败后的状态更新
                if (result.sha) {
                    updateStatus('已同步');
                } else { 
                    updateStatus('保存失败', true, result.error); 
                }
                isSaving = false;
            }, 1500);
        }


        
        function showPage(pageId) { ui.appContainer.querySelectorAll(':scope > .page').forEach(p => p.classList.remove('active')); ui.appContainer.querySelector(`#${pageId}`).classList.add('active'); }
        function showView(viewId, sectionId) { const section = ui.appContainer.querySelector(`#${sectionId}`); section.querySelectorAll(':scope > .page').forEach(p => p.classList.remove('active')); section.querySelector(`#${viewId}`).classList.add('active'); showPage(sectionId); }

        function renderMemoFolders() {
            ui.folderList.innerHTML = '';
            memoryCache.memo.folders.forEach(folder => {
            ui.folderList.style.gridTemplateColumns = '';
                // [新增] 计算当前文件夹下的笔记数量
                const itemCount = memoryCache.memo.notes.filter(note => note.folderId === folder.id).length;
                const isSelected = state.memoFoldersToDelete.includes(folder.id);
                const el = document.createElement('div');
                el.className = `folder-item ${state.isMemoManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`;
                el.dataset.folderId = folder.id;
                el.dataset.action = "open-memo-folder";
                // [修改] 在HTML结构中添加项目数量信息，与相册封面对齐
                el.innerHTML = `<span class="sort-handle memo-sort-handle" title="按住拖拽排序">☰</span><input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}><div><div class="folder-icon">📁</div><div class="folder-name">${folder.name}</div></div><div class="album-info">${itemCount} 个项目</div><span class="rename-icon" data-action="rename-memo-folder" title="重命名"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="20px" height="20px" viewBox="0 0 24 24" style="vertical-align: middle;"><path d="m18,22H5c-1.654,0-3-1.346-3-3V6c0-1.654,1.346-3,3-3h6v2h-6c-.552,0-1,.449-1,1v13c0,.551,.448,1,1,1h13c.552,0,1-.449,1-1v-6h2v6c0,1.654-1.346,3-3,3Z" stroke-width="0" fill="currentColor"></path><path d="m21.707,2.293c-1.178-1.18-3.236-1.18-4.414,0l-9.196,9.196-1.471,5.886,5.886-1.472,9.195-9.196c1.217-1.217,1.217-3.197,0-4.414Zm-1.414,3l-1.707,1.707-1.586-1.586,1.707-1.707c.424-.424,1.162-.424,1.586,0,.437.437,.437,1.149,0,1.586Z" fill="currentColor" stroke-width="0" data-color="color-2"></path></svg></span>`;

                ui.folderList.appendChild(el);
            });
            if (memoryCache.memo.folders.length === 0) ui.folderList.innerHTML = `<p class="empty-list-placeholder">没有文件夹</p>`;
        }


        function renderNotes() {
            ui.notesList.innerHTML = '';
            const notesInFolder = memoryCache.memo.notes.filter(n => n.folderId === state.currentMemoFolderId).sort((a, b) => (b.isPinned ? 1 : 0) - (a.isPinned ? 1 : 0) || b.timestamp - a.timestamp);
            notesInFolder.forEach(note => {
                const isSelected = state.notesToDelete.includes(note.id); // 检查是否被选中
                const el = document.createElement('div');
                // 添加管理模式相关的 class
                el.className = `note-item ${note.isPinned ? 'pinned' : ''} ${state.isNoteManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`; 
                el.dataset.noteId = note.id;
                el.dataset.action = "open-note";
                // 提取纯文本内容用于预览和复制
                // 创建一个虚拟div来解析HTML并获取纯文本
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = note.content || '';
                const plainTextContent = tempDiv.textContent;

                const preview = (plainTextContent).substring(0, 100).replace(/</g, "&lt;").replace(/>/g, "&gt;"); // 预览纯文本
                const date = new Date(note.timestamp).toLocaleDateString('zh-CN');
                // 添加复选框，并将图标从 📌 替换为 "置顶"
                el.innerHTML = `
                    <input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}>
                    <div class="note-content-area">
                        <div class="note-title">${note.title || '无标题'}</div>
                        <div class="note-preview">${preview || '没有内容'}</div>
                        <div class="note-timestamp">${date}</div>
                    </div>
                    <button class="pin-btn" data-action="pin-note" data-note-id="${note.id}" title="置顶">置顶</button>
                    <!-- 新增的复制按钮 -->
                    <button class="note-item-copy-btn" data-action="copy-note-text" data-note-id="${note.id}" title="复制备忘录正文">
                        <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="20px" height="20px" viewBox="0 0 20 20">
                            <path d="m4,7h3c.552,0,1-.448,1-1v-3" fill="currentColor" stroke="currentColor" stroke-linejoin="round" stroke-width="2" data-color="color-2"></path>
                            <path d="m16,14v-8c0-1.657-1.343-3-3-3h-4.586c-.265,0-.52.105-.707.293l-3.414,3.414c-.188.188-.293.442-.293.707v6.586c0,1.657,1.343,3,3,3h6c1.657,0,3-1.343,3-3Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
                        </svg>
                    </button>
                `;
                ui.notesList.appendChild(el);
            });
            if (notesInFolder.length === 0) ui.notesList.innerHTML = `<p class="empty-list-placeholder">没有笔记</p>`;
        }

        function renderAlbumFolders() {
            ui.albumList.innerHTML = '';
            // [修改] 如果存在排序，则使用排序后的数组，否则使用原数组
            const foldersToRender = memoryCache.album.folders;

            foldersToRender.forEach(folder => {
                const itemCount = memoryCache.album.items.filter(p => p.albumId === folder.id).length;
                const isSelected = state.albumFoldersToDelete.includes(folder.id);
                const el = document.createElement('div');
                el.className = `album-item ${state.isAlbumManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`;
                el.dataset.albumId = folder.id;
                el.dataset.action = "open-album-folder";
                el.innerHTML = `<span class="sort-handle" title="按住拖拽排序">☰</span><input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}><div><div class="folder-icon">🖼️</div><div class="folder-name">${folder.name}</div></div><div class="album-info">${itemCount} 个项目</div><span class="rename-icon" data-action="rename-album" title="重命名"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="20px" height="20px" viewBox="0 0 24 24" style="vertical-align: middle;"><path d="m18,22H5c-1.654,0-3-1.346-3-3V6c0-1.654,1.346-3,3-3h6v2h-6c-.552,0-1,.449-1,1v13c0,.551,.448,1,1,1h13c.552,0,1-.449,1-1v-6h2v6c0,1.654-1.346,3-3,3Z" stroke-width="0" fill="currentColor"></path><path d="m21.707,2.293c-1.178-1.18-3.236-1.18-4.414,0l-9.196,9.196-1.471,5.886,5.886-1.472,9.195-9.196c1.217-1.217,1.217-3.197,0-4.414Zm-1.414,3l-1.707,1.707-1.586-1.586,1.707-1.707c.424-.424,1.162-.424,1.586,0,.437.437,.437,1.149,0,1.586Z" fill="currentColor" stroke-width="0" data-color="color-2"></path></svg></span>`;



                
                // [核心修正] 处理自定义背景逻辑
                if (folder.background) {
                    el.classList.add('has-custom-bg');
                    el.style.backgroundSize = 'cover';
                    el.style.backgroundPosition = 'center';
                    
                    // 判断 background 是 Base64 还是路径
                    if (folder.background.startsWith('data:image')) {
                        // 兼容可能存在的旧数据
                        el.style.backgroundImage = `url(${folder.background})`;
                    } else {
                        // 新的路径方案，需要异步获取安全URL
                        getSecureFileUrl(folder.background).then(secureUrl => {
                            if (secureUrl) {
                                el.style.backgroundImage = `url(${secureUrl})`;
                            }
                        });
                    }
                }

                ui.albumList.appendChild(el);
            });
            if (foldersToRender.length === 0) ui.albumList.innerHTML = `<p class="empty-list-placeholder">没有相册</p>`;
        }

        function renderPhotos() {
            if (photoObserver) photoObserver.disconnect();
            ui.photoList.innerHTML = '';
            
            const itemsInAlbum = memoryCache.album.items
                .filter(p => p.albumId === state.currentAlbumId)
                .sort((a, b) => b.timestamp - a.timestamp);
            
            if (itemsInAlbum.length === 0) {
                ui.photoList.innerHTML = `<p class="empty-list-placeholder">没有照片</p>`;
                return;
            }

            const fragment = document.createDocumentFragment();
            // ★★★ 新增：定义视频图标的HTML字符串，方便复用 ★★★
            const videoIconHtml = `<div class="video-indicator"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="22px" height="22px" viewBox="0 0 18 18"><path d="M11.652,8.568l-3.651-2.129c-.333-.194-.752,.046-.752,.432v4.259c0,.386,.419,.626,.752,.432l3.651-2.129c.331-.193,.331-.671,0-.864Z" fill="none" stroke="#1c1f21" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" data-color="color-2"></path><path d="M9,1.75c4.004,0,7.25,3.246,7.25,7.25s-3.246,7.25-7.25,7.25" fill="none" stroke="#1c1f21" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"></path><circle cx="3.873" cy="14.127" r=".75" fill="#1c1f21" data-stroke="none"></circle><circle cx="1.75" cy="9" r=".75" fill="#1c1f21" data-stroke="none"></circle><circle cx="3.873" cy="3.873" r=".75" fill="#1c1f21" data-stroke="none"></circle><circle cx="6.226" cy="15.698" r=".75" fill="#1c1f21" data-stroke="none"></circle><circle cx="2.302" cy="11.774" r=".75" fill="#1c1f21" data-stroke="none"></circle><circle cx="2.302" cy="6.226" r=".75" fill="#1c1f21" data-stroke="none"></circle><circle cx="6.226" cy="2.302" r=".75" fill="#1c1f21" data-stroke="none"></circle></svg></div>`;
            const videoExtensions = ['.mp4', '.mov', '.webm', '.mkv'];

            itemsInAlbum.forEach(item => {
                const isSelected = state.photosToDelete.includes(item.id);
                const el = document.createElement('div');
                el.dataset.itemId = item.id;

                const createMediaElement = (path, isStack = false) => {
                    const isVideo = videoExtensions.some(ext => path.toLowerCase().endsWith(ext));
                    const classes = `${isStack ? 'photo-stack-img' : ''} lazyload`;
                    if (isVideo) {
                        return `<video class="${classes}" data-src="${path}" muted playsinline preload="metadata" style="pointer-events: none;"></video>`;
                    } else {
                        return `<img class="${classes}" data-src="${path}" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=">`;
                    }
                };

                if (item.type === 'photoset') {
                    el.className = `photo-item-set ${state.isPhotoManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`;
                    el.dataset.action = "open-item";
                    let stackHtml = '';
                    const photosToDisplay = item.photos.slice(0, 3);

                    // ★★★ 新增：检查照片集封面是否为视频 ★★★
                    let isCoverVideo = false;
                    if (photosToDisplay.length > 0) {
                        isCoverVideo = videoExtensions.some(ext => photosToDisplay[photosToDisplay.length - 1].path.toLowerCase().endsWith(ext));
                    }
                    
                    for (let i = photosToDisplay.length - 1; i >= 0; i--) {
                        stackHtml += createMediaElement(photosToDisplay[i].path, true);
                    }
                    const title = (item.title || '照片集');
                    el.innerHTML = `<input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}>${stackHtml}${isCoverVideo ? videoIconHtml : ''}<div class="photo-title-overlay">${title}</div><div class="count-overlay">${item.photos.length} 张</div>`;
                } else {
                    el.className = `photo-item ${state.isPhotoManageMode ? 'manage-mode' : ''} ${isSelected ? 'manage-selected' : ''}`;
                    el.dataset.action = "open-item";
                    const title = (item.title || '');
                    const mediaHtml = createMediaElement(item.path);

                    // ★★★ 新增：检查单个文件是否为视频 ★★★
                    const isVideo = videoExtensions.some(ext => item.path.toLowerCase().endsWith(ext));

                    el.innerHTML = `<input type="checkbox" class="manage-checkbox" ${isSelected ? 'checked' : ''}>${mediaHtml}${isVideo ? videoIconHtml : ''}<div class="photo-title-overlay">${title}</div>`;
                }
                fragment.appendChild(el);
            });


            ui.photoList.appendChild(fragment);

            const lazyImages = ui.photoList.querySelectorAll('.lazyload');
            lazyImages.forEach(img => photoObserver.observe(img));
        }

        
        async function openPhotoViewer(items, initialIndex) {
            if (!items || items.length === 0) return;
            state.viewerContext = { items, index: initialIndex };
            ui.photoViewer.classList.add('active');
            await updatePhotoViewerContent();
        }

// (这是替换后的新代码)
        async function updatePhotoViewerContent() {
            const { items, index } = state.viewerContext;
            if (!items || items.length === 0 || index < 0) { closePhotoViewer(); return; }
            
            const currentItem = items[index];
            let photo, title, description, timestamp, isSet, setIndex = 0, setLength = 0, isVideo = false;

            if (currentItem.type === 'photoset') {
                isSet = true;
                setIndex = currentItem.internalIndex || 0;
                setLength = currentItem.photos.length;
                photo = currentItem.photos[setIndex];
                title = currentItem.title;
                description = currentItem.description;
                timestamp = currentItem.timestamp;
            } else {
                isSet = false;
                photo = currentItem;
                title = photo.title;
                description = photo.description;
                timestamp = photo.timestamp;
            }

            const viewerImgContainer = ui.photoViewer.querySelector('#viewer-img-container');
            viewerImgContainer.innerHTML = ''; // 清空容器

            const fileUrl = await getSecureFileUrl(photo.path);
            
            // --- [需求 3 实现] ---
            const videoExtensions = ['.mp4', '.mov', '.webm', '.avi', '.mkv']; // 可根据需要添加更多格式
            isVideo = videoExtensions.some(ext => photo.path.toLowerCase().endsWith(ext));

            let mediaElement;
            if (isVideo) {
                mediaElement = document.createElement('video');
                mediaElement.controls = true; // 显示视频控制条
                mediaElement.autoplay = false; // 默认不自动播放
                mediaElement.style.maxWidth = '100%';
                mediaElement.style.maxHeight = '100%';
                mediaElement.id = 'viewer-img'; // 保持ID以便样式应用
                viewerImgContainer.appendChild(mediaElement);
            } else {
                mediaElement = document.createElement('img');
                mediaElement.alt = "渲染中...";
                mediaElement.id = 'viewer-img';
                viewerImgContainer.appendChild(mediaElement);
            }

            mediaElement.src = fileUrl; // 为 img 或 video 设置 src
            
            ui.photoViewer.querySelector('#viewer-title').textContent = title || '';
            ui.photoViewer.querySelector('#viewer-description').textContent = description || '';
            ui.photoViewer.querySelector('#viewer-timestamp').textContent = new Date(timestamp).toLocaleString('zh-CN');
            
            const downloadBtn = document.getElementById('download-photo-btn');
            if (downloadBtn) {
                downloadBtn.href = fileUrl;
                const originalFilename = photo.path.split('/').pop();
                const smartTitle = title ? title.replace(/[/\\?%*:|"<>]/g, '-') : '';
                
                // 如果是图片且没有正确扩展名，则默认.jpg
                const extension = originalFilename.includes('.') ? '.' + originalFilename.split('.').pop() : (isVideo ? '.mp4' : '.jpg');
                
                downloadBtn.download = smartTitle ? `${smartTitle}${extension}` : originalFilename;
                downloadBtn.style.display = 'flex';
            }
            // --- [需求 3 实现结束] ---


            const prevBtn = document.getElementById('prev-photo-btn');
            const nextBtn = document.getElementById('next-photo-btn');
            const counter = document.getElementById('viewer-counter');

            const canGoPrev = (isSet && setIndex > 0) || index > 0;
            const canGoNext = (isSet && setIndex < setLength - 1) || index < items.length - 1;

            prevBtn.style.display = canGoPrev ? 'flex' : 'none';
            nextBtn.style.display = canGoNext ? 'flex' : 'none';

            if (isSet) {
                counter.textContent = `${setIndex + 1} / ${setLength}`;
                counter.style.display = 'block';
            } else {
                counter.style.display = 'none';
            }
        }

        function closePhotoViewer() { 
            document.getElementById('viewer-img-container').classList.remove('zoomed-long'); // 重置缩放状态
            state.viewerContext.items.forEach(item => { if(item.type === 'photoset') delete item.internalIndex; });
            ui.photoViewer.classList.remove('active'); 
            // [新增] 隐藏下载按钮
            const downloadBtn = document.getElementById('download-photo-btn');
            if (downloadBtn) {
                downloadBtn.style.display = 'none';
            }
        }
        async function changePhotoInViewer(direction) {
            const { items, index } = state.viewerContext;
            const currentItem = items[index];
            
            if (currentItem.type === 'photoset') {
                const newSetIndex = (currentItem.internalIndex || 0) + direction;
                if (newSetIndex >= 0 && newSetIndex < currentItem.photos.length) {
                    currentItem.internalIndex = newSetIndex;
                } else {
                    changeViewerItem(direction);
                }
            } else {
                changeViewerItem(direction);
            }
            await updatePhotoViewerContent();
        }

        function changeViewerItem(direction) {
            let newIndex = state.viewerContext.index + direction;
            if (newIndex >= 0 && newIndex < state.viewerContext.items.length) {
                state.viewerContext.index = newIndex;
                    const newItem = state.viewerContext.items[newIndex];
                if (newItem.type === 'photoset') {
                    newItem.internalIndex = direction > 0 ? 0 : newItem.photos.length - 1;
                }
            }
        }



        const actions = {
            'open-baidu-settings': () => BaiduNetdisk.openSettingsModal(), // <<< 这里添加了逗号
            'goto-memo': () => { showPage('memo-section'); state.currentSection = 'memo'; document.getElementById('memory-modal-title').textContent = '备忘录'; renderMemoFolders(); },
            'goto-album': () => { showPage('album-section'); state.currentSection = 'album'; document.getElementById('memory-modal-title').textContent = '相册'; renderAlbumFolders(); },
            'goto-cloud': () => { 
    showPage('cloud-drive-section'); 
    state.currentSection = 'cloud'; 
    document.getElementById('memory-modal-title').textContent = '文件夹'; 
    populateDriveCategorySelector(); 
    populateDriveProjectSelector(); // 新增此行
    fetchFilesForSelectedProject(); 
},

            'back-to-hub': () => {
                // 退出管理模式
                if (state.isMemoManageMode) actions['toggle-memo-manage'](ui.modal.querySelector('[data-action="toggle-memo-manage"]'));
                if (state.isAlbumManageMode) actions['toggle-album-manage'](ui.modal.querySelector('[data-action="toggle-album-manage"]'));
                
                showPage('hub-view'); 
                state.currentSection = null; 
                document.getElementById('memory-modal-title').textContent = '记忆'; 
            },

            'add-memo-folder': () => { state.folderModalContext = { type: 'memo', id: null }; document.getElementById('folder-modal-title').textContent = '新文件夹'; ui.folderModal.querySelector('#folder-name-input').value = ''; ui.folderModal.classList.add('show'); },
            'add-album-folder': () => {
                if (memoryCache.album.folders.length >= 100) { alert('相册数量已达上限（100个），请整理后再创建。'); return; }
                state.folderModalContext = { type: 'album', id: null }; document.getElementById('folder-modal-title').textContent = '新相册'; ui.folderModal.querySelector('#folder-name-input').value = ''; ui.folderModal.classList.add('show'); },
            'close-folder-modal': () => ui.folderModal.classList.remove('show'),
            'save-folder': () => {
                const { type, id } = state.folderModalContext;
                const name = ui.folderModal.querySelector('#folder-name-input').value.trim();
                if (!name) return alert('名称不能为空');
                const list = memoryCache[type].folders;
                if (id) {
                    const item = list.find(f => f.id === id);
                    if (item) item.name = name;
                } else {
                    list.push({ id: Date.now(), name });
                }
                ui.folderModal.classList.remove('show');
                if (type === 'memo') renderMemoFolders(); else renderAlbumFolders();
                scheduleSave();
            },
            // --- 在此下方新增 ---
            'rename-memo-folder': (target) => {
                const folderId = parseInt(target.closest('[data-folder-id]').dataset.folderId, 10);
                const folder = memoryCache.memo.folders.find(f => f.id === folderId);
                if (folder) {
                    const newName = prompt('请输入新的文件夹名称：', folder.name);
                    if (newName && newName.trim() && newName.trim() !== folder.name) {
                        folder.name = newName.trim();
                        renderMemoFolders();
                        scheduleSave();
                    }
                }
            },
            // --- 新增结束 ---
            'open-memo-folder': (target) => {
                const folderId = parseInt(target.closest('[data-folder-id]').dataset.folderId, 10);
                if (state.isMemoManageMode) {
                    const index = state.memoFoldersToDelete.indexOf(folderId);
                    if (index > -1) state.memoFoldersToDelete.splice(index, 1);
                    else state.memoFoldersToDelete.push(folderId);
                    renderMemoFolders();
                    return;
                }
                state.currentMemoFolderId = folderId;
                const folder = memoryCache.memo.folders.find(f => f.id === folderId);
                if (folder) document.getElementById('notes-view-title').textContent = folder.name;
                showView('notes-view', 'memo-section');
                renderNotes();
            },
            'open-album-folder': (target) => {
                const albumId = parseInt(target.closest('[data-album-id]').dataset.albumId, 10);
                if (state.isAlbumManageMode) {
                    const index = state.albumFoldersToDelete.indexOf(albumId);
                    if (index > -1) state.albumFoldersToDelete.splice(index, 1);
                    else state.albumFoldersToDelete.push(albumId);
                    renderAlbumFolders();
                    return;
                }
                state.currentAlbumId = albumId;
                const folder = memoryCache.album.folders.find(f => f.id === albumId);
                if (folder) document.getElementById('photo-grid-title').textContent = folder.name;
                showView('photo-grid-view', 'album-section');
                renderPhotos();
            },
            'back-to-memo-folders': () => {
                if (document.getElementById('note-editor-view').classList.contains('active')) {
                   actions['cancel-note']();
                } else {
                   // [新增] 在返回文件夹列表前，检查并关闭笔记列表的管理模式
                   if (state.isNoteManageMode) {
                        actions['toggle-note-manage'](ui.modal.querySelector('[data-action="toggle-note-manage"]'));
                   }
                   showView('folder-view', 'memo-section'); state.currentMemoFolderId = null;
                }
            },

            'back-to-album-folders': () => {
                // [新增] 在返回相册列表前，检查并关闭照片列表的管理模式
                if (state.isPhotoManageMode) {
                    actions['toggle-photo-manage'](ui.modal.querySelector('[data-action="toggle-photo-manage"]'));
                }
                showView('album-folder-view', 'album-section'); 
                state.currentAlbumId = null; 
            },

            'add-note': () => {
                state.currentNoteId = null;
                document.getElementById('note-title-input').value = '';
                document.getElementById('note-content-editor').innerHTML = ''; // 修正点：清空 contenteditable div
                document.querySelector('[data-action="delete-note"]').style.display = 'none';
                showView('note-editor-view', 'memo-section');
            },

         'open-note': (target) => {
            const noteId = parseInt(target.closest('[data-note-id]').dataset.noteId, 10);
            if (state.isNoteManageMode) {
                const index = state.notesToDelete.indexOf(noteId);
                if (index > -1) state.notesToDelete.splice(index, 1);
                else state.notesToDelete.push(noteId);
                renderNotes();
                return;
            }
            const note = memoryCache.memo.notes.find(n => n.id === noteId);
            if (note) {
                state.currentNoteId = note.id;
                document.getElementById('note-title-input').value = note.title;
                document.getElementById('note-content-editor').innerHTML = note.content; 
                document.querySelector('[data-action="delete-note"]').style.display = 'inline-block';
                showView('note-editor-view', 'memo-section');
            }
        },

            'save-note': () => {
                const title = document.getElementById('note-title-input').value.trim();
                // 从 contenteditable div 获取 innerHTML
                const content = document.getElementById('note-content-editor').innerHTML;
                const now = Date.now();
                if (state.currentNoteId) {
                    const note = memoryCache.memo.notes.find(n => n.id === state.currentNoteId);
                    if (note) {
                        note.title = title;
                        note.content = content;
                        note.timestamp = now;
                    }
                } else {
                    memoryCache.memo.notes.push({ id: now, folderId: state.currentMemoFolderId, title, content, timestamp: now, isPinned: false });
                }
                showView('notes-view', 'memo-section');
                renderNotes();
                scheduleSave();
            },

            'cancel-note': () => {
                showView('notes-view', 'memo-section');
            },
            'delete-note': () => {
                if (state.currentNoteId && confirm('确定要删除这篇笔记吗？')) {
                    memoryCache.memo.notes = memoryCache.memo.notes.filter(n => n.id !== state.currentNoteId);
                    showView('notes-view', 'memo-section');
                    renderNotes();
                    scheduleSave();
                }
            },
            'pin-note': (target) => {
                const noteId = parseInt(target.dataset.noteId, 10);
                const note = memoryCache.memo.notes.find(n => n.id === noteId);
                if(note) { note.isPinned = !note.isPinned; }
                renderNotes();
                scheduleSave();
            },
             // 新增：复制备忘录纯文本的动作 (V2 - 修复格式丢失问题)
            'copy-note-text': async (target) => {
                // 阻止事件冒泡，防止触发父级“open-note”事件
                const noteId = parseInt(target.closest('[data-note-id]').dataset.noteId, 10);
                const note = memoryCache.memo.notes.find(n => n.id === noteId);
                if (note && note.content) {
                    // 1. 创建一个临时元素
                    const tempDiv = document.createElement('div');

                    // 2. [核心] 设置样式，使其在视口外渲染，但视觉上不可见
                    tempDiv.style.position = 'fixed';
                    tempDiv.style.top = '-9999px';
                    tempDiv.style.left = '-9999px';
                    tempDiv.style.whiteSpace = 'pre-wrap'; // 保持空白符和换行
                    tempDiv.style.width = '1px'; // 给一个极小的宽度，让浏览器计算布局
                    
                    // 3. 将备忘录的HTML内容填入
                    tempDiv.innerHTML = note.content;

                    // 4. [核心] 将元素添加到页面中，以便浏览器渲染它
                    document.body.appendChild(tempDiv);
                    
                    try {
                        // 5. [核心] 从渲染后的元素上获取 innerText，这会保留格式
                        const plainTextWithFormat = tempDiv.innerText;
                        
                        // 6. 复制到剪贴板
                        await navigator.clipboard.writeText(plainTextWithFormat);
                        showTopToast(`"${note.title || '无标题'}" 已复制`, 2000);
                    } catch (err) {
                        showTopToast('复制失败，请手动复制', 2000);
                        console.error('Failed to copy note text:', err);
                    } finally {
                        // 7. [核心] 无论成功与否，都从页面中移除临时元素
                        document.body.removeChild(tempDiv);
                    }
                } else {
                    showTopToast('备忘录内容为空，无法复制', 2000);
                }
            },

            'toggle-memo-manage': (target) => {
                state.isMemoManageMode = !state.isMemoManageMode;
                target.textContent = state.isMemoManageMode ? '完成' : '管理';
                ui.memoManageControls.classList.toggle('active', state.isMemoManageMode);
                if (!state.isMemoManageMode) state.memoFoldersToDelete = [];
                renderMemoFolders();
            },
            'select-all-memo': () => {
                if (state.memoFoldersToDelete.length === memoryCache.memo.folders.length) {
                    state.memoFoldersToDelete = [];
                } else {
                    state.memoFoldersToDelete = memoryCache.memo.folders.map(f => f.id);
                }
                renderMemoFolders();
            },
            'delete-selected-memo': () => {
                if (state.memoFoldersToDelete.length === 0) return;
                let notesToDeleteCount = 0;
                memoryCache.memo.notes.forEach(note => {
                    if (state.memoFoldersToDelete.includes(note.folderId)) {
                        notesToDeleteCount++;
                    }
                });
                if (confirm(`确定要删除选中的 ${state.memoFoldersToDelete.length} 个文件夹及其包含的 ${notesToDeleteCount} 篇笔记吗？`)) {
                    memoryCache.memo.notes = memoryCache.memo.notes.filter(n => !state.memoFoldersToDelete.includes(n.folderId));
                    memoryCache.memo.folders = memoryCache.memo.folders.filter(f => !state.memoFoldersToDelete.includes(f.id));
                    state.memoFoldersToDelete = [];
                    renderMemoFolders();
                    scheduleSave();
                }
            },
            'toggle-album-manage': (target) => {
                state.isAlbumManageMode = !state.isAlbumManageMode;
                target.textContent = state.isAlbumManageMode ? '完成' : '管理';
                ui.albumManageControls.classList.toggle('active', state.isAlbumManageMode);
                if (!state.isAlbumManageMode) state.albumFoldersToDelete = [];
                
                // [新增] 替换全局漫游按钮的逻辑
                const globalWanderBtn = document.querySelector('#album-folder-view [data-action="wander-global"]');
                if (globalWanderBtn) {
                     if (state.isAlbumManageMode) {
                        // 在管理模式下，全局漫游没有意义，可以隐藏或禁用
                        globalWanderBtn.style.display = 'none';
                    } else {
                        // 退出管理模式时恢复
                        globalWanderBtn.style.display = 'inline-block';
                    }
                }

                renderAlbumFolders();
            },

            'select-all-album': () => {
                if (state.albumFoldersToDelete.length === memoryCache.album.folders.length) {
                    state.albumFoldersToDelete = [];
                } else {
                    state.albumFoldersToDelete = memoryCache.album.folders.map(f => f.id);
                }
                renderAlbumFolders();
            },
            'delete-selected-album': async () => {
                if (state.albumFoldersToDelete.length === 0) return;
                const itemsToDelete = memoryCache.album.items.filter(p => state.albumFoldersToDelete.includes(p.albumId));
                let photoCount = 0;
                itemsToDelete.forEach(item => { photoCount += item.type === 'photoset' ? item.photos.length : 1; });
                if (confirm(`确定要删除选中的 ${state.albumFoldersToDelete.length} 个相册及其包含的 ${photoCount} 张照片吗？`)) {
                    await Promise.all(itemsToDelete.map(item => {
                        if (item.type === 'photoset') return Promise.all(item.photos.map(p => deleteFromGithub(p.path, `Delete photo from set`, p.sha, true)));
                        else return deleteFromGithub(item.path, `Delete photo`, item.sha, true);
                    }));
                    memoryCache.album.items = memoryCache.album.items.filter(p => !state.albumFoldersToDelete.includes(p.albumId));
                    memoryCache.album.folders = memoryCache.album.folders.filter(f => !state.albumFoldersToDelete.includes(f.id));
                    state.albumFoldersToDelete = [];
                    renderAlbumFolders();
                    scheduleSave();
                }
            },
        'toggle-note-manage': (target) => {
            state.isNoteManageMode = !state.isNoteManageMode;
            target.textContent = state.isNoteManageMode ? '完成' : '管理';
            ui.noteManageControls.classList.toggle('active', state.isNoteManageMode);
            if (!state.isNoteManageMode) state.notesToDelete = [];
            renderNotes();
        },
        'select-all-notes': () => {
            const currentFolderNotes = memoryCache.memo.notes.filter(n => n.folderId === state.currentMemoFolderId);
            if (state.notesToDelete.length === currentFolderNotes.length) {
                state.notesToDelete = [];
            } else {
                state.notesToDelete = currentFolderNotes.map(n => n.id);
            }
            renderNotes();
        },
        'delete-selected-notes': () => {
            if (state.notesToDelete.length === 0) return;
            if (confirm(`确定要删除选中的 ${state.notesToDelete.length} 篇笔记吗？`)) {
                memoryCache.memo.notes = memoryCache.memo.notes.filter(n => !state.notesToDelete.includes(n.id));
                state.notesToDelete = [];
                renderNotes();
                scheduleSave();
            }
        },
        'move-selected-notes': () => {
            if (state.notesToDelete.length === 0) {
                alert('请先选择要移动的笔记。');
                return;
            }
            const destSelector = document.getElementById('memo-destination-selector');
            destSelector.innerHTML = '';
            memoryCache.memo.folders.forEach(folder => {
                if (folder.id !== state.currentMemoFolderId) {
                    const option = document.createElement('option');
                    option.value = folder.id;
                    option.textContent = folder.name;
                    destSelector.appendChild(option);
                }
            });

            if (destSelector.options.length === 0) {
                alert('没有其他文件夹可以移动。');
                return;
            }
            document.getElementById('moveNotesModal').classList.add('show');
        },
        'close-move-notes-modal': () => {
            document.getElementById('moveNotesModal').classList.remove('show');
        },
        'confirm-move-notes': () => {
            const destFolderId = parseInt(document.getElementById('memo-destination-selector').value, 10);
            if (!destFolderId) {
                alert('无效的目标文件夹。');
                return;
            }

            memoryCache.memo.notes.forEach(note => {
                if (state.notesToDelete.includes(note.id)) {
                    note.folderId = destFolderId;
                }
            });

            state.notesToDelete = [];
            renderNotes();
            scheduleSave();
            document.getElementById('moveNotesModal').classList.remove('show');
            showTopToast('笔记移动成功！', 2000);
        },

             'toggle-photo-manage': (target) => {
                state.isPhotoManageMode = !state.isPhotoManageMode;
                target.textContent = state.isPhotoManageMode ? '完成' : '管理';
                ui.photoManageControls.classList.toggle('active', state.isPhotoManageMode);
                if (!state.isPhotoManageMode) state.photosToDelete = [];

                // [修改] 替换漫游按钮的逻辑
                const wanderBtn = document.querySelector('#photo-grid-view [data-action="wander-local"], #photo-grid-view [data-action="set-album-bg"]'); // 确保能选中按钮
                if (wanderBtn) {
                    if (state.isPhotoManageMode) {
                        wanderBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="20px" height="20px" viewBox="0 0 24 24"> <path fill-rule="evenodd" clip-rule="evenodd" d="M16.5071 8.39038L22.7863 16.3822L21.5 19.5L16.4929 20H10.628H3.5L2.7433 18.669L1.25671 18.331L6.41639 12.5981L10.372 16.0592L16.5071 8.39038Z" fill="#1c1f21"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M20 3C21.6569 3 23 4.34315 23 6L23 18C23 19.6569 21.6569 21 20 21L4 21C2.34314 21 0.999999 19.6569 0.999999 18L1 6C1 4.34314 2.34315 3 4 3L20 3ZM21 6C21 5.44772 20.5523 5 20 5L4 5C3.44771 5 3 5.44771 3 6L3 18C3 18.5523 3.44771 19 4 19L20 19C20.5523 19 21 18.5523 21 18L21 6Z" fill="#1c1f21"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M7 9C7 7.89543 7.89543 7 9 7C10.1046 7 11 7.89543 11 9C11 10.1046 10.1046 11 9 11C7.89543 11 7 10.1046 7 9Z" fill="#1c1f21" data-color="color-2"></path> </svg>';

                        wanderBtn.dataset.action = 'set-album-bg';
                        wanderBtn.title = '设置相册背景'; // [新增] 增加提示
                        wanderBtn.classList.remove('wander-btn');
                    } else {
                       wanderBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="none"><path d="M20.3174 8.19531C20.0357 8.8823 19.5416 9.61008 18.9248 10.332C17.6628 11.8091 15.7312 13.4472 13.4355 14.9248C11.14 16.4022 8.8494 17.4826 6.98242 18.0195C6.31873 18.2104 5.67868 18.3394 5.09375 18.3857L5.45996 16.3232C5.74837 16.2727 6.07264 16.1993 6.42969 16.0967C8.06215 15.6272 10.1747 14.6455 12.3535 13.2432C14.5326 11.8406 16.3019 10.3247 17.4053 9.0332C17.7661 8.61089 18.0377 8.22999 18.2305 7.90234L20.3174 8.19531Z" fill="url(#star-sparkle_grad_0-album-inner-js)" data-glass="origin" mask="url(#star-sparkle_mask-album-inner-js)"></path><path d="M20.3174 8.19531C20.0357 8.8823 19.5416 9.61008 18.9248 10.332C17.6628 11.8091 15.7312 13.4472 13.4355 14.9248C11.14 16.4022 8.8494 17.4826 6.98242 18.0195C6.31873 18.2104 5.67868 18.3394 5.09375 18.3857L5.45996 16.3232C5.74837 16.2727 6.07264 16.1993 6.42969 16.0967C8.06215 15.6272 10.1747 14.6455 12.3535 13.2432C14.5326 11.8406 16.3019 10.3247 17.4053 9.0332C17.7661 8.61089 18.0377 8.22999 18.2305 7.90234L20.3174 8.19531Z" fill="url(#star-sparkle_grad_0-album-inner-js)" data-glass="clone" filter="url(#star-sparkle_filter-album-inner-js)" clip-path="url(#star-sparkle_clip-album-inner-js)"></path><path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="url(#star-sparkle_grad_1-album-inner-js)" data-glass="blur"></path><path d="M10.6641 2.61911C11.2207 1.52809 12.7793 1.52809 13.336 2.61911L15.5079 6.87498C15.7301 7.31065 16.1505 7.61058 16.6348 7.67869L21.4083 8.34959C22.654 8.5247 23.1438 10.0637 22.2286 10.9267L18.839 14.123C18.4713 14.4698 18.3034 14.9789 18.3917 15.4766L19.2003 20.0371C19.4097 21.2177 18.2249 22.1382 17.1475 21.6846L17.044 21.6367L12.6797 19.418C12.2525 19.2008 11.7475 19.2008 11.3203 19.418L6.95602 21.6367L6.85251 21.6846C5.80984 22.1236 4.6659 21.2757 4.78315 20.1504L4.79975 20.0371L5.60835 15.4766C5.68559 15.0411 5.56634 14.5972 5.28901 14.2607L5.16108 14.123L1.7714 10.9267C0.884703 10.0905 1.31671 8.62007 2.47746 8.3701L2.59172 8.34959L7.36521 7.67869C7.84952 7.61057 8.26991 7.31064 8.49217 6.87498L10.6641 2.61911ZM12.668 2.95993C12.3897 2.41442 11.6104 2.41442 11.332 2.95993L9.16015 7.2158C8.82676 7.86931 8.19619 8.31969 7.4697 8.42185L2.69621 9.09275C2.07335 9.18031 1.82846 9.9493 2.28605 10.3808L5.67574 13.5771C6.22733 14.0974 6.47906 14.8609 6.34664 15.6074L5.53804 20.168C5.42998 20.7772 6.06456 21.248 6.61618 20.9678L10.9805 18.749C11.6212 18.4234 12.3789 18.4234 13.0196 18.749L17.3839 20.9678C17.9355 21.248 18.5701 20.7772 18.462 20.168L17.6534 15.6074C17.521 14.8609 17.7727 14.0974 18.3243 13.5771L21.714 10.3808C22.1716 9.9493 21.9267 9.18031 21.3038 9.09275L16.5303 8.42185C15.8038 8.31969 15.1733 7.86931 14.8399 7.2158L12.668 2.95993Z" fill="url(#star-sparkle_grad_2-album-inner-js)"></path><path d="M6.07314 2.88824L5.44324 1.30101C5.28398 0.8997 4.71603 0.89965 4.55669 1.30094L3.92644 2.88824C3.91951 2.90563 3.90577 2.91938 3.88838 2.9263L2.30091 3.55671C1.89969 3.71604 1.8997 4.28396 2.30092 4.44329L3.88838 5.0737C3.90577 5.08063 3.91951 5.09437 3.92644 5.11176L4.55668 6.69906C4.71602 7.10035 5.28397 7.1003 5.44324 6.69899L6.07314 5.11176C6.08008 5.0943 6.094 5.08061 6.11147 5.0737L7.69907 4.4433C8.10031 4.28398 8.10031 3.71602 7.69907 3.5567L6.11147 2.9263C6.094 2.91939 6.08008 2.9057 6.07314 2.88824Z" fill="url(#star-sparkle_grad_3-album-inner-js)"></path><path d="M23.5 16.25C23.5 16.9404 22.9404 17.5 22.25 17.5C21.5596 17.5 21 16.9404 21 16.25C21 15.5596 21.5596 15 22.25 15C22.9404 15 23.5 15.5596 23.5 16.25Z" fill="url(#star-sparkle_grad_4-album-inner-js)"></path><path d="M18.2307 4.89743C18.949 4.93039 19.7944 5.15041 20.2727 5.89353L20.3548 6.03415C20.7312 6.74332 20.584 7.53845 20.3333 8.16404C20.3289 8.17492 20.3231 8.18536 20.3186 8.19626L18.2327 7.90329C18.3369 7.72619 18.4187 7.56496 18.4768 7.4199C18.578 7.16745 18.5847 7.03502 18.5813 6.98142C18.5338 6.95616 18.4108 6.90798 18.1399 6.89548C17.6948 6.87509 17.0493 6.96563 16.2268 7.20212C14.5943 7.67159 12.482 8.65321 10.303 10.0556C8.12386 11.4582 6.3547 12.974 5.25125 14.2656C4.69526 14.9164 4.34675 15.4662 4.18093 15.8799C4.07977 16.1323 4.07313 16.2646 4.07644 16.3183C4.12416 16.3436 4.24758 16.3918 4.51882 16.4043C4.76947 16.4157 5.08313 16.3909 5.45632 16.3261L5.09011 18.3867C4.86005 18.4047 4.63829 18.412 4.42703 18.4023C3.70884 18.3694 2.86334 18.1492 2.38504 17.4062C1.90698 16.6632 2.05709 15.803 2.32449 15.1357C2.60377 14.4391 3.10509 13.7002 3.73172 12.9668C4.99373 11.4897 6.92524 9.85163 9.22097 8.374C11.5166 6.89649 13.8071 5.81617 15.6741 5.27927C16.6011 5.01275 17.4811 4.86312 18.2307 4.89743Z" fill="url(#star-sparkle_grad_5-album-inner-js)"></path><defs><linearGradient id="star-sparkle_grad_0-album-inner-js" x1="12.706" y1="7.902" x2="12.706" y2="18.386" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient><linearGradient id="star-sparkle_grad_1-album-inner-js" x1="12" y1="1.801" x2="12" y2="21.802" gradientUnits="userSpaceOnUse"><stop stop-color="#E3E3E5" stop-opacity=".6"></stop><stop offset="1" stop-color="#BBBBC0" stop-opacity=".6"></stop></linearGradient><linearGradient id="star-sparkle_grad_2-album-inner-js" x1="12" y1="1.801" x2="12" y2="13.384" gradientUnits="userSpaceOnUse"><stop stop-color="#fff"></stop><stop offset="1" stop-color="#fff" stop-opacity="0"></stop></linearGradient><linearGradient id="star-sparkle_grad_3-album-inner-js" x1="5" y1="1" x2="5" y2="7" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient><linearGradient id="star-sparkle_grad_4-album-inner-js" x1="22.25" y1="15" x2="22.25" y2="17.5" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient><linearGradient id="star-sparkle_grad_5-album-inner-js" x1="11.329" y1="4.893" x2="11.329" y2="18.407" gradientUnits="userSpaceOnUse"><stop stop-color="#575757"></stop><stop offset="1" stop-color="#151515"></stop></linearGradient><filter id="star-sparkle_filter-album-inner-js" x="-100%" y="-100%" width="400%" height="400%" filterUnits="objectBoundingBox" primitiveUnits="userSpaceOnUse"><feGaussianBlur stdDeviation="2" x="0%" y="0%" width="100%" height="100%" in="SourceGraphic" edgeMode="none" result="blur"></feGaussianBlur></filter><clipPath id="star-sparkle_clip-album-inner-js"><path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="url(#star-sparkle_grad_1-album-inner-js)"></path></clipPath><mask id="star-sparkle_mask-album-inner-js"><rect width="100%" height="100%" fill="#FFF"></rect><path d="M10.6642 2.61922C11.2208 1.52816 12.7794 1.52811 13.336 2.61922L15.5069 6.87508C15.7292 7.31078 16.1505 7.6107 16.6349 7.67879L21.4083 8.34969C22.654 8.52479 23.1438 10.0637 22.2286 10.9268L18.839 14.1231C18.4713 14.4699 18.3034 14.979 18.3917 15.4766L19.2003 20.0372C19.4164 21.2558 18.1473 22.1966 17.0441 21.6358L12.6798 19.418C12.2526 19.2009 11.7476 19.2009 11.3204 19.418L6.95616 21.6358C5.85285 22.1967 4.58376 21.2559 4.79991 20.0372L5.60851 15.4766C5.69678 14.9789 5.52801 14.4699 5.16027 14.1231L1.77159 10.9268C0.856418 10.0637 1.34619 8.52479 2.59191 8.34969L7.36534 7.67879C7.84961 7.61064 8.27006 7.31071 8.4923 6.87508L10.6642 2.61922Z" fill="#000"></path></mask></defs></g></svg>`;

                        wanderBtn.dataset.action = 'wander-local';
                        wanderBtn.title = '漫游此相册'; // [新增] 恢复提示
                        wanderBtn.classList.add('wander-btn');
                    }
                }
                
                renderPhotos();
            },

            // [V2 修正] 使用文件上传机制设置相册背景
            'set-album-bg': () => {
                // 1. 创建一个文件选择器
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';

                // 2. 监听文件选择事件
                input.onchange = async e => {
                    const file = e.target.files[0];
                    if (!file) return;

                    // 3. 立即显示加载状态，提升用户体验
                    showTopToast('正在上传背景图...', 60000); // 长时间提示以防上传慢

                    try {
                        // 4. 定义上传路径和唯一文件名
                        const ALBUM_BG_PATH = 'memory/album_backgrounds/';
                        const path = `${ALBUM_BG_PATH}bg-${state.currentAlbumId}-${Date.now()}.${file.name.split('.').pop()}`;
                        
                        // 5. 调用文件上传函数（复用已有逻辑）
                        const result = await uploadFileViaGitData({
                            file,
                            path,
                            commitMessage: `Update album background for ID ${state.currentAlbumId}`,
                            onProgress: (p) => { /* 可以在这里更新提示，暂时省略 */ }
                        });

                        // 6. 核心：只保存返回的路径
                        const album = memoryCache.album.folders.find(f => f.id === state.currentAlbumId);
                        if (album) {
                            album.background = result.path; // 只保存路径！
                            scheduleSave();
                            renderAlbumFolders(); // 重新渲染当前相册列表，即时看到效果
                            renderPhotos(); // 刷新照片视图，背景图可能也需要在这里更新
                            showTopToast('相册背景已成功设置！', 2000);
                        }
                    } catch (error) {
                        console.error("Failed to upload album background:", error);
                        const userMessage = await handleApiError("上传背景图", error);
                        alert(`上传失败: ${userMessage}`);
                        showTopToast('上传背景图失败', 3000);
                    }
                };
                
                // 7. 触发文件选择
                input.click();
            },

             'select-all-photos': () => {
                const currentAlbumItems = memoryCache.album.items.filter(p => p.albumId === state.currentAlbumId);
                if (state.photosToDelete.length === currentAlbumItems.length) {
                    state.photosToDelete = [];
                } else {
                    state.photosToDelete = currentAlbumItems.map(p => p.id);
                }
                renderPhotos();
            },
            'delete-selected-photos': async () => {
                if (state.photosToDelete.length === 0) return;
                const itemsToDelete = memoryCache.album.items.filter(p => state.photosToDelete.includes(p.id));
                let photoCount = 0;
                itemsToDelete.forEach(item => { photoCount += item.type === 'photoset' ? item.photos.length : 1; });
                if (confirm(`确定要删除选中的 ${itemsToDelete.length} 个项目(共 ${photoCount} 张照片)吗？`)) {
                    await Promise.all(itemsToDelete.map(item => {
                        if (item.type === 'photoset') return Promise.all(item.photos.map(p => deleteFromGithub(p.path, `Delete photo from set`, p.sha, true)));
                        else return deleteFromGithub(item.path, `Delete photo`, item.sha, true);
                    }));
                    memoryCache.album.items = memoryCache.album.items.filter(p => !state.photosToDelete.includes(p.id));
                    state.photosToDelete = [];
                    renderPhotos(); scheduleSave();
                }
            },
            'save-photo-details': () => { state.isSavingPhoto = true; },
            'skip-photo-details': () => {
                // [修改] 如果当前是多文件上传，点击跳过将跳过后续所有
                if (state.photoUploadQueue.length > 1) {
                    state.skipAllPhotoDetails = true;
                }
                state.isSavingPhoto = false; 
                document.getElementById('photo-title-input').value = ''; 
                document.getElementById('photo-desc-input').value = '';
            },

            'open-item': (target) => {
                const itemId = parseInt(target.closest('[data-item-id]').dataset.itemId, 10);
                 if (state.isPhotoManageMode) {
                    const index = state.photosToDelete.indexOf(itemId);
                    if (index > -1) state.photosToDelete.splice(index, 1);
                    else state.photosToDelete.push(itemId);
                    renderPhotos();
                    return;
                }
                const itemsInAlbum = memoryCache.album.items.filter(p => p.albumId === state.currentAlbumId).sort((a,b) => b.timestamp - a.timestamp);
                const itemIndex = itemsInAlbum.findIndex(p => p.id === itemId);
                openPhotoViewer(itemsInAlbum, itemIndex);
            },
            'close-viewer': () => closePhotoViewer(),
            'prev-photo': () => changePhotoInViewer(-1),
            'next-photo': () => changePhotoInViewer(1),

            'move-selected-photos': () => {
                if (state.photosToDelete.length === 0) {
                    alert('请先选择要移动的照片。');
                    return;
                }
                const destSelector = document.getElementById('album-destination-selector');
                destSelector.innerHTML = '';
                memoryCache.album.folders.forEach(folder => {
                    if (folder.id !== state.currentAlbumId) {
                        const option = document.createElement('option');
                        option.value = folder.id;
                        option.textContent = folder.name;
                        destSelector.appendChild(option);
                    }
                });

                if (destSelector.options.length === 0) {
                    alert('没有其他相册可以移动。');
                    return;
                }
                document.getElementById('movePhotosModal').classList.add('show');
            },
            'close-move-modal': () => {
                document.getElementById('movePhotosModal').classList.remove('show');
            },
            
            'back-to-hub': () => {
                // [V2 优化] 在返回主页前，先退出所有管理和搜索模式
                if (state.isMemoManageMode) actions['toggle-memo-manage'](ui.modal.querySelector('[data-action="toggle-memo-manage"]'));
                if (state.isAlbumManageMode) actions['toggle-album-manage'](ui.modal.querySelector('[data-action="toggle-album-manage"]'));
                // [V2 新增] 退出全局搜索模式
                if (document.getElementById('global-memo-search-input').style.display !== 'none') {
                    actions['toggle-global-memo-search']();
                }

                showPage('hub-view'); 
                state.currentSection = null; 
                document.getElementById('memory-modal-title').textContent = '记忆'; 
            },

            'back-to-memo-folders': () => {
                if (document.getElementById('note-editor-view').classList.contains('active')) {
                   actions['cancel-note']();
                } else {
                   // [V2 优化] 在返回文件夹列表前，退出笔记管理和局部搜索模式
                   if (state.isNoteManageMode) {
                        actions['toggle-note-manage'](ui.modal.querySelector('[data-action="toggle-note-manage"]'));
                   }
                   // [V2 新增] 退出局部搜索模式
                   if (document.getElementById('local-memo-search-input').style.display !== 'none') {
                        actions['toggle-local-memo-search']();
                   }
                   showView('folder-view', 'memo-section'); state.currentMemoFolderId = null;
                }
            },

            // --- [新增] 备忘录搜索相关逻辑 ---
            'toggle-global-memo-search': () => {

                const titleEl = document.querySelector('#folder-view .page-header .title');
                const controlsEl = document.querySelector('#folder-view .header-controls');
                const searchInput = document.getElementById('global-memo-search-input');
                const cancelBtn = document.getElementById('global-memo-search-cancel');

                const isSearching = searchInput.style.display !== 'none';
                if (isSearching) {
                    // 退出搜索模式
                    titleEl.style.display = 'block';
                    controlsEl.style.display = 'flex';
                    searchInput.style.display = 'none';
                    cancelBtn.style.display = 'none';
                    searchInput.value = '';
                    renderMemoFolders(); // 恢复文件夹列表
                } else {
                    // 进入搜索模式
                    titleEl.style.display = 'none';
                    controlsEl.style.display = 'none';
                    searchInput.style.display = 'block';
                    cancelBtn.style.display = 'inline-block';
                    searchInput.focus();
                    // 初始时显示空列表或提示
                    ui.folderList.innerHTML = '<p class="empty-list-placeholder">请输入关键字进行搜索</p>';
                }
            },
            'toggle-local-memo-search': () => {
                const titleEl = document.querySelector('#notes-view .page-header .title');
                const controlsEl = document.querySelector('#notes-view .header-controls');
                const searchInput = document.getElementById('local-memo-search-input');
                const cancelBtn = document.getElementById('local-memo-search-cancel');

                const isSearching = searchInput.style.display !== 'none';
                if (isSearching) {
                    titleEl.style.display = 'block';
                    controlsEl.style.display = 'flex';
                    searchInput.style.display = 'none';
                    cancelBtn.style.display = 'none';
                    searchInput.value = '';
                    renderNotes(); // 恢复当前文件夹的笔记列表
                } else {
                    titleEl.style.display = 'none';
                    controlsEl.style.display = 'none';
                    searchInput.style.display = 'block';
                    cancelBtn.style.display = 'inline-block';
                    searchInput.focus();
                    ui.notesList.innerHTML = '<p class="empty-list-placeholder">请输入关键字进行搜索</p>';
                }
            },

            'confirm-move-photos': () => {
                const destAlbumId = parseInt(document.getElementById('album-destination-selector').value, 10);
                if (!destAlbumId) {
                    alert('无效的目标相册。');
                    return;
                }

                memoryCache.album.items.forEach(item => {
                    if (state.photosToDelete.includes(item.id)) {
                        item.albumId = destAlbumId;
                    }
                });

                state.photosToDelete = [];
                renderPhotos();
                scheduleSave();
                document.getElementById('movePhotosModal').classList.remove('show');
                showTopToast('照片移动成功！', 2000);
            },

            'rename-album': (target) => {
                const albumId = parseInt(target.closest('[data-album-id]').dataset.albumId, 10);
                const album = memoryCache.album.folders.find(f => f.id === albumId);

                if (album) {
                    const newName = prompt('请输入新的相册名称：', album.name);
                    if (newName && newName.trim() !== '' && newName.trim() !== album.name) {
                        album.name = newName.trim();
                        renderAlbumFolders(); // 重新渲染以显示新名称
                        scheduleSave();
                    }
                }
            },

            'wander-global': () => WanderView.start(memoryCache.album.items),
            'wander-local': () => WanderView.start(memoryCache.album.items.filter(p => p.albumId === state.currentAlbumId)),
            'close-wander-view': () => WanderView.close(),
            'toggle-player-collapse': () => WanderView.togglePlayerCollapse(),

            // ============= [ 新增：标签功能Action注册 ] =============
            'open-tag-manager': () => {
                const modal = document.getElementById('tagManagementModal');
                renderTagManager();
                modal.classList.add('show');
            },
            'toggle-tag-binding': (target) => {
                toggleTagBindingMode(target);
            },
            'open-view-by-tag': () => {
                const modal = document.getElementById('viewByTagModal');
                renderViewByTagModal();
                modal.classList.add('show');
            },
            'add-tags-to-selected-files': () => {
                addTagsToSelectedFiles();
            },
            'remove-tags-from-selected-files': () => {
                removeTagsFromSelectedFiles();
            },
            // ============= [ 新增结束 ] =============
        };

        async function processPhotoUploadQueue() {
            if (state.photoUploadQueue.length === 0) return;

            // [解决方案 1] 同步添加一个标记，确保在文件读取期间关闭页面也能触发提示。
            activePhotoUploadXHRs.push("photo_upload_session");

            const totalPhotos = state.photoUploadQueue.length;

            // [解决方案 2] 弹出一个长时存在的顶部提示框作为视觉反馈。
            showTopToast(`正在上传 ${totalPhotos} 张照片...`, 600000); // 持续10分钟或直到任务结束

            state.skipAllPhotoDetails = false;
            let isPhotoSetMode = false;
            const isBatch = totalPhotos > 1;
            ui.photosetToggleContainer.style.display = isBatch ? 'block' : 'none';
            ui.photosetToggle.checked = false;


            let photosetData = { id: Date.now(), albumId: state.currentAlbumId, type: 'photoset', title: '', description: '', timestamp: Date.now(), photos: [] };
            
            try {
                for (let i = 0; i < totalPhotos; i++) {
                    const file = state.photoUploadQueue[i];
                    let title = '';
                    let description = '';
                    
                    let statusText = `上传中 (${i + 1}/${totalPhotos})`;
                    updateStatus(statusText);

                    const shouldShowModal = i === 0 || (!isPhotoSetMode && !state.skipAllPhotoDetails);

                    if (shouldShowModal) {
                        ui.photoDetailsModal.querySelector('#photo-details-modal-title').textContent = '添加照片信息';
                        ui.photoDetailsModal.querySelector('#upload-thumbnail').src = URL.createObjectURL(file);
                        ui.photoDetailsModal.classList.add('show');
                        
                        await new Promise((resolve, reject) => {
                            const saveHandler = () => { state.isSavingPhoto = true; cleanUp(); resolve(); };
                            const skipHandler = () => { actions['skip-photo-details'](); state.isSavingPhoto = false; cleanUp(); resolve(); };
                            // [新增] 定义取消操作，通过 reject 中断 Promise 链
                            const cancelHandler = () => { cleanUp(); reject(new Error('Upload cancelled by user')); };

                            const saveBtn = ui.photoDetailsModal.querySelector('[data-action="save-photo-details"]');
                            const skipBtn = ui.photoDetailsModal.querySelector('[data-action="skip-photo-details"]');
                            // [新增] 获取新添加的取消按钮
                            const cancelBtn = ui.photoDetailsModal.querySelector('[data-action="cancel-photo-upload"]');

                            const cleanUp = () => {
                                saveBtn.removeEventListener('click', saveHandler);
                                skipBtn.removeEventListener('click', skipHandler);
                                cancelBtn.removeEventListener('click', cancelHandler);
                            };
                            
                            saveBtn.addEventListener('click', saveHandler);
                            skipBtn.addEventListener('click', skipHandler);
                            // [新增] 为取消按钮绑定事件
                            cancelBtn.addEventListener('click', cancelHandler);
                        });

                        
                        if (state.isSavingPhoto) {
                            title = document.getElementById('photo-title-input').value.trim();
                            description = document.getElementById('photo-desc-input').value.trim();
                        }
                        if (i === 0) isPhotoSetMode = document.getElementById('create-photoset-toggle').checked;
                        
                        ui.photoDetailsModal.classList.remove('show');
                        document.getElementById('photo-title-input').value = '';
                        document.getElementById('photo-desc-input').value = '';
                    }
                    
                    const photoData = await uploadPhoto(file, (percent) => {
                         // 此回调为空，因为用户不需要进度条
                    });
                    
                    if (photoData) {
                        if (isPhotoSetMode) {
                            photosetData.photos.push(photoData);
                            if (i === 0) {
                                photosetData.title = title;
                                photosetData.description = description;
                            }
                        } else {
                            memoryCache.album.items.push({
                                id: Date.now() + i, albumId: state.currentAlbumId, type: 'photo',
                                title: title, description: description, timestamp: Date.now(),
                                ...photoData
                            });
                        }
                    }
                } // 循环结束

                if (photosetData.photos.length > 0) {
                    memoryCache.album.items.push(photosetData);
                }

                showTopToast('所有照片上传完成!', 3000); // 显示最终成功状态
                updateStatus('上传完成!');
                state.photoUploadQueue = [];
                renderPhotos();
                scheduleSave();

            } catch (error) {
                // [新增] 专门处理用户主动取消的逻辑
                if (error.message === 'Upload cancelled by user') {
                    showTopToast('上传已取消', 2000);
                    updateStatus('已取消');
                    ui.photoDetailsModal.classList.remove('show');
                } else {
                    showTopToast('照片上传失败，请检查网络或配置', 4000);
                    updateStatus('上传失败', true, error.message);
                    alert(error.message);
                }
                state.photoUploadQueue = [];
            } finally {

                // [解决方案 1 清理] 无论成功或失败，都在任务结束后移除标记。
                const index = activePhotoUploadXHRs.indexOf("photo_upload_session");
                if (index > -1) {
                    activePhotoUploadXHRs.splice(index, 1);
                }
            }
        }



        function uploadPhoto(file, onProgressCallback) {
            return new Promise((resolve, reject) => {
                const extension = (file.name.split('.').pop() || 'jpg').toLowerCase();
                const newSafeFileName = `${Date.now()}_${Math.random().toString(36).substring(2, 10)}.${extension}`;
                const path = `${MEMORY_PHOTOS_PATH}${newSafeFileName}`;
                const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;

                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = async () => {
                    const contentB64 = reader.result.split(',')[1];
                    const body = { message: `Upload photo: ${newSafeFileName}`, content: contentB64, branch: 'main' };

                    const xhr = new XMLHttpRequest();
                    activePhotoUploadXHRs.push(xhr); // [核心] 将请求添加到跟踪列表

                    xhr.open('PUT', url, true);
                    xhr.setRequestHeader('Authorization', `token ${GITHUB_CONFIG.token}`);
                    xhr.setRequestHeader('Content-Type', 'application/json');

                    xhr.upload.onprogress = (e) => {
                        if (e.lengthComputable && onProgressCallback) {
                            const percent = (e.loaded / e.total) * 100;
                            onProgressCallback(percent);
                        }
                    };

                    xhr.onload = function() {
                        const index = activePhotoUploadXHRs.indexOf(xhr);
                        if (index > -1) activePhotoUploadXHRs.splice(index, 1);

                        if (this.status >= 200 && this.status < 300) {
                            const response = JSON.parse(this.responseText);
                            resolve({ path: response.content.path, sha: response.content.sha });
                        } else {
                            const errorResponse = JSON.parse(this.responseText);
                            const errorMessage = errorResponse.message || `HTTP ${this.status}`;
                            reject(new Error(`上传照片 ${file.name || '未知文件'} 失败: ${errorMessage}`));
                        }
                    };

                    xhr.onerror = () => {
                        const index = activePhotoUploadXHRs.indexOf(xhr);
                        if (index > -1) activePhotoUploadXHRs.splice(index, 1);
                        reject(new Error("网络错误，上传失败。"));
                    };
                    
                    xhr.onabort = () => {
                        const index = activePhotoUploadXHRs.indexOf(xhr);
                        if (index > -1) activePhotoUploadXHRs.splice(index, 1);
                        reject(new Error("上传已取消。"));
                    };

                    xhr.send(JSON.stringify(body));
                };
                reader.onerror = () => {
                   reject(new Error("读取文件失败！"));
                };
            });
        }


       
              function populateDriveCategorySelector() {
    ui.categorySelector.innerHTML = '<option value="">-- 请选择分类 --</option>';
    if (currentConfig.categories && currentConfig.categories.length > 0) {
        // 直接遍历所有分类并添加到下拉菜单
        currentConfig.categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.name;
            option.textContent = cat.name;
            ui.categorySelector.appendChild(option);
        });
    }
}

         function populateDriveProjectSelector() {
            const selectedCategory = ui.categorySelector.value;
            ui.projectSelector.innerHTML = ''; // 首先清空旧的项目

            // 如果没有选择分类，则隐藏项目选择器
            if (!selectedCategory || selectedCategory === '') {
                ui.projectSelector.classList.add('hidden');
                ui.fileList.innerHTML = ''; // 同时清空文件列表
                ui.fileListStatus.textContent = '请选择一个分类';
                ui.fileListStatus.style.display = 'block';
                return;
            }

            ui.projectSelector.classList.remove('hidden');

            let projectsToShow = [];
            // 如果选择的是"全部"，则合并所有分类下的项目
            if (selectedCategory === '全部') {
                 const allButtons = new Map();
                currentConfig.categories.forEach(cat => {
                    if (cat.buttons) {
                        cat.buttons.forEach(btn => {
                             // 使用 href 作为 key 来去重
                            if (!allButtons.has(btn.href)) {
                                allButtons.set(btn.href, btn);
                            }
                        });
                    }
                });
                projectsToShow = Array.from(allButtons.values());
            } else {
                const category = currentConfig.categories.find(c => c.name === selectedCategory);
                projectsToShow = (category && category.buttons) ? category.buttons : [];
            }


            if (projectsToShow.length > 0) {
                 ui.projectSelector.innerHTML = '<option value="">-- 请选择项目 --</option>'; // 添加一个默认提示选项
                // 遍历所有项目并添加到选择框
                projectsToShow.forEach(btn => {
                    const option = document.createElement('option');
                    // 使用项目的 href 作为唯一标识
                    option.value = btn.href; 
                    option.textContent = btn.text;
                    ui.projectSelector.appendChild(option);
                });
            } else {
                // 如果分类下确实没有任何项目
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "此分类下无任何项目";
                option.disabled = true;
                ui.projectSelector.appendChild(option);
            }
            
            // 切换分类后，主动清空文件列表并更新状态提示
            fetchFilesForSelectedProject();
        }

        function fetchFilesForSelectedProject() {
            const categoryName = ui.categorySelector.value;
            const projectHref = ui.projectSelector.value;
            ui.fileList.innerHTML = '';
            ui.fileListStatus.style.display = 'block';

            if (!projectHref) {
                ui.fileListStatus.textContent = (categoryName && categoryName !== '') ? "该分类下无上传项目" : '请选择一个分类';
                return;
            }
            fetchFilesFromGithubProject(projectHref);
        }

                // [新增] 辅助函数：格式化文件大小
                function formatFileSize(bytes) {
                    if (bytes === 0) return '0 B';
                    if (!bytes) return '...'; // 处理 undefined 或 null 的情况

                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    
                    // 使用 toFixed(1) 来保留一位小数
                    const size = parseFloat((bytes / Math.pow(k, i)).toFixed(1));
                    return `${size} ${sizes[i]}`;
                }

                // [新增] 辅助函数：通过GitHub API获取文件的最后提交日期
                async function getFileCommitDate(filePath) {
                    const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/commits?path=${encodeURIComponent(filePath)}&page=1&per_page=1`;
                    try {
                        const response = await fetch(url, { headers: { 'Authorization': `token ${GITHUB_CONFIG.token}` } });
                        if (!response.ok) return '日期未知';
                        const commits = await response.json();
                        if (commits && commits.length > 0) {
                            const date = new Date(commits[0].commit.committer.date);
                            // 格式化为 年-月-日
                            return date.toISOString().split('T')[0];
                        }
                        return '日期未知';
                    } catch (error) {
                        console.error(`Error fetching commit date for ${filePath}:`, error);
                        return '日期未知';
                    }
                }

                async function fetchFilesFromGithubProject(projectHref) {
                    // [新增] 为本次请求创建一个唯一的令牌
                    const requestToken = Symbol();
                    state.cloudDriveRequestToken = requestToken;

                    ui.fileList.innerHTML = '';
                    ui.fileListStatus.style.display = 'block';

                    const projectConfig = findButtonConfigByHref(projectHref);

                    if (!projectConfig) {
                        ui.fileListStatus.textContent = "请选择一个项目以查看文件";
                        return;
                    }

                    const projectName = projectConfig.text;
                    const folderName = projectName.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-") || `project-${Date.now()}`;
                    const projectPath = `jellyfish_drive/${folderName}`;
                    ui.fileListStatus.textContent = "加载中...";
                    
                    const { data: files, error } = await fetchFromGithub(projectPath);
                    
                    // [新增] 在处理返回数据前，检查令牌是否仍然有效
                    if(state.cloudDriveRequestToken !== requestToken) {
                        console.log("文件夹请求已过期，结果被丢弃。");
                        return; // 如果令牌不匹配（意味着用户已切换项目），则中止函数
                    }

                    if (error) { 
                        ui.fileListStatus.textContent = `加载失败: ${error}`; 
                        return; 
                    }

                    if (!files || files.length === 0) {
                        ui.fileListStatus.textContent = "该项目下暂无文件";
                        return;
                    }
                    
                    // -- 开始修改 --
                    ui.fileListStatus.textContent = "正在获取文件信息...";

                    // 1. 创建一个包含文件和日期的对象数组
                    const filesWithDates = await Promise.all(files.map(async file => {
                        if(state.cloudDriveRequestToken !== requestToken) { return null; } // 检查令牌
                        const date = await getLatestCommitDate(file.path);
                        return { file, date };
                    }));

                    if(state.cloudDriveRequestToken !== requestToken) { return; } // 再次检查令牌

                    // 2. 过滤掉可能因请求取消而产生的null，并按日期从新到旧排序
                    const sortedFiles = filesWithDates
                        .filter(item => item !== null)
                        .sort((a, b) => new Date(b.date) - new Date(a.date))
                        .map(item => item.file); // 提取出排序后的文件对象

                    ui.fileListStatus.style.display = "none";

                    // 3. 遍历排序后的数组来渲染列表
                    for (const file of sortedFiles) {
                        
                        const li = document.createElement("li");
                        
                        const sizeText = formatFileSize(file.size); 
                        const dateText = await getLatestCommitDate(file.path);
                        const metaText = `${sizeText} • ${dateText}`;
                        
                        // [新增] 查找并构建标签HTML
                        const fileTags = memoryCache.driveTags?.[file.path] || [];
                        let tagsHtml = '';
                        if (fileTags.length > 0) {
                            const tagNames = fileTags.map(tagId => {
                                const tag = memoryCache.allTags.find(t => t.id === tagId);
                                return tag ? tag.name : null;
                            }).filter(Boolean);
                            
                            // [核心修改] 将容器从 div 改为 span，使其成为行内元素
                            tagsHtml = `<span class="file-tags">${tagNames.map(name => `<span class="file-tag-item">${name}</span>`).join('')}</span>`;
                        }

                        // [核心修改] 调整HTML结构，将meta和tags放在一个容器里以便对齐
                        li.innerHTML = `<input type="checkbox" class="file-manage-checkbox" data-path="${file.path}">
                                        <div class="file-info">
                                            <div class="file-main-info">
                                                <span class="file-name">${file.name}</span>
                                                <div class="file-meta-tags-wrapper">
                                                    <span class="file-meta" data-path="${file.path}">${metaText}</span>
                                                    ${tagsHtml}
                                                </div>
                                            </div>
                                        </div>
                                        <button class="delete-btn" data-sha="${file.sha}">&times;</button>`;

                        ui.fileList.appendChild(li);

                        
                        li.querySelector(".file-info").addEventListener("click", () => forceDownload(file.path, file.name, li));
                        li.querySelector(".delete-btn").addEventListener("click", () => deleteFile(file.path, file.sha, li));
                    }
                }

        async function getLatestCommitDate(e){const t=`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/commits?path=${encodeURIComponent(e)}&page=1&per_page=1`;try{const n=await fetch(t,{headers:{"Authorization":`token ${GITHUB_CONFIG.token}`},cache:"no-cache"});if(!n.ok)return(new Date(0)).toISOString().split('T')[0];const o=await n.json();return o[0]?.commit.committer.date.split('T')[0]||(new Date(0)).toISOString().split('T')[0]}catch(n){return console.error(`Error fetching commit date for ${e}:`,n),(new Date(0)).toISOString().split('T')[0]}}async function deleteFile(e,t,n){
    const originalFileName = n.querySelector(".file-name").textContent;
    if(!confirm(`确定要永久删除文件 "${originalFileName}" 吗？`))return;
    
    // --- [新增功能] ---
    const fileNameSpan = n.querySelector(".file-name");
    const deleteButton = n.querySelector(".delete-btn");
    fileNameSpan.textContent = "正在删除...";
    deleteButton.style.display = "none"; // 隐藏删除按钮
    n.style.pointerEvents = "none"; // 禁止重复点击
    n.style.opacity="0.7";
    // --- [新增结束] ---
    
    try{ 
        const success = await deleteFromGithub(e, `Delete file: ${e}`, t); 
        if (success) { 
            n.remove(); 
            if(ui.fileList.children.length === 0) { 
                ui.fileListStatus.textContent = '该文件夹下暂无文件'; 
                ui.fileListStatus.style.display = 'block'; 
            } 
        } else { 
            // --- [优化] 恢复状态 ---
            fileNameSpan.textContent = originalFileName;
            deleteButton.style.display = "flex";
            n.style.pointerEvents = "auto";
            n.style.opacity = "1";
            // --- [优化结束] ---
        } 
    } catch(err) { 
         // --- [优化] 恢复状态 ---
         fileNameSpan.textContent = originalFileName;
         deleteButton.style.display = "flex";
         n.style.pointerEvents = "auto";
         n.style.opacity = "1";
         // --- [优化结束] ---
    }
}

        async function forceDownload(path, filename, el) {
            const fileNameSpan = el.querySelector(".file-name");
            const originalText = fileNameSpan.textContent;
            el.style.pointerEvents = "none";

            try {
                const xhr = new XMLHttpRequest();
                const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;
                xhr.open('GET', url, true);
                xhr.setRequestHeader('Authorization', `token ${GITHUB_CONFIG.token}`);
                xhr.setRequestHeader('Accept', 'application/vnd.github.v3.raw');
                xhr.responseType = 'blob';

                let lastProgressText = '';
                xhr.onprogress = (event) => {
                    let newProgressText = '正在下载...';
                    if (event.lengthComputable) {
                        const percentComplete = Math.round((event.loaded / event.total) * 100);
                        newProgressText = `下载中... ${percentComplete}%`;
                    }
                    if (newProgressText !== lastProgressText) {
                        fileNameSpan.textContent = newProgressText;
                        lastProgressText = newProgressText;
                    }
                };

                xhr.onload = () => {
                    if (xhr.status === 200) {
                        const blob = xhr.response;
                        const blobUrl = URL.createObjectURL(blob);
                        const link = document.createElement("a");
                        link.href = blobUrl;
                        link.download = filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(blobUrl);
                        fileNameSpan.textContent = "下载完成";
                    } else {
                        fileNameSpan.textContent = "下载失败";
                        alert(`下载失败: ${xhr.statusText}`);
                    }
                    
                    setTimeout(() => {
                        fileNameSpan.textContent = originalText;
                        el.style.pointerEvents = "auto";
                    }, 2000);
                };

                xhr.onerror = async () => {
                    fileNameSpan.textContent = "下载错误";
                    alert(await handleApiError("下载文件", new Error("网络错误")));
                    setTimeout(() => {
                        fileNameSpan.textContent = originalText;
                        el.style.pointerEvents = "auto";
                    }, 2000);
                };

                fileNameSpan.textContent = "准备下载...";
                xhr.send();

            } catch (error) {
                alert(await handleApiError("准备下载时出错", error));
                fileNameSpan.textContent = originalText;
                el.style.pointerEvents = "auto";
            }
        }
                async function uploadFile() {
                    if (activeUploadXHR) {
                        if(confirm("当前有文件正在上传，要终止它吗？")) {
                            activeUploadXHR.abort();
                        }
                        return;
                    }
                    if (!checkConfig(true)) return;

                    const selectedProjectHref = ui.projectSelector.value;
                    const file = ui.fileUploader.files[0];
                    let fileName = ui.fileNameInput.value.trim() || (file && file.name);

                    if (!selectedProjectHref || !file || !fileName) { return alert("请选择要上传到的项目、文件，并确保文件名不为空。"); }
                    const projectConfig = findButtonConfigByHref(selectedProjectHref);
                    if (!projectConfig) { return alert("此项目配置无效。"); }

                    const projectName = projectConfig.text;
                    const folderName = projectName.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-");
                    const path = `jellyfish_drive/${folderName}/${fileName}`;
                    const url = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${path}`;

                    // --- [修改] UI 准备 ---
                    let progressToast = null; // 用于管理顶部持久化进度提示框

                    // --- [新增] 创建/更新/销毁 顶部提示框的函数 ---
                    const manageProgressToast = (status, isFinal = false, duration = 3000) => {
                        // 如果是最终状态（成功/失败），但提示框从未被创建（即用户未关闭弹窗），则直接使用标准的 showTopToast
                        if (isFinal && !progressToast) {
                            showTopToast(status, duration);
                            return;
                        }

                        // 如果提示框不存在，则创建它 (仅在非最终状态或模态框关闭后调用)
                        if (!progressToast) {
                            progressToast = document.createElement('div');
                            progressToast.className = 'top-toast';
                            document.body.appendChild(progressToast);
                            // 触发显示动画
                            setTimeout(() => {
                                if (progressToast) progressToast.classList.add('show');
                            }, 50);
                        }

                        // 更新内容
                        progressToast.textContent = status;

                        // 如果是最终状态，安排移除
                        if (isFinal) {
                            setTimeout(() => {
                                if (progressToast) {
                                    progressToast.classList.remove('show');
                                    progressToast.addEventListener('transitionend', () => {
                                        if (progressToast) progressToast.remove();
                                        progressToast = null; // 清理引用
                                    }, { once: true });
                                }
                            }, duration);
                        }
                    };
                    
                    // --- [修改] 监听主上传模态框的关闭 ---
                    const modalObserver = new MutationObserver(mutations => {
                        for (const mutation of mutations) {
                            if (mutation.attributeName === 'class' && !mutation.target.classList.contains('show') && activeUploadXHR) {
                                // 当模态框关闭时，创建顶部持久提示框
                                const currentProgress = parseInt(ui.progressBar.style.width, 10) || 0;
                                manageProgressToast(`上传中... ${currentProgress}%`);
                                modalObserver.disconnect();
                                return;
                            }
                        }
                    });
                    modalObserver.observe(document.getElementById('memoryModal'), { attributes: true });

                    // --- 核心上传逻辑 ---
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = async () => {
                        const contentB64 = reader.result.split(',')[1];
                        const { data: existingFile } = await fetchFromGithub(path);
                        
                        const body = { message: `Upload ${fileName} to Drive`, content: contentB64, branch: 'main', sha: existingFile?.sha };
                        
                        activeUploadXHR = new XMLHttpRequest();
                        activeUploadXHR.open('PUT', url, true);
                        activeUploadXHR.setRequestHeader('Authorization', `token ${GITHUB_CONFIG.token}`);
                        activeUploadXHR.setRequestHeader('Content-Type', 'application/json');
                        
                        const uploadCancelBtn = document.getElementById('upload-cancel-btn');
                        const uploadCancelHandler = () => { if (activeUploadXHR) activeUploadXHR.abort(); };
                        uploadCancelBtn.addEventListener('click', uploadCancelHandler);

                        activeUploadXHR.upload.onprogress = (e) => {
                            if (e.lengthComputable) {
                                const percent = (e.loaded / e.total) * 100;
                                ui.progressBar.style.width = `${percent}%`;
                                // 如果顶部提示框已存在，同步更新进度
                                if(progressToast) {
                                    manageProgressToast(`上传中... ${Math.round(percent)}%`);
                                }
                            }
                        };

                        activeUploadXHR.onload = function() {
                            if (this.status >= 200 && this.status < 300) {
                                manageProgressToast("上传成功！", true, 2000);
                                fetchFilesForSelectedProject();
                                ui.fileUploader.value = "";
                                ui.fileNameInput.value = "";
                                ui.selectedFileName.textContent = '未选择任何文件';
                            } else {
                                const errorMsg = JSON.parse(this.responseText).message || `HTTP ${this.status}`;
                                manageProgressToast(`上传失败`, true, 4000);
                                alert(`上传失败: ${errorMsg}`);
                            }
                            cleanup();
                        };

                        activeUploadXHR.onerror = () => { 
                            manageProgressToast("网络错误", true, 4000);
                            alert("上传失败，请检查网络连接。"); 
                            cleanup(); 
                        };

                        activeUploadXHR.onabort = () => { 
                            manageProgressToast("已取消", true, 2000);
                            cleanup(); 
                        };

                        const cleanup = () => {
                            uploadCancelBtn.removeEventListener('click', uploadCancelHandler);
                            ui.progressContainer.style.display = 'none';
                            activeUploadXHR = null;
                            modalObserver.disconnect();
                            // 如果清理时，toast 仍在且不处于最终状态，则立即移除
                            if (progressToast && !progressToast.textContent.includes('成功') && !progressToast.textContent.includes('失败') && !progressToast.textContent.includes('取消')) {
                                progressToast.classList.remove('show');
                                progressToast.addEventListener('transitionend', () => progressToast.remove(), { once: true });
                                progressToast = null;
                            }
                        };

                        ui.progressContainer.style.display = 'flex';
                        ui.progressBar.style.width = '0%';
                        activeUploadXHR.send(JSON.stringify(body));
                    };
                    reader.onerror = () => { alert("读取文件失败！"); };
                }

        // ============= [ 新增：标签功能核心逻辑 ] =============

        let isTagBindingMode = false;

        // 渲染标签管理模态框
        function renderTagManager() {
            const editor = document.getElementById('tag-list-editor');
            editor.innerHTML = '';
            if (!memoryCache.allTags || memoryCache.allTags.length === 0) {
                editor.innerHTML = '<p style="text-align:center; color: #889;">暂无标签</p>';
                return;
            }
            memoryCache.allTags.forEach(tag => {
                const item = document.createElement('div');
                item.className = 'tag-editor-item';
                item.innerHTML = `
                    <span class="tag-name" data-tag-id="${tag.id}">${tag.name}</span>
                    <div class="tag-actions">
                        <button class="rename" data-tag-id="${tag.id}" title="重命名">
                            <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 24 24" style="vertical-align: middle;"><rect x="1" y="20" width="22" height="2" fill="currentColor" stroke-width="0" data-color="color-2"></rect><path d="m18.875,2.125c-1.492-1.493-3.922-1.493-5.414,0L4.079,11.507l-1.354,6.768,6.768-1.354,9.382-9.382c1.493-1.493,1.493-3.921,0-5.414Zm-1.414,4l-.875.875-2.586-2.586.875-.875c.713-.713,1.873-.713,2.586,0s.713,1.873,0,2.586Z" stroke-width="0" fill="currentColor"></path></svg>
                        </button>
                        <button class="delete" data-tag-id="${tag.id}" title="删除">
                            <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 24 24" style="vertical-align: middle;"><path d="m4.458,9l.463,11.125c.067,1.612,1.384,2.875,2.998,2.875h8.163c1.613,0,2.93-1.263,2.998-2.875l.463-11.125H4.458Z" stroke-width="0" fill="currentColor"></path><path d="m16,5V1h-8v4H2v2h20v-2h-6Zm-6-2h4v2h-4v-2Z" fill="currentColor" stroke-width="0" data-color="color-2"></path></svg>
                        </button>
                    </div>
                `;
                editor.appendChild(item);
            });
        }

        // 添加新标签
        async function addNewTag() {
            const input = document.getElementById('newTagNameInput');
            const name = input.value.trim();
            if (!name) {
                alert('标签名不能为空！');
                return;
            }
            if (memoryCache.allTags.some(tag => tag.name === name)) {
                alert('该标签已存在！');
                return;
            }
            memoryCache.allTags.push({ id: Date.now(), name: name });
            await scheduleSave();
            input.value = '';
            renderTagManager();
        }

        // 重命名标签
        async function renameTag(tagId) {
            const tag = memoryCache.allTags.find(t => t.id === tagId);
            if (!tag) return;
            const newName = prompt('请输入新的标签名：', tag.name);
            if (newName && newName.trim() && newName.trim() !== tag.name) {
                if (memoryCache.allTags.some(t => t.name === newName.trim())) {
                    alert('该标签名已存在！');
                    return;
                }
                tag.name = newName.trim();
                await scheduleSave();
                renderTagManager();
                fetchFilesForSelectedProject(); // 刷新文件列表以显示新标签名
            }
        }

        // 删除标签
        async function deleteTag(tagId) {
            const tag = memoryCache.allTags.find(t => t.id === tagId);
            if (!tag) return;
            if (confirm(`确定要删除标签 "${tag.name}" 吗？\n所有文件上的此标签也将被移除。`)) {
                // 从所有标签列表中删除
                memoryCache.allTags = memoryCache.allTags.filter(t => t.id !== tagId);
                // 从所有文件的关联中删除
                for (const path in memoryCache.driveTags) {
                    const index = memoryCache.driveTags[path].indexOf(tagId);
                    if (index > -1) {
                        memoryCache.driveTags[path].splice(index, 1);
                    }
                }
                await scheduleSave();
                renderTagManager();
                fetchFilesForSelectedProject(); // 刷新文件列表
            }
        }
        
        // 切换批量绑定模式
        function toggleTagBindingMode(button) {
            isTagBindingMode = !isTagBindingMode;
            const cloudDriveSection = document.getElementById('cloud-drive-section');
            cloudDriveSection.classList.toggle('tag-binding-active', isTagBindingMode);
            
            document.getElementById('tag-binding-controls').classList.toggle('active', isTagBindingMode);
            button.textContent = isTagBindingMode ? '完成绑定' : '批量绑定标签';
            
            if (isTagBindingMode) {
                populateTagBindingSelector();
            } else {
                // 退出时清空所有选中状态
                document.querySelectorAll('#fileList li.manage-selected').forEach(li => {
                    li.classList.remove('manage-selected');
                    li.querySelector('.file-manage-checkbox').checked = false;
                });
            }
        }

        // 填充批量绑定下拉框
        function populateTagBindingSelector() {
            const selector = document.getElementById('tag-binding-selector');
            selector.innerHTML = '<option value="">-- 选择要操作的标签 --</option>';
            memoryCache.allTags.forEach(tag => {
                selector.innerHTML += `<option value="${tag.id}">${tag.name}</option>`;
            });
        }
        
        // [重构] 渲染按标签查看模态框
        function renderViewByTagModal() {
            const container = document.getElementById('tag-filter-selector');
            container.innerHTML = ''; // 清空容器

            if (!memoryCache.allTags || memoryCache.allTags.length === 0) {
                container.innerHTML = '<p style="color: #889;">没有可供筛选的标签。</p>';
                return;
            }

            // 创建可点击的按钮
            memoryCache.allTags.forEach(tag => {
                const button = document.createElement('button');
                button.className = 'filter-tag-option';
                button.textContent = tag.name;
                button.dataset.tagId = tag.id;
                container.appendChild(button);
            });
        }
        
        // [重构] 执行按标签查看的查询
        async function performViewByTag(tagIds) {
            ui.fileList.innerHTML = '';
            ui.fileListStatus.style.display = 'block';
            ui.fileListStatus.textContent = '正在根据标签筛选文件...';
            
            const filesWithMatchingTags = [];
            
            // 遍历 driveTags 映射，效率更高
            for (const path in memoryCache.driveTags) {
                const fileTags = memoryCache.driveTags[path];
                // 检查文件是否包含所有被选中的标签 (AND逻辑)
                const hasAllTags = tagIds.every(id => fileTags.includes(id));
                
                if (hasAllTags) {
                    // 模拟一个 file 对象，以便复用渲染逻辑
                    const fileName = path.split('/').pop();
                    filesWithMatchingTags.push({
                        name: fileName,
                        path: path,
                        // size 和 date 暂时无法直接获取，可以留空或显示占位符
                        size: null, 
                        sha: null // SHA 也未知，删除等操作将不可用
                    });
                }
            }

            if (filesWithMatchingTags.length === 0) {
                ui.fileListStatus.textContent = '未找到包含所有选中标签的文件。';
                return;
            }

            ui.fileListStatus.style.display = 'none';

            // 直接在主文件列表区域渲染结果
            for (const file of filesWithMatchingTags) {
                const li = document.createElement("li");
                const metaText = '大小未知 • 日期未知';

                li.innerHTML = `<div class="file-info">
                                    <div class="file-main-info">
                                        <span class="file-name">${file.name}</span>
                                        <div class="file-meta-tags-wrapper">
                                            <span class="file-meta">${metaText}</span>
                                        </div>
                                    </div>
                                </div>
                                <!-- 筛选结果不支持删除 -->`;
                
                li.querySelector(".file-info").addEventListener("click", () => forceDownload(file.path, file.name, li));
                ui.fileList.appendChild(li);
            }
        }

        // 批量为文件添加标签
        async function addTagsToSelectedFiles() {
            const selectedTagId = parseInt(document.getElementById('tag-binding-selector').value, 10);
            if (!selectedTagId) {
                alert('请先选择一个要添加的标签！');
                return;
            }

            const selectedFilePaths = Array.from(document.querySelectorAll('.file-manage-checkbox:checked')).map(cb => cb.dataset.path);
            if (selectedFilePaths.length === 0) {
                alert('请先选择要操作的文件！');
                return;
            }
            
            selectedFilePaths.forEach(path => {
                if (!memoryCache.driveTags[path]) {
                    memoryCache.driveTags[path] = [];
                }
                if (!memoryCache.driveTags[path].includes(selectedTagId)) {
                    memoryCache.driveTags[path].push(selectedTagId);
                }
            });

            await scheduleSave();
            fetchFilesForSelectedProject(); // 刷新列表以显示新标签
            showTopToast('标签添加成功！', 2000);
        }

        // 批量为文件移除标签
        async function removeTagsFromSelectedFiles() {
            const selectedTagId = parseInt(document.getElementById('tag-binding-selector').value, 10);
            if (!selectedTagId) {
                alert('请先选择一个要移除的标签！');
                return;
            }

            const selectedFilePaths = Array.from(document.querySelectorAll('.file-manage-checkbox:checked')).map(cb => cb.dataset.path);
            if (selectedFilePaths.length === 0) {
                alert('请先选择要操作的文件！');
                return;
            }

            selectedFilePaths.forEach(path => {
                if (memoryCache.driveTags[path]) {
                    const index = memoryCache.driveTags[path].indexOf(selectedTagId);
                    if (index > -1) {
                        memoryCache.driveTags[path].splice(index, 1);
                    }
                }
            });

            await scheduleSave();
            fetchFilesForSelectedProject();
            showTopToast('标签移除成功！', 2000);
        }


        // ============= [ 新增结束 ] =============

        return {
// [修改] 优化加载逻辑，避免白屏
open: async () => {
    if (!checkConfig(true)) { 
        document.getElementById('settingsModal').classList.add('show'); 
        return; 
    }
    
    ui.modal.classList.add('show');

    // [V2 新增] 每次打开时，重置所有内部状态，确保从主页开始
    if (document.getElementById('global-memo-search-input').style.display !== 'none') {
        actions['toggle-global-memo-search']();
    }
    if (document.getElementById('local-memo-search-input').style.display !== 'none') {
        actions['toggle-local-memo-search']();
    }
    if (state.isMemoManageMode) actions['toggle-memo-manage'](ui.modal.querySelector('[data-action="toggle-memo-manage"]'));
    if (state.isAlbumManageMode) actions['toggle-album-manage'](ui.modal.querySelector('[data-action="toggle-album-manage"]'));
    if (state.isNoteManageMode) actions['toggle-note-manage'](ui.modal.querySelector('[data-action="toggle-note-manage"]'));
    if (state.isPhotoManageMode) actions['toggle-photo-manage'](ui.modal.querySelector('[data-action="toggle-photo-manage"]'));

    document.getElementById('memory-modal-title').textContent = '记忆';
    showPage('hub-view');

    // [核心修复] 移除缓存判断，强制每次打开都重新加载数据，并显示加载状态
    const hubView = document.getElementById('hub-view');
    const originalHubContent = hubView.innerHTML;
    // 只有在hub-view内部没有加载提示时才添加，避免重复
    if (!hubView.querySelector('.empty-list-placeholder')) {
        hubView.innerHTML = '<p class="empty-list-placeholder" style="margin-top: 100px; font-size: 16px;">正在从云端加载记忆模块...</p>';
    }
    
    // 强制重新同步数据
    await syncWithGithub();
    
    // 加载完成后恢复 hub-view 的原始内容
    hubView.innerHTML = originalHubContent;
},

            init: () => {
                 photoObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            const src = img.dataset.src;
                            if (src) {
                                getSecureFileUrl(src).then(url => {
                                    if(url) img.src = url;
                                });
                            }
                            observer.unobserve(img);
                        }
                    });
                }, { root: ui.photoList, rootMargin: "0px 0px 200px 0px" });


                // [核心修改] 重构事件监听以支持长按
                let pressTimer = null;
                let isLongPress = false;
                const FAB_ADD_NOTE_SELECTOR = '.fab[data-action="add-note"]';

                const startPress = (e) => {
                    const fabButton = e.target.closest(FAB_ADD_NOTE_SELECTOR);
                    if (fabButton) {
                        isLongPress = false;
                        pressTimer = setTimeout(() => {
                            isLongPress = true;
                            // 打开导入模态框
                            openMemoImportModal();
                        }, 500); // 500毫秒定义为长按
                    }
                };

                const cancelPress = (e) => {
                    clearTimeout(pressTimer);
                };

                const endPress = (e) => {
                    clearTimeout(pressTimer);
                    const fabButton = e.target.closest(FAB_ADD_NOTE_SELECTOR);
                    if (fabButton && isLongPress) {
                        e.preventDefault(); // 阻止默认的点击事件
                        e.stopPropagation(); // 阻止事件冒泡
                    }
                };

                ui.appContainer.addEventListener('mousedown', startPress);
                ui.appContainer.addEventListener('touchstart', startPress);
                ui.appContainer.addEventListener('mouseup', endPress);
                ui.appContainer.addEventListener('touchend', endPress);
                ui.appContainer.addEventListener('mouseleave', cancelPress, true);


                ui.appContainer.addEventListener('click', e => {
                    const target = e.target.closest('[data-action]');
                    if(target && target.matches(FAB_ADD_NOTE_SELECTOR) && isLongPress) {
                        isLongPress = false; // 重置标志
                        return; // 如果是长按触发的点击，则忽略
                    }
                    
                    if (target && actions[target.dataset.action]) {
                        // 如果是复制备忘录按钮，阻止事件冒泡，防止打开备忘录
                        if (target.dataset.action === 'copy-note-text') {
                             e.stopPropagation(); // 阻止事件冒泡到父级的 open-note 处理器
                        }
                        actions[target.dataset.action](target, e); // 传递完整的事件对象
                    }
                });
                // [重构] 可向下展开的标签栏交互
                const tagActionsToggleBtn = document.getElementById('tag-actions-toggle-btn');
                const tagActionsWrapper = document.getElementById('tag-actions-wrapper');
                if (tagActionsToggleBtn && tagActionsWrapper) {
                    tagActionsToggleBtn.addEventListener('click', () => {
                        // 直接给按钮和容器切换 .expanded 类
                        tagActionsToggleBtn.classList.toggle('expanded');
                        tagActionsWrapper.classList.toggle('expanded');
                    });
                }


                // [新增] 为“按标签查看”模态框添加事件委托
                const viewByTagModal = document.getElementById('viewByTagModal');
                if (viewByTagModal) {
                    viewByTagModal.addEventListener('click', async (e) => {
                        const target = e.target;
                        
                        // 1. 处理标签按钮的点击事件
                        if (target.classList.contains('filter-tag-option')) {
                            // 切换选中状态
                            target.classList.toggle('selected');
                            return; // 处理完毕，直接返回
                        }

                        // 2. 处理“确认”按钮的点击事件
                        if (target.dataset.action === 'confirm-tag-filter') {
                            const selectedTags = Array.from(viewByTagModal.querySelectorAll('.filter-tag-option.selected'));
                            const selectedTagIds = selectedTags.map(tag => parseInt(tag.dataset.tagId, 10));

                            if (selectedTagIds.length > 0) {
                                // 调用筛选函数
                                await performViewByTag(selectedTagIds);
                            } else {
                                // 如果没有选择标签，则恢复显示当前项目的文件列表
                                fetchFilesForSelectedProject();
                            }
                            
                            // 关闭模态框
                            viewByTagModal.classList.remove('show');
                            return; // 处理完毕
                        }

                        // 3. 处理“重置”按钮的点击事件
                        if (target.dataset.action === 'reset-tag-filter') {
                            // 移除所有标签的选中状态
                            viewByTagModal.querySelectorAll('.filter-tag-option.selected').forEach(tag => {
                                tag.classList.remove('selected');
                            });
                            // 恢复显示当前项目的文件列表
                            fetchFilesForSelectedProject();
                            return; // 处理完毕
                        }
                    });
                }

                // [新增] 打开导入备忘录模态框的函数 (V3 - 优化UI和格式处理)
                const openMemoImportModal = () => {
                    const modal = document.getElementById('memoImportModal'); 
                    const fileInput = modal.querySelector('#memoFilePicker');
                    const filePickerBtn = modal.querySelector('#memoFilePickerBtn');
                    const statusEl = modal.querySelector('#memoImportStatus');
                    const fileListEl = modal.querySelector('#memo-import-file-list'); // [新增] 获取文件名列表容器
                    const progressContainer = modal.querySelector('#memoImportProgressContainer');
                    const progressBar = modal.querySelector('#memoImportProgressBar');
                    const cancelImportBtn = modal.querySelector('#memoImportCancelBtn');
                    const confirmImportBtn = modal.querySelector('#confirmMemoImportBtn');
                    const cancelModalBtn = modal.querySelector('[data-action="close-memo-import-modal"]');
                    const closeIconBtn = modal.querySelector('.close-btn');

                    let activeFileReading = true;
                    
                    const closeModal = () => {
                        activeFileReading = false;
                        modal.classList.remove('show');
                    }
                    
                    // 重置UI
                    fileInput.value = '';
                    statusEl.textContent = '最多可选择 20 个文件';
                    fileListEl.innerHTML = ''; // [新增] 清空文件名列表
                    fileListEl.style.display = 'none'; // [新增] 隐藏列表容器
                    confirmImportBtn.disabled = true;
                    progressContainer.style.display = 'none';
                    progressBar.style.width = '0%';
                    activeFileReading = true;
                    
                    cancelModalBtn.onclick = closeModal;
                    closeIconBtn.onclick = closeModal;

                    filePickerBtn.onclick = () => fileInput.click();
                    
                    // 文件选择后的处理 (已修改)
                    fileInput.onchange = (e) => {
                        const files = e.target.files;
                        fileListEl.innerHTML = ''; // 每次选择都清空

                        if (files.length > 20) {
                            alert("一次最多只能选择20个文件！");
                            fileInput.value = '';
                            fileListEl.style.display = 'none';
                            statusEl.textContent = '最多可选择 20 个文件';
                            return;
                        }
                        if (files.length > 0) {
                            statusEl.textContent = `已选择 ${files.length} 个文件`;
                            // [Requirement 1 实现] 遍历文件并显示文件名
                            Array.from(files).forEach(file => {
                                const fileEl = document.createElement('div');
                                fileEl.className = 'memo-import-filename';
                                fileEl.textContent = file.name;
                                fileListEl.appendChild(fileEl);
                            });
                            fileListEl.style.display = 'block';
                            confirmImportBtn.disabled = false;
                        } else {
                            statusEl.textContent = '最多可选择 20 个文件';
                            fileListEl.style.display = 'none';
                            confirmImportBtn.disabled = true;
                        }
                    };
                    
                    // 绑定 "导入" 按钮 (已修改)
                    confirmImportBtn.onclick = async () => {
                        const files = fileInput.files;
                        if (files.length === 0) return;
                        
                        confirmImportBtn.disabled = true;
                        cancelModalBtn.style.display = 'none';
                        progressContainer.style.display = 'flex';
                        statusEl.textContent = '准备解析文件...';

                        const cancelImportHandler = () => {
                           activeFileReading = false;
                           showTopToast('导入已取消', 2000);
                           closeModal();
                        };
                        cancelImportBtn.addEventListener('click', cancelImportHandler, { once: true });
                        
                        const filePromises = Array.from(files).map((file, index) => {
                            return new Promise(async (resolve, reject) => {
                                if (!activeFileReading) return reject(new Error('Cancelled'));
                                
                                try {
                                    statusEl.textContent = `正在解析: ${file.name}`;
                                    const reader = new FileReader();
                                    const getFileNameWithoutExtension = (fileName) => fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
                                    const title = getFileNameWithoutExtension(file.name);
                                    let content = '';
                                    if (file.name.endsWith('.docx')) {
                                        const arrayBuffer = await new Promise((res, rej) => {
                                            reader.onload = e => res(e.target.result); reader.onerror = rej; reader.readAsArrayBuffer(file);
                                        });
                                        const result = await mammoth.extractRawText({ arrayBuffer });
                                        content = result.value;
                                    } else {
                                        content = await new Promise((res, rej) => {
                                            reader.onload = e => res(e.target.result); reader.onerror = rej; reader.readAsText(file, 'UTF-8');
                                        });
                                    }
                                     // [Requirement 2 实现] 格式化文本以保留换行和空格
                                    let formattedContent = content
                                        .replace(/&/g, "&amp;")
                                        .replace(/</g, "&lt;")
                                        .replace(/>/g, "&gt;")
                                        .replace(/"/g, "&quot;")
                                        .replace(/'/g, "&#039;")
                                        .replace(/\r\n/g, '\n') // 统一换行符
                                        .replace(/  /g, ' &nbsp;') // 替换连续空格
                                        .replace(/\n/g, '<br>'); // 替换换行为<br>


                                    resolve({ title, content: formattedContent });

                                } catch (err) {
                                    console.error(`解析文件 ${file.name} 失败:`, err);
                                    reject(new Error(`无法解析 ${file.name}`));
                                } finally {
                                     const progressPercent = ((index + 1) / files.length) * 100;
                                     progressBar.style.width = `${progressPercent}%`;
                                }
                            });
                        });
                        
                        try {
                            const results = await Promise.all(filePromises);
                            
                            statusEl.textContent = '解析完成，正在保存...';
                            const now = Date.now();
                            results.forEach((result, index) => {
                                memoryCache.memo.notes.push({ id: now + index, folderId: state.currentMemoFolderId, title: result.title, content: result.content, timestamp: now + index, isPinned: false });
                            });
                            
                            await scheduleSave();
                            renderNotes();
                            showTopToast(`${results.length} 篇备忘录导入成功！`, 2500);
                            closeModal();
                        } catch (error) {
                            if (error.message !== 'Cancelled') {
                               alert(error.message);
                            }
                        } finally {
                           confirmImportBtn.disabled = false;
                           cancelModalBtn.style.display = 'block';
                           progressContainer.style.display = 'none';
                           cancelImportBtn.removeEventListener('click', cancelImportHandler);
                        }
                    };

                    modal.classList.add('show');
                };


                // [新增] 长图双击缩放逻辑
                const viewerImg = ui.photoViewer.querySelector('#viewer-img');
                const viewerImgContainer = ui.photoViewer.querySelector('#viewer-img-container');
                
                viewerImgContainer.addEventListener('dblclick', () => {
                    const isCurrentlyZoomed = viewerImgContainer.classList.contains('zoomed-long');
                    
                    if (isCurrentlyZoomed) {
                        viewerImgContainer.classList.remove('zoomed-long');
                        viewerImgContainer.scrollTop = 0; 
                        return;
                    }

                    const isLongImage = viewerImg.naturalHeight > viewerImg.naturalWidth;
                    const isTallerThanContainer = viewerImg.naturalHeight > viewerImgContainer.clientHeight;

                    if (isLongImage && isTallerThanContainer) {
                        viewerImgContainer.classList.add('zoomed-long');
                    } else {
                        showTopToast('此图片无需放大', 2000);
                    }
                });

                // [新增] 备忘录富文本编辑器逻辑 v2
                const editor = document.getElementById('note-content-editor');
                const toolbar = document.querySelector('.memo-toolbar');

                const updateToolbarState = () => {
                    const commands = ['bold', 'italic', 'underline', 'strikeThrough'];
                    commands.forEach(command => {
                        const button = toolbar.querySelector(`[data-command="${command}"]`);
                        if (button) {
                            button.classList.toggle('active', document.queryCommandState(command));
                        }
                    });
                };

                editor.addEventListener('keyup', updateToolbarState);
                editor.addEventListener('mouseup', updateToolbarState);

                // [V2 新增] 监听输入事件，用于自动清理空的代码块
                editor.addEventListener('input', () => {
                   // 使用 setTimeout 延迟执行，确保在 DOM 更新后进行检查
                   setTimeout(() => {
                        const codeBlocks = editor.querySelectorAll('.memo-code-block pre');
                        codeBlocks.forEach(pre => {
                            // 如果 pre 标签内没有文本内容（注意 trim() 以处理空白字符）
                            if (pre.textContent.trim() === '') {
                                const parentBlock = pre.closest('.memo-code-block');
                                if (parentBlock) {
                                    parentBlock.remove(); // 移除整个代码块
                                }
                            }
                        });
                   }, 0);
                });

                // V3 - 跟踪字体大小调整的目标元素
                let fontSizeTargetSpan = null;
                const fontSizePopup = document.getElementById('fontSizeSliderPopup');
                const fontSizeSlider = document.getElementById('fontSizeSlider');

                // V3 - 监听全局点击，用于关闭字号弹窗
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('[data-command="fontSize"]') && !e.target.closest('#fontSizeSliderPopup')) {
                        if (fontSizePopup.style.display === 'block') {
                            fontSizePopup.style.display = 'none';
                        }
                    }
                }, true);
                
                // V3 最终 BUG 修复: 更健壮的统一事件处理器
                toolbar.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.toolbar-btn');
                    if (!button) return;

                    const command = button.dataset.command;
                    editor.focus();

                    // 【核心修复】将所有标准 execCommand 命令明确分组，避免 switch 的未知问题
                    const standardCommands = ['bold', 'italic', 'underline', 'strikeThrough'];
                    
                    if (standardCommands.includes(command)) {
                        document.execCommand(command, false, null);
                    } else if (command === 'fontSize') {
                        if (fontSizePopup.style.display === 'block') {
                            fontSizePopup.style.display = 'none';
                            return;
                        }

                        const selection = window.getSelection();
                        if (!selection.rangeCount || selection.isCollapsed) {
                            showTopToast('请先选择一段您想调整大小的文字', 2500);
                            return;
                        }
                        const range = selection.getRangeAt(0);
                        const parentElement = range.commonAncestorContainer.nodeType === 3
                            ? range.commonAncestorContainer.parentNode
                            : range.commonAncestorContainer;

                        if (parentElement.nodeName === 'SPAN' && parentElement.style.fontSize) {
                            fontSizeTargetSpan = parentElement;
                            fontSizeSlider.value = parseInt(parentElement.style.fontSize, 10) || 16;
                        } else {
                            fontSizeTargetSpan = document.createElement('span');
                            try {
                                range.surroundContents(fontSizeTargetSpan);
                            } catch (err) {
                                showTopToast('选区无法调整，请勿跨段落选择', 2500);
                                return;
                            }
                        }
                        fontSizePopup.style.display = 'block';
                    } else if (command === 'copyContent') {
                        const contentContainer = document.getElementById('note-content-editor');
                        const plainText = contentContainer.innerText;
                        if (plainText.trim()) {
                            navigator.clipboard.writeText(plainText)
                                .then(() => showTopToast('正文已复制到剪贴板！', 2000))
                                .catch(() => showTopToast('复制失败，请重试', 2000));
                        } else {
                            showTopToast('备忘录内容为空', 2000);
                        }
                    } else if (command === 'createCodeBlock') {
                        const selectionCode = window.getSelection();
                        if (!selectionCode.rangeCount || selectionCode.isCollapsed) return showTopToast('请先选择一段文字', 2000);
                        const rangeCode = selectionCode.getRangeAt(0);
                        const selectedText = rangeCode.toString();
                        const codeBlock = document.createElement('div');
                        codeBlock.className = 'memo-code-block';
                        const pre = document.createElement('pre');
                        pre.textContent = selectedText;
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'code-block-copy-btn';
                        copyBtn.contentEditable = 'false';
                        copyBtn.textContent = '❏';
                        copyBtn.title = '复制';
                        codeBlock.appendChild(copyBtn);
                        codeBlock.appendChild(pre);
                        rangeCode.deleteContents();
                        const fragment = document.createDocumentFragment();
                        fragment.appendChild(codeBlock);
                        fragment.appendChild(document.createTextNode('\u200B'));
                        rangeCode.insertNode(fragment);
                        rangeCode.setStartAfter(codeBlock.nextSibling);
                        rangeCode.collapse(true);
                        selectionCode.removeAllRanges();
                        selectionCode.addRange(rangeCode);
                    } else if (command === 'todo') {
                        document.execCommand('insertUnorderedList', false, null);
                        setTimeout(() => {
                            editor.querySelectorAll('li').forEach(li => {
                                if (!li.querySelector('.todo-text')) {
                                    const textNode = document.createTextNode(li.textContent.trim());
                                    const span = document.createElement('span');
                                    span.className = 'todo-text';
                                    span.appendChild(textNode);
                                    li.innerHTML = '';
                                    li.appendChild(span);
                                }
                            });
                        }, 50);
                    }

                    setTimeout(updateToolbarState, 0);
                });

                // 编辑器内部的点击事件（待办清单完成/代码块复制）
                editor.addEventListener('click', (e) => {
                    const li = e.target.closest('li');
                    const copyBtn = e.target.closest('.code-block-copy-btn');
                    
                    if (li && e.target.tagName !== 'SPAN' && !e.target.closest('.todo-text')) {
                        // 核心修复1：只有当点击的不是文本SPAN时，才切换状态
                        li.classList.toggle('completed');
                        
                        // 核心修复2：确保取消勾选时删除线也被移除
                        const textSpan = li.querySelector('.todo-text');
                        if (textSpan) {
                            if (li.classList.contains('completed')) {
                                textSpan.style.textDecoration = 'line-through';
                                textSpan.style.opacity = '0.6';
                            } else {
                                textSpan.style.textDecoration = 'none';
                                textSpan.style.opacity = '1';
                            }
                        }
                    } else if (copyBtn) {
                        const codeBlock = copyBtn.closest('.memo-code-block');
                        const textToCopy = codeBlock.querySelector('pre')?.textContent || '';
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            const originalText = copyBtn.textContent;
                            copyBtn.textContent = '✓';
                            setTimeout(() => { copyBtn.textContent = originalText; }, 1500);
                        }).catch(() => showTopToast('复制失败', 2000));
                    }
                    updateToolbarState();
                });
                // 为字号滑块添加事件监听
                fontSizeSlider.addEventListener('input', () => {
                    if (fontSizeTargetSpan) {
                        fontSizeTargetSpan.style.fontSize = `${fontSizeSlider.value}px`;
                    }
                });

                ui.folderModal.addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target) actions[target.dataset.action]?.(); });
                ui.photoDetailsModal.addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target) actions[target.dataset.action]?.(); });
                ui.photoViewer.addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target) actions[target.dataset.action]?.(); });
                document.getElementById('movePhotosModal').addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target && actions[target.dataset.action]) actions[target.dataset.action](target); });
            document.getElementById('moveNotesModal').addEventListener('click', e => { const target = e.target.closest('[data-action]'); if (target && actions[target.dataset.action]) actions[target.dataset.action](target);                 });

                // ★★★ [新增] 备忘录回顶按钮逻辑 ★★★
                const noteEditorContent = document.querySelector('#memoryModal .editor-content');
                const backToTopBtn = document.getElementById('memo-back-to-top');

                if (noteEditorContent && backToTopBtn) {
                    // 监听编辑区域的滚动事件
                    noteEditorContent.addEventListener('scroll', () => {
                        // 如果滚动距离大于300像素，显示按钮，否则隐藏
                        if (noteEditorContent.scrollTop > 300) {
                            backToTopBtn.classList.add('show');
                        } else {
                            backToTopBtn.classList.remove('show');
                        }
                    });

                    // 为按钮添加点击事件，实现平滑滚动回顶部
                    backToTopBtn.addEventListener('click', () => {
                        noteEditorContent.scrollTo({
                            top: 0,
                            behavior: 'smooth'
                        });
                    });
                }
                // ★★★ [新增结束] ★★★

                ui.photoUploader.addEventListener('change', e => {
                    if (!e.target.files.length) return;
                    state.photoUploadQueue = Array.from(e.target.files);
                    processPhotoUploadQueue();
                    e.target.value = '';
                });
                // ============= [ 新增：为标签管理模态框按钮绑定事件 ] =============
                const tagManagementModal = document.getElementById('tagManagementModal');
                if (tagManagementModal) {
                    tagManagementModal.addEventListener('click', async (e) => {
                        const actionTarget = e.target.closest('[id], [data-tag-id]');
                        if (!actionTarget) return;

                        // 添加新标签
                        if (actionTarget.id === 'addNewTagBtn') {
                            await addNewTag();
                        }
                        // 重命名标签
                        else if (actionTarget.classList.contains('rename')) {
                            const tagId = parseInt(actionTarget.dataset.tagId, 10);
                            await renameTag(tagId);
                        }
                        // 删除标签
                        else if (actionTarget.classList.contains('delete')) {
                            const tagId = parseInt(actionTarget.dataset.tagId, 10);
                            await deleteTag(tagId);
                        }
                        // 点击标签名本身也可以触发重命名
                        else if (actionTarget.classList.contains('tag-name')) {
                             const tagId = parseInt(actionTarget.dataset.tagId, 10);
                             await renameTag(tagId);
                        }
                    });
                }
                // ============= [ 新增结束 ] =============

                // --- [新增] 备忘录搜索输入和取消事件绑定 ---

                // --- [新增] 备忘录搜索输入和取消事件绑定 ---
                const globalSearchInput = document.getElementById('global-memo-search-input');
                const localSearchInput = document.getElementById('local-memo-search-input');

                const performSearch = (keyword, scope) => {
                    if (!keyword) {
                        if (scope === 'global') renderMemoFolders(); // 如果是全局搜索，清空时恢复文件夹视图
                        else renderNotes(); // 局部搜索清空时恢复笔记列表
                        return;
                    }

                    keyword = keyword.toLowerCase();
                    let notesToSearch = memoryCache.memo.notes;
                    
                    // 如果是局部搜索，先过滤出当前文件夹的笔记
                    if (scope === 'local') {
                        notesToSearch = notesToSearch.filter(n => n.folderId === state.currentMemoFolderId);
                    }

                    const rankedResults = notesToSearch.map(note => {
                        const title = (note.title || '').toLowerCase();
                        // 移除HTML标签以搜索纯文本内容
                        const plainContent = (note.content || '').replace(/<[^>]*>/g, '').toLowerCase(); 
                        
                        let score = 0;
                        if (title.includes(keyword)) score += 2;
                        if (plainContent.includes(keyword)) score += 1;
                        
                        return score > 0 ? { ...note, score } : null;
                    }).filter(Boolean).sort((a, b) => b.score - a.score);

                    const container = (scope === 'global') ? ui.folderList : ui.notesList;
                    
                    if (rankedResults.length === 0) {
                        container.innerHTML = '<p class="empty-list-placeholder">未找到相关备忘录</p>';
                        return;
                    }
                    
                    // 将文件夹网格布局改为单列列表布局
                    container.style.gridTemplateColumns = '1fr'; 
                    container.innerHTML = ''; // 清空容器

                    rankedResults.forEach(note => {
                        const el = document.createElement('div');
                        el.className = 'note-item';
                        el.dataset.noteId = note.id;
                        el.dataset.action = "open-note";
                         // [新增] 在搜索结果中，也存储其原始 folderId，以便打开笔记后能正确返回
                        el.dataset.originalFolderId = note.folderId; 

                        const preview = (note.content || '').substring(0, 100).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        const date = new Date(note.timestamp).toLocaleDateString('zh-CN');
                        el.innerHTML = `<div class="note-content-area"><div class="note-title">${note.title || '无标题'}</div><div class="note-preview">${preview || '没有内容'}</div><div class="note-timestamp">${date}</div></div>`;
                        container.appendChild(el);
                    });
                };
                
                globalSearchInput.addEventListener('input', () => performSearch(globalSearchInput.value, 'global'));
                localSearchInput.addEventListener('input', () => performSearch(localSearchInput.value, 'local'));

                document.getElementById('global-memo-search-cancel').addEventListener('click', actions['toggle-global-memo-search']);
                document.getElementById('local-memo-search-cancel').addEventListener('click', actions['toggle-local-memo-search']);

                // [修改] 优化 open-note 逻辑以支持从搜索结果中打开
                // 重写 open-note 行为以处理搜索结果
                const originalOpenNote = actions['open-note'];
                actions['open-note'] = (target) => {
                    const fromSearch = target.closest('[data-original-folder-id]');
                    if (fromSearch) {
                        state.currentMemoFolderId = parseInt(fromSearch.dataset.originalFolderId, 10);
                        // 从搜索结果打开笔记时，确保非管理模式
                        if(state.isNoteManageMode) {
                            actions['toggle-note-manage'](ui.modal.querySelector('[data-action="toggle-note-manage"]'));
                        }
                    }
                    originalOpenNote(target);
                }

                // [V2 优化] 为照片下载按钮添加平台差异化处理
                document.getElementById('download-photo-btn').addEventListener('click', async (e) => {
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

                    // 如果是 iOS 设备，则执行分享逻辑
                    if (isIOS) {
                        // 阻止 a 标签的默认下载行为
                        e.preventDefault();
                        
                        // 检查浏览器是否支持 Web Share API 的文件分享功能
                        if (!navigator.share || !navigator.canShare) {
                            alert('您的浏览器不支持分享功能。');
                            return;
                        }

                        const shareBtn = e.currentTarget;
                        const imageUrl = shareBtn.href;
                        const title = shareBtn.download || '分享的图片';

                        try {
                            showTopToast('正在准备图片...', 60000); 

                            const response = await fetch(imageUrl);
                            if (!response.ok) throw new Error('下载图片失败，无法分享。');
                            
                            const blob = await response.blob();
                            const file = new File([blob], title, { type: blob.type });

                            const existingToast = document.querySelector('.top-toast');
                            if (existingToast) existingToast.remove();

                            if (navigator.canShare({ files: [file] })) {
                                await navigator.share({
                                    files: [file],
                                    title: title,
                                    text: '来自 Jellyfish Island 的分享'
                                });
                            } else {
                                alert('您的浏览器不支持分享此类型的文件。');
                            }
                        } catch (error) {
                            const existingToast = document.querySelector('.top-toast');
                            if (existingToast) existingToast.remove();
                            if (error.name !== 'AbortError') {
                                console.error('分享图片时出错:', error);
                                alert('无法分享图片: ' + error.message);
                            }
                        }
                    }
                    // 如果是安卓或电脑设备，不执行任何操作，让<a>标签的download属性自然生效
                    else {
                        // 此处无需代码，浏览器将自动处理下载
                        return;
                    }
                });

                ui.photosetToggle.addEventListener('change', e => {
                    const isSet = e.target.checked;
                    const button = ui.photoDetailsModal.querySelector('[data-action="save-photo-details"]');
                    const skipBtn = ui.photoDetailsModal.querySelector('[data-action="skip-photo-details"]');
                    button.textContent = '保存';
                    skipBtn.style.display = isSet ? 'none' : 'inline-block';
                });
                document.querySelector('[data-action="close-wander-view"]').addEventListener('click', actions['close-wander-view']);
                document.querySelector('[data-action="toggle-player-collapse"]').addEventListener('click', actions['toggle-player-collapse']);
                ui.categorySelector.addEventListener("change", () => {
   populateDriveProjectSelector();
   fetchFilesForSelectedProject();
});

                ui.projectSelector.addEventListener("change", fetchFilesForSelectedProject);
                ui.selectFileBtn.addEventListener('click', () => ui.fileUploader.click());
                ui.fileUploader.addEventListener("change",()=>{ if(ui.fileUploader.files.length>0){ const file = ui.fileUploader.files[0]; ui.fileNameInput.value=file.name; ui.selectedFileName.textContent = file.name; } else { ui.selectedFileName.textContent = "未选择任何文件"; }});
                ui.uploadBtn.addEventListener("click", uploadFile);
            },
            getAlbumItems: () => memoryCache ? memoryCache.album.items : [],
            scheduleSave,
            // [新增] 供外部调用的 sha 更新函数
            updateSha: (newSha) => {
                memoryDataSha = newSha;
            }
        };

    })();
    // ===== [END] MEMORY APP LOGIC =====


    // ===== [START] WANDER VIEW 4.0 LOGIC (Architecture) =====
    const WanderView = (() => {
        const MUSIC_DATA_PATH = 'memory/music_data.json';
        const MUSIC_FILES_PATH = 'memory/music/';
        let musicDataSha = null;

        const ui = {
            overlay: document.getElementById('wanderViewOverlay'),
            photoContainer: document.getElementById('wander-photo-container'),
            img: document.getElementById('wander-img'),
            title: document.getElementById('wander-title'),
            description: document.getElementById('wander-description'),
            player: {
                container: document.getElementById('wander-music-player'),
                audio: document.getElementById('audio-player'),
                playPauseBtn: document.getElementById('play-pause-btn'),
                prevBtn: document.getElementById('prev-song-btn'),
                nextBtn: document.getElementById('next-song-btn'),
                loopBtn: document.getElementById('loop-mode-btn'),
                playlistBtn: document.getElementById('playlist-btn'),
                displayArea: document.getElementById('player-display-area'),
                progressTrack: document.querySelector('.player-progress-track'),
                progressBar: document.getElementById('player-progress-bar'),
                progressHandle: document.getElementById('player-progress-handle'),
                popover: document.getElementById('playlist-popover'),
                popoverPlaylist: document.getElementById('popover-playlist-ul'),
                openSettingsBtn: document.getElementById('open-music-settings-btn'),
                handle: document.querySelector('.player-handle-container'),
                mainContent: document.querySelector('.wander-main-content'),
            },
            settingsModal: {
                modal: document.getElementById('musicSettingsModal'),
                uploadMusicBtn: document.getElementById('upload-music-btn'),
                uploadLrcBtn: document.getElementById('upload-lrc-btn'),
                musicStatus: document.getElementById('upload-music-status'),
                lrcStatus: document.getElementById('upload-lrc-status'),
                renameInput: document.getElementById('music-rename-input'),
                confirmUploadBtn: document.getElementById('confirm-upload-btn'),
                musicFilePicker: document.getElementById('music-file-picker'),
                lrcFilePicker: document.getElementById('lrc-file-picker'),
                playlistContainer: document.getElementById('music-playlist-container'),
                autoplayToggle: document.getElementById('autoplay-toggle'),
            }
        };

        const state = {
            items: [], currentIndex: -1,
            playlist: [], currentTrackIndex: -1, isPlaying: false,
            loopMode: 'all',
            lyrics: [],
            lastWanderedItemId: null,
            pendingMusicFile: null,
            pendingLrcFile: null,
            isSeeking: false,
        };
        
        const icons = {
            play: '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>',
            pause: '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>',
            prev: '<svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6 8.5 6V6z"/></svg>',
            next: '<svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>',
            loopAll: '<svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>',
            loopOne: '<svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v3H13z"/></svg>',
            shuffle: '<svg viewBox="0 0 24 24"><path d="M10.59 9.17 5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg>',
            musicNote: '<svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>',
            delete: '<svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>',
            list: '<svg viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>',
        };

        function start(items) {
            if (!items || items.length === 0) { alert('没有可漫游的项目。请先在“记忆”中添加一些照片。'); return; }
            let itemPool = [...items];
            if (itemPool.length > 1 && state.lastWanderedItemId) {
                itemPool = itemPool.filter(p => p.id !== state.lastWanderedItemId);
            }
             if (itemPool.length > 0) {
                for ( let i = itemPool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [itemPool[i], itemPool[j]] = [itemPool[j], itemPool[i]];
                }
             } else {
                itemPool = [...items];
             }

            state.items = itemPool;
            state.currentIndex = 0;
            state.lastWanderedItemId = itemPool[0]?.id;
            
            ui.overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
            updateContent();
            loadCloudPlaylist().then(() => {
                if (ui.settingsModal.autoplayToggle.checked && state.playlist.length > 0) {
                    playTrack(state.currentTrackIndex > -1 ? state.currentTrackIndex : 0);
                }
            });
        }

        function close() {
            ui.overlay.classList.remove('active');
            document.body.style.overflow = '';
            if (state.isPlaying) {
                ui.player.audio.pause();
                ui.player.audio.src = ''; // Force stop
            }
        }

        async function updateContent() {
            const item = state.items[state.currentIndex];
            if (!item) return;

            let photo, title, description;
            if (item.type === 'photoset') {
                item.internalIndex = item.internalIndex ?? 0;
                photo = item.photos[item.internalIndex];
                title = item.title;
                description = item.description;
            } else {
                photo = item;
                title = item.title;
                description = item.description;
            }
            
            ui.img.src = ""; 
            ui.img.alt = "渲染中...";

            const photoUrl = await getSecureFileUrl(photo.path);
            ui.img.src = photoUrl;
            ui.img.alt = title || description || "Wander view image";
            ui.photoContainer.style.setProperty('--blur-bg', `url(${photoUrl})`);
            ui.title.textContent = title || '';
            ui.description.textContent = description || '';
        }
        
        async function changePhoto(direction) {
            const item = state.items[state.currentIndex];
            if (item.type === 'photoset' && !ui.photoContainer.classList.contains('fullscreen')) {
                let nextIndex = (item.internalIndex || 0) + direction;
                if (nextIndex >= 0 && nextIndex < item.photos.length) {
                    item.internalIndex = nextIndex;
                } else {
                    changeItem(direction);
                }
            } else {
                changeItem(direction);
            }
            await updateContent();
         }

        function changeItem(direction) {
            let nextIndex = state.currentIndex + direction;
            if (nextIndex < 0) nextIndex = state.items.length - 1;
            if (nextIndex >= state.items.length) nextIndex = 0;
            
            state.currentIndex = nextIndex;
            const newItem = state.items[state.currentIndex];
            if (newItem.type === 'photoset') {
                newItem.internalIndex = direction > 0 ? 0 : newItem.photos.length - 1;
            }
        }
        
        function initGestures() {
            let startX = 0;
            ui.photoContainer.addEventListener('touchstart', e => { startX = e.touches[0].clientX; }, { passive: true });
            ui.photoContainer.addEventListener('touchend', e => {
                const endX = e.changedTouches[0].clientX;
                const swipeDiff = endX - startX;
                if (Math.abs(swipeDiff) < 50) return;
                
                if (ui.photoContainer.classList.contains('fullscreen') && state.items[state.currentIndex].type !== 'photoset') {
                    changePhoto(swipeDiff > 0 ? -1 : 1);
                } else {
                    changePhoto(swipeDiff > 0 ? -1 : 1);
                }
            }, { passive: true });
        }

        function initPlayer() {
            const p = ui.player;
            const sm = ui.settingsModal;

            p.playPauseBtn.innerHTML = icons.play; p.prevBtn.innerHTML = icons.prev; p.nextBtn.innerHTML = icons.next; p.loopBtn.innerHTML = icons.loopAll; p.playlistBtn.innerHTML = icons.list; p.openSettingsBtn.innerHTML = icons.musicNote;
            
            p.playlistBtn.addEventListener('click', (e) => { e.stopPropagation(); p.popover.classList.toggle('active'); });
            p.openSettingsBtn.addEventListener('click', () => { p.popover.classList.remove('active'); sm.modal.classList.add('show'); });
            document.addEventListener('click', (e) => { if (!p.container.contains(e.target)) p.popover.classList.remove('active'); });

            sm.uploadMusicBtn.addEventListener('click', () => sm.musicFilePicker.click());
            sm.uploadLrcBtn.addEventListener('click', () => sm.lrcFilePicker.click());
            sm.musicFilePicker.addEventListener('change', (e) => {
                if(e.target.files.length > 0) {
                    state.pendingMusicFile = e.target.files[0];
                    sm.musicStatus.textContent = state.pendingMusicFile.name;
                    sm.renameInput.value = state.pendingMusicFile.name.replace(/\.[^/.]+$/, "");
                }
            });
            sm.lrcFilePicker.addEventListener('change', (e) => {
                if(e.target.files.length > 0) {
                    state.pendingLrcFile = e.target.files[0];
                    sm.lrcStatus.textContent = state.pendingLrcFile.name;
                }
            });
            sm.confirmUploadBtn.addEventListener('click', () => {
                if (sm.confirmUploadBtn.textContent.startsWith("取消上传")) {
                    if(activeUploadXHR) activeUploadXHR.abort();
                } else {
                    uploadPendingFiles();
                }
            });

            p.playPauseBtn.addEventListener('click', () => {
                if (state.playlist.length === 0) { sm.modal.classList.add('show'); return; }
                if(state.currentTrackIndex === -1) playTrack(0);
                else if (state.isPlaying) p.audio.pause(); 
                else p.audio.play();
            });
            p.audio.onplay = () => { state.isPlaying = true; p.playPauseBtn.innerHTML = icons.pause; p.playPauseBtn.title = "暂停"; p.progressHandle.classList.add('playing'); };
            p.audio.onpause = () => { state.isPlaying = false; p.playPauseBtn.innerHTML = icons.play; p.playPauseBtn.title = "播放"; p.progressHandle.classList.remove('playing'); };
            p.audio.onloadedmetadata = () => updateProgressUI();
            p.audio.ontimeupdate = () => {
                if (!state.isSeeking) updateProgressUI();
                updateLyrics(p.audio.currentTime);
            };
            p.audio.onended = () => nextTrack(false);
            p.nextBtn.addEventListener('click', () => nextTrack(true));
            p.prevBtn.addEventListener('click', () => {
                if (state.playlist.length === 0) return;
                let newIndex = state.currentTrackIndex - 1;
                if (newIndex < 0) newIndex = state.playlist.length - 1;
                playTrack(newIndex);
            });
             p.loopBtn.addEventListener('click', () => {
                if (state.loopMode === 'all') { state.loopMode = 'one'; p.loopBtn.innerHTML = icons.loopOne; p.loopBtn.title = "单曲循环"; }
                else if (state.loopMode === 'one') { state.loopMode = 'shuffle'; p.loopBtn.innerHTML = icons.shuffle; p.loopBtn.title = "随机播放"; }
                else { state.loopMode = 'all'; p.loopBtn.innerHTML = icons.loopAll; p.loopBtn.title = "列表循环"; }
            });
            sm.autoplayToggle.checked = localStorage.getItem('wanderAutoplay') === 'true';
            sm.autoplayToggle.addEventListener('change', (e) => {
                localStorage.setItem('wanderAutoplay', e.target.checked);
            });
            
            const onSeek = (e) => {
                const trackRect = p.progressTrack.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let percent = (clientX - trackRect.left) / trackRect.width;
                percent = Math.max(0, Math.min(1, percent));
                
                if (p.audio.duration) {
                    p.audio.currentTime = percent * p.audio.duration;
                    updateProgressUI();
                }
            };
            const startSeek = (e) => { state.isSeeking = true; onSeek(e); };
            const endSeek = () => { state.isSeeking = false; };
            p.progressTrack.addEventListener('pointerdown', startSeek);
            document.addEventListener('pointermove', (e) => { if(state.isSeeking) onSeek(e); });
            document.addEventListener('pointerup', endSeek);
        }
        
        function updateProgressUI() {
            const p = ui.player;
            if (!p.audio.duration) return;
            const percent = (p.audio.currentTime / p.audio.duration) * 100;
            p.progressBar.style.width = `${percent}%`;
            p.progressHandle.style.left = `${percent}%`;
        }

        function nextTrack(manual = false) {
            if (state.playlist.length === 0) return;
            if (state.playlist.length === 1 && state.loopMode !== 'none') { playTrack(0); return; }
            if (state.loopMode === 'one' && !manual) { playTrack(state.currentTrackIndex); return; }
            
            let newIndex;
            if (state.loopMode === 'shuffle') {
                do { newIndex = Math.floor(Math.random() * state.playlist.length); } while (state.playlist.length > 1 && newIndex === state.currentTrackIndex);
            } else {
                newIndex = state.currentTrackIndex + 1;
                if (newIndex >= state.playlist.length) {
                    if (state.loopMode === 'all') newIndex = 0;
                    else { ui.player.audio.pause(); return; }
                }
            }
            playTrack(newIndex);
        }

        async function playTrack(index) {
            if (index < 0 || index >= state.playlist.length) return;
            state.currentTrackIndex = index;
            const track = state.playlist[index];
            
            ui.player.displayArea.innerHTML = `<div class="music-loader"></div>`;
            const audioUrl = await getSecureFileUrl(track.musicPath);

            if (!audioUrl) {
                console.error(`Failed to get URL for track: ${track.displayName}`);
                alert(`无法播放歌曲 "${track.displayName}"，请检查文件是否存在或网络连接。`);
                ui.player.displayArea.innerHTML = `<div class="song-title-display">${track.displayName} (加载失败)</div>`;
                nextTrack(true);
                return;
            }
            ui.player.audio.src = audioUrl;
            
            state.lyrics = [];

            const displaySongTitle = () => {
                ui.player.displayArea.innerHTML = `<div class="song-title-display">${track.displayName}</div>`;
            };

            if (track.lrcPath) {
                try {
                    const lrcUrl = await getSecureFileUrl(track.lrcPath);
                    const response = await fetch(lrcUrl);
                    if(response.ok) {
                        const lrcText = await response.text();
                        state.lyrics = parseLRC(lrcText);
                    }
                } catch (e) { 
                    console.error("Could not fetch lyrics", e); 
                    state.lyrics = [];
                }
            }
            
            if(state.lyrics && state.lyrics.length > 0) {
                 ui.player.displayArea.innerHTML = `<div id="lyrics-container"><ul id="lyrics-ul"></ul></div>`;
                 renderLyrics();
                 updateLyrics(0);
            } else {
                 displaySongTitle();
            }
            
            ui.player.audio.play().catch(e => console.error("Audio play failed:", e));
            renderPlaylists();
        }

        function renderPlaylists() {
            renderPlaylistInPopover();
            renderPlaylistInModal();
        }

        function renderPlaylistInPopover() {
            ui.player.popoverPlaylist.innerHTML = state.playlist.map((track, index) => 
                `<li data-index="${index}" class="${index === state.currentTrackIndex ? 'playing' : ''}">
                    <span class="playlist-item-name">${track.displayName}</span>
                 </li>`
            ).join('');
            ui.player.popoverPlaylist.querySelectorAll('li').forEach(el => {
                el.addEventListener('click', (e) => {
                    playTrack(parseInt(e.currentTarget.dataset.index, 10));
                    ui.player.popover.classList.remove('active');
                });
            });
        }

        function renderPlaylistInModal() {
            const sm = ui.settingsModal;
            sm.playlistContainer.innerHTML = state.playlist.map((track, index) => 
                `<li data-index="${index}" class="${index === state.currentTrackIndex ? 'playing' : ''}">
                    <span class="song-name">${track.displayName}</span>
                    <button class="player-btn delete-song-btn" data-index="${index}">${icons.delete}</button>
                 </li>`
            ).join('');

            sm.playlistContainer.querySelectorAll('.song-name').forEach(el => {
                el.addEventListener('click', (e) => {
                    const songIndex = parseInt(e.currentTarget.parentElement.dataset.index, 10);
                    sm.modal.classList.remove('show');
                    start(MemoryApp.getAlbumItems());
                    setTimeout(() => playTrack(songIndex), 500);
                });
            });
            sm.playlistContainer.querySelectorAll('.delete-song-btn').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteSong(parseInt(e.currentTarget.dataset.index, 10));
                });
            });
        }

        async function deleteSong(index) {
            const track = state.playlist[index];
            if (!confirm(`确定要从云端永久删除 "${track.displayName}" 吗？`)) return;

            try {
                await deleteFromGithub(track.musicPath, `Delete music: ${track.musicPath}`, track.musicSha);
                if (track.lrcPath && track.lrcSha) {
                    await deleteFromGithub(track.lrcPath, `Delete lyric: ${track.lrcPath}`, track.lrcSha);
                }
                state.playlist.splice(index, 1);
                await saveCloudPlaylist();
                
                if (index === state.currentTrackIndex) {
                    ui.player.audio.pause();
                    ui.player.audio.src = '';
                    state.currentTrackIndex = -1;
                    if (state.playlist.length > 0) playTrack(0);
                } else if (index < state.currentTrackIndex) {
                    state.currentTrackIndex--;
                }
                renderPlaylists();

            } catch(e) { alert(await handleApiError("删除歌曲", e)); }
        }

        function parseLRC(lrc) {
            const lines = lrc.split('\n');
            const result = [];
            const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
            for (const line of lines) {
                const matches = [...line.matchAll(timeRegex)];
                const text = line.substring(line.lastIndexOf(']') + 1).trim();
                
                if (text && matches.length > 0) {
                    for (const match of matches) {
                        const minutes = parseInt(match[1], 10);
                        const seconds = parseInt(match[2], 10);
                        const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
                        const time = minutes * 60 + seconds + milliseconds / 1000;
                        result.push({ time, text });
                    }
                }
            }
            return result.sort((a, b) => a.time - b.time);
        }

        function renderLyrics() {
            const lyricsUl = document.getElementById('lyrics-ul');
            if(!lyricsUl) return;
            lyricsUl.innerHTML = state.lyrics.map(line => `<li>${line.text}</li>`).join('');
        }

        function updateLyrics(currentTime) {
            if (state.lyrics.length === 0) return;
            const lyricsUl = document.getElementById('lyrics-ul');
            if(!lyricsUl) return;

            let currentLineIndex = -1;
            for (let i = 0; i < state.lyrics.length; i++) {
                if (currentTime >= state.lyrics[i].time) {
                    currentLineIndex = i;
                } else {
                    break;
                }
            }
            
            if (currentLineIndex > -1) {
                const allLi = lyricsUl.children;
                if (allLi[currentLineIndex] && !allLi[currentLineIndex].classList.contains('current-lyric')) {
                    const oldLi = lyricsUl.querySelector('.current-lyric');
                    if(oldLi) oldLi.classList.remove('current-lyric');
                    allLi[currentLineIndex].classList.add('current-lyric');
                    
                    const offset = allLi[currentLineIndex].offsetTop;
                    lyricsUl.style.transform = `translateY(-${offset}px)`;
                }
            }
        }
        
        async function loadCloudPlaylist() {
            const { data } = await fetchFromGithub(MUSIC_DATA_PATH);
            if (data && data.content) {
                state.playlist = JSON.parse(b64_to_utf8(data.content));
                musicDataSha = data.sha;
            } else {
                state.playlist = [];
                musicDataSha = null;
            }
            renderPlaylists();
        }

       async function saveCloudPlaylist() {
            const content = utf8_to_b64(JSON.stringify(state.playlist, null, 2));
            const result = await saveToGithub(MUSIC_DATA_PATH, content, 'Update music playlist', musicDataSha);
            if (result.sha) {
                musicDataSha = result.sha;
            }
        }

        async function uploadPendingFiles() {
            const sm = ui.settingsModal;
            if (!state.pendingMusicFile) { alert("请先选择一个音乐文件。"); return; }
            const displayName = sm.renameInput.value.trim();
            if (!displayName) { alert("请输入歌曲名称。"); return; }
            
            // [核心修正] 从原始文件名动态获取扩展名，而不是写死.mp3
            const originalExtension = state.pendingMusicFile.name.slice(state.pendingMusicFile.name.lastIndexOf('.'));
            const finalMusicFilename = displayName + originalExtension;
            const finalLrcFilename = displayName + '.lrc';
            sm.confirmUploadBtn.textContent = "取消上传 (0%)";
            sm.confirmUploadBtn.disabled = false;
            try {
                const musicPath = MUSIC_FILES_PATH + finalMusicFilename;
                const musicResult = await uploadFileViaGitData({ file: state.pendingMusicFile, path: musicPath, commitMessage: `Upload music: ${finalMusicFilename}`, onProgress: (percent) => { if (percent < 100) sm.confirmUploadBtn.textContent = `取消上传 (${Math.round(percent)}%)`; else sm.confirmUploadBtn.textContent = '正在处理...'; } });
                let lrcResult = { sha: null, path: null };
                if (state.pendingLrcFile) { try { const lrcPath = MUSIC_FILES_PATH + finalLrcFilename; lrcResult = await uploadFileViaGitData({ file: state.pendingLrcFile, path: lrcPath, commitMessage: `Upload lyric: ${finalLrcFilename}`, onProgress: () => {} }); } catch(e) { alert("歌词文件上传失败，但音乐已成功上传。"); } }
                
                const existingIndex = state.playlist.findIndex(t => t.displayName === displayName);
                const newTrackData = { id: Date.now(), displayName, musicPath: musicResult.path, musicSha: musicResult.sha, lrcPath: lrcResult.path, lrcSha: lrcResult.sha };
                if (existingIndex > -1) state.playlist[existingIndex] = { ...state.playlist[existingIndex], ...newTrackData }; else state.playlist.push(newTrackData);
                
                await saveCloudPlaylist();
                renderPlaylists();
                resetUploadForm();
                alert(`"${displayName}" 上传成功！`);
            } catch (e) { if (e.message !== "上传已取消。") alert(await handleApiError(`上传歌曲 ${displayName}`, e)); } 
            finally { sm.confirmUploadBtn.textContent = "确认上传"; sm.confirmUploadBtn.disabled = false; }
        }

        function resetUploadForm() {
            const sm = ui.settingsModal;
            state.pendingMusicFile = null; state.pendingLrcFile = null;
            sm.musicFilePicker.value = ''; sm.lrcFilePicker.value = '';
            sm.musicStatus.textContent = ''; sm.lrcStatus.textContent = '';
            sm.renameInput.value = '';
        }

        return {
            init: () => {
                ui.img.addEventListener('click', () => { const isFullscreen = ui.photoContainer.classList.toggle('fullscreen'); ui.player.container.classList.toggle('hidden', isFullscreen); });
                initGestures(); initPlayer();
            }, start, close,
            updateTheme: () => {
                const isDark = document.body.classList.contains('dark-mode');
                ui.overlay.style.background = isDark ? 'var(--bg-night-element)' : 'var(--bg-day-element)';
                ui.overlay.style.color = isDark ? 'var(--text-night)' : 'var(--text-day)';
            },
            togglePlayerCollapse: () => {
                const isCollapsed = ui.player.container.classList.toggle('collapsed');
                ui.player.mainContent.style.transform = isCollapsed ? `translateY(-${ui.player.container.offsetHeight - 30}px)` : 'translateY(0)';
            },
        };
    })();
    // ===== [END] WANDER VIEW LOGIC =====
    
    async function getSecureFileUrl(path) {
        if (!path) return '';

        // 1. 优先从本次会话的内存缓存中读取 (最快)
        if (secureFileCache.has(path)) {
            const cached = secureFileCache.get(path);
            // 如果缓存的是一个Promise，等待它完成
            if (typeof cached.then === 'function') {
                return await cached;
            }
            return cached;
        }
        
        // 2. 如果内存中没有，则尝试从 IndexedDB 持久化缓存中读取
        try {
            const cachedBlob = await ImageCacheDB.get(path);
            if (cachedBlob) {
                const blobUrl = URL.createObjectURL(cachedBlob);
                secureFileCache.set(path, blobUrl); // 存入内存缓存，方便本次会话后续快速访问
                return blobUrl;
            }
        } catch (e) {
            console.warn(`从 IndexedDB 读取缓存失败:`, e);
        }

        // 3. 如果 IndexedDB 中也没有，则发起网络请求
        const fetchPromise = new Promise(async (resolve) => {
            try {
                if (!path.startsWith('projects/') && !path.startsWith('memory/')) {
                    resolve(path);
                    return;
                }
                
                const { data: metaData, error: metaError } = await fetchFromGithub(path, 'contents');
                if (metaError || !metaData || !metaData.sha) {
                    throw new Error(`Could not get metadata for ${path}. ${metaError || 'No SHA found.'}`);
                }

                const { data: blobData, error: blobError } = await fetchFromGithub(`blobs/${metaData.sha}`, 'git');
                if (blobError || !blobData || !blobData.content) {
                    throw new Error(`Could not get blob content for ${path}. ${blobError || 'No content returned.'}`);
                }
                
                const contentType = path.toLowerCase().endsWith('.html') || path.toLowerCase().endsWith('.htm') ? 'text/html' : (metaData.type || 'application/octet-stream');
                const blob = b64toBlob(blobData.content, contentType);

                // 4. [核心] 将获取到的数据存入 IndexedDB
                ImageCacheDB.set(path, blob).catch(e => console.warn('存入IndexedDB失败:', e));

                const blobUrl = URL.createObjectURL(blob);
                secureFileCache.set(path, blobUrl); // 确保内存缓存也被更新
                resolve(blobUrl);

            } catch (error) {
                console.error(`获取安全文件URL失败: ${path}`, error);
                secureFileCache.delete(path); // 从内存缓存中移除失败的条目
                resolve(''); // 返回空字符串，防止界面出错
            }
        });

        // 将Promise存入内存缓存，防止对同一资源发起重复网络请求
        secureFileCache.set(path, fetchPromise);
        return await fetchPromise;
    }

        function checkAppUpdate() {
            const helpPage = document.getElementById('help-page-2');
            if (!helpPage) return;

            const currentUpdateHash = simpleHash(helpPage.innerHTML.trim());
            const lastSeenUpdateHash = localStorage.getItem('lastSeenUpdateHash');
            const updateLogIndicator = document.getElementById('update-log-indicator');

            if (String(currentUpdateHash) !== lastSeenUpdateHash) {
                document.getElementById('helpBtn').classList.add('has-update');
                if (updateLogIndicator) updateLogIndicator.classList.add('show');
            } else {
                if (updateLogIndicator) updateLogIndicator.classList.remove('show');
            }
        }


 window.addEventListener('load', async () => {
        try {
            await ImageCacheDB.init();
        } catch (e) {
            console.error(e);
            alert("本地图片缓存功能启动失败，图片加载速度可能会变慢。");
        }
        loadGithubConfig();
        checkAppUpdate();
        await loadInitialData();
        setupModals();
        BaiduNetdisk.init(); // <-- 将初始化调用移到这里
        MemoryApp.init();
        WanderView.init();
        setupBgImageManager();

        setupColorSync(colorModal.pickerD1, colorModal.hexD1, 'dayColor1'); 
        setupColorSync(colorModal.pickerD2, colorModal.hexD2, 'dayColor2');
        setupColorSync(colorModal.pickerN1, colorModal.hexN1, 'nightColor1'); 
        setupColorSync(colorModal.pickerN2, colorModal.hexN2, 'nightColor2');
        // [新增] 为十六进制输入框绑定同步事件
        setupHexInputSync(colorModal.hexD1, colorModal.pickerD1, 'dayColor1');
        setupHexInputSync(colorModal.hexD2, colorModal.pickerD2, 'dayColor2');
        setupHexInputSync(colorModal.hexN1, colorModal.pickerN1, 'nightColor1');
        setupHexInputSync(colorModal.hexN2, colorModal.pickerN2, 'nightColor2');

        // [核心新增] 将悬浮球初始化移至最后，并增加常驻逻辑
        FloatingBallManager.init();

        // ★ 新增：应用随机CSS预设的逻辑 ★
        const randomCssEnabled = localStorage.getItem('jellyRandomCssEnabled') === 'true';
        if (currentConfig.settings.jellyBall && currentConfig.settings.jellyBall.cssPresets && currentConfig.settings.jellyBall.cssPresets.length > 0 && randomCssEnabled) {
            const presets = currentConfig.settings.jellyBall.cssPresets;
            const randomPreset = presets[Math.floor(Math.random() * presets.length)];
            currentConfig.settings.jellyBall.customCSS = randomPreset.css; // 同步到当前配置
            // 注意：这里不需要saveGlobalConfig，因为这只是本次启动的临时效果
        }

        if (currentConfig.settings.jellyBall && currentConfig.settings.jellyBall.enabled) {
            FloatingBallManager.create();
        }

        function showIosWarning() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            const hasBeenShown = localStorage.getItem('iosWarningShown') === 'true';
            if (isIOS && !hasBeenShown) {
                const modal = document.getElementById('iosWarningModal');
                const confirmBtn = document.getElementById('iosWarningConfirmBtn');
                modal.classList.add('show');
                confirmBtn.addEventListener('click', () => {
                    modal.classList.remove('show');
                    localStorage.setItem('iosWarningShown', 'true');
                    // [核心修改] 用户确认iOS提示后，再检查是否需要显示首次引导
                    checkAndShowFirstTimeGuide();
                }, { once: true });
            } else {
                // [核心修改] 如果不是iOS或已经提示过，直接检查首次引导
                checkAndShowFirstTimeGuide();
            }
        }
        function checkAndShowFirstTimeGuide() {
            const isConfigured = GITHUB_CONFIG.owner && GITHUB_CONFIG.repo && GITHUB_CONFIG.token;
            const guideShown = localStorage.getItem('firstTimeGuideShown') === 'true';

            if (!isConfigured && !guideShown) {
                const guideModal = document.getElementById('firstTimeGuideModal');
                const startBtn = document.getElementById('startConfigGuideBtn');

                guideModal.classList.add('show');

                startBtn.addEventListener('click', () => {
                    guideModal.classList.remove('show');
                    document.getElementById('helpModal').classList.add('show');
                    document.getElementById('help-tab-0').click(); // 直接跳转到首次配置标签页
                    localStorage.setItem('firstTimeGuideShown', 'true');
                }, { once: true });
            }
        }

        // [修改] 调用 showIosWarning，它现在内部会处理后续的 checkAndShowFirstTimeGuide 调用
        showIosWarning();


        // [新增] 监听更新公告标签页的点击
        const updateLogTab = document.querySelector('label[for="help-tab-2"]');
        if (updateLogTab) {
            updateLogTab.addEventListener('click', () => {
                const helpPage = document.getElementById('help-page-2');
                const updateLogIndicator = document.getElementById('update-log-indicator');

                if (helpPage && updateLogIndicator.classList.contains('show')) {
                    // 隐藏标签上的红点
                    if (updateLogIndicator) updateLogIndicator.classList.remove('show');
                    // 隐藏主按钮上的红点
                    document.getElementById('helpBtn').classList.remove('has-update');
                    // 更新“已读”状态到localStorage
                    const currentUpdateHash = simpleHash(helpPage.innerHTML.trim());
                    localStorage.setItem('lastSeenUpdateHash', String(currentUpdateHash));
                }
            });
        }

        /* =============================================================== */
        /* ============== [新增] 拖拽排序功能核心逻辑 V1.0 ============= */
        /* =============================================================== */
        const DragAndSort = (() => {
            let draggedEl = null;      // 正在拖拽的原始元素
            let ghostEl = null;        // 跟随鼠标的虚影元素
            let dropTarget = null;     // 当前的放置目标元素
            let longPressTimer = null; // 长按计时器
            let isDragging = false;    // 是否正在拖拽的标志
            let startPos = { x: 0, y: 0 };
            let offset = { x: 0, y: 0 };

            const LONG_PRESS_DELAY = 300; // 长按 300 毫秒触发
            const DRAG_THRESHOLD = 5;     // 移动超过 5px 则取消长按

            // 当长按计时器触发，开始拖拽
            function startDrag(event) {
                if (!draggedEl) return;
                isDragging = true;
                
                const rect = draggedEl.getBoundingClientRect();

                // 1. 创建虚影
                ghostEl = draggedEl.cloneNode(true);
                ghostEl.classList.add('drag-ghost');
                document.body.appendChild(ghostEl);
                
                // 设置虚影的初始尺寸和位置
                ghostEl.style.width = `${rect.width}px`;
                ghostEl.style.height = `${rect.height}px`;
                ghostEl.style.left = `${rect.left}px`;
                ghostEl.style.top = `${rect.top}px`;

                // 计算鼠标/手指在元素上的偏移
                offset.x = startPos.x - rect.left;
                offset.y = startPos.y - rect.top;

                // 2. 更新原始元素和body的样式
                draggedEl.classList.add('dragging');
                document.body.classList.add('dragging-active');

                // 3. 初始移动一次虚影，确保位置正确
                moveGhost(startPos.x, startPos.y);
            }

            // 移动虚影
            function moveGhost(clientX, clientY) {
                if (!ghostEl) return;
                ghostEl.style.left = `${clientX - offset.x}px`;
                ghostEl.style.top = `${clientY - offset.y}px`;
            }

            // 拖拽过程中的处理
            function onDragMove(event) {
                const a = event.touches ? event.touches[0] : event;
                const { clientX, clientY } = a;

                // 如果还没开始拖拽（长按计时器未触发），检查移动距离
                if (!isDragging) {
                    if (Math.abs(clientX - startPos.x) > DRAG_THRESHOLD || Math.abs(clientY - startPos.y) > DRAG_THRESHOLD) {
                        clearTimeout(longPressTimer); // 移动过大，取消长按
                    }
                    return;
                }

                event.preventDefault(); // 开始拖拽后，阻止默认行为（如滚动）
                moveGhost(clientX, clientY);

                // 隐藏虚影，以便检测其下方的元素
                ghostEl.style.display = 'none';
                const elementBelow = document.elementFromPoint(clientX, clientY);
                ghostEl.style.display = '';

                // 移除上一个目标的高亮
                if (dropTarget) {
                    dropTarget.classList.remove('drag-over');
                    dropTarget = null;
                }
                
                // 检查下方元素是否是有效的放置目标
                const potentialTarget = elementBelow ? elementBelow.closest('.nav-btn, .category-pill, .album-item, .folder-item') : null;
                if (potentialTarget && potentialTarget !== draggedEl && draggedEl.classList[0] === potentialTarget.classList[0]) {
                    dropTarget = potentialTarget;
                    dropTarget.classList.add('drag-over');
                }
            }

             // 拖拽结束
            function onDragEnd(event) {
                clearTimeout(longPressTimer);
                if (!isDragging) return;

                // 如果存在有效的放置目标
                if (dropTarget) {
                    dropTarget.classList.remove('drag-over');
                    
                    // [修改] 实现节点互换逻辑
                    const parent = draggedEl.parentNode;
                    
                    // 创建两个占位节点
                    const draggedPlaceholder = document.createElement('div');
                    const targetPlaceholder = document.createElement('div');
                    
                    // 将占位节点插入到原始节点之前
                    parent.insertBefore(draggedPlaceholder, draggedEl);
                    parent.insertBefore(targetPlaceholder, dropTarget);
                    
                    // 将原始节点移动到对方的占位节点之前
                    parent.insertBefore(draggedEl, targetPlaceholder);
                    parent.insertBefore(dropTarget, draggedPlaceholder);
                    
                    // 移除占位节点
                    parent.removeChild(draggedPlaceholder);
                    parent.removeChild(targetPlaceholder);

                    // 更新数据模型
                    updateDataModel(draggedEl, dropTarget, parent);
                }

                // 清理工作
                draggedEl.classList.remove('dragging');
                document.body.classList.remove('dragging-active');
                if (ghostEl) {
                    ghostEl.remove();
                }
                
                draggedEl = null;
                ghostEl = null;
                dropTarget = null;
                isDragging = false;
                
                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('touchmove', onDragMove);
                document.removeEventListener('mouseup', onDragEnd);
                document.removeEventListener('touchend', onDragEnd);
            }


            // 按下事件（长按的起点）
            function onDragStart(event) {
                // [修改] 同时检查相册和备忘录文件夹的管理模式是否开启
                const isAlbumManageMode = document.querySelector('.album-item.manage-mode');
                const isMemoManageMode = document.querySelector('.folder-item.manage-mode');

                // 如果所有管理模式都没开，则退出
                if (!document.body.classList.contains('management-active') && !isAlbumManageMode && !isMemoManageMode) return;
                
                if (isDragging) return;

                const a = event.touches ? event.touches[0] : event;
                startPos.x = a.clientX;
                startPos.y = a.clientY;

                // 路径1：立即拖拽 (针对相册或备忘录文件夹的排序把手)
                if (event.target.classList.contains('sort-handle')) {
                    // [修改] 让其能找到 .album-item 或 .folder-item
                    draggedEl = event.target.closest('.album-item, .folder-item'); 
                    if (!draggedEl) return;
                    
                    startDrag(event);
                    
                    document.addEventListener('mousemove', onDragMove);
                    document.addEventListener('touchmove', onDragMove, { passive: false });
                    document.addEventListener('mouseup', onDragEnd, { once: true });
                    document.addEventListener('touchend', onDragEnd, { once: true });
                    return; 
                }
                
                // 路径2：长按拖拽 (针对主页项目和分类)
                const target = event.target.closest('.nav-btn, .category-pill');
                if (!target || event.target.classList.contains('delete-icon')) return;

                draggedEl = target;
                longPressTimer = setTimeout(() => startDrag(event), LONG_PRESS_DELAY);

                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('touchmove', onDragMove, { passive: false });
                document.addEventListener('mouseup', onDragEnd, { once: true });
                document.addEventListener('touchend', onDragEnd, { once: true });
            }

            // 更新底层数据结构
            function updateDataModel(el1, el2, parent) {
                // 情况一：对项目按钮排序
                if (parent.id === 'navContainer') {
                    const category = currentConfig.categories.find(c => c.name === currentCategory);
                    if (!category) return;

                    const allButtons = Array.from(parent.querySelectorAll('.nav-btn'));
                    const newButtonOrder = allButtons.map(btn => {
                        return category.buttons.find(b => b.href === btn.dataset.href);
                    }).filter(Boolean);

                    category.buttons = newButtonOrder;
                }
                // 情况二：对相册封面排序
                else if (parent.id === 'album-list-container') {
                    const allAlbums = Array.from(parent.querySelectorAll('.album-item'));
                    const newAlbumOrder = allAlbums.map(albumEl => {
                        const albumId = parseInt(albumEl.dataset.albumId, 10);
                        return memoryCache.album.folders.find(f => f.id === albumId);
                    }).filter(Boolean);

                    memoryCache.album.folders = newAlbumOrder;
                    
                    MemoryApp.scheduleSave();
                    return; 
                }
                // [新增] 情况三：对备忘录文件夹排序
                else if (parent.id === 'folder-list-container') {
                    const allFolders = Array.from(parent.querySelectorAll('.folder-item'));
                    const newFolderOrder = allFolders.map(folderEl => {
                        const folderId = parseInt(folderEl.dataset.folderId, 10);
                        return memoryCache.memo.folders.find(f => f.id === folderId);
                    }).filter(Boolean);

                    memoryCache.memo.folders = newFolderOrder;

                    MemoryApp.scheduleSave();
                    return;
                }
                // 情况四：对分类标签排序
                else if (parent.id === 'categoryNav') {

                    const allPills = Array.from(parent.querySelectorAll('.category-pill'));
                    const newCategoryOrder = allPills.map(pill => {
                        return currentConfig.categories.find(c => c.name === pill.dataset.category);
                    }).filter(Boolean);

                    const allCategory = newCategoryOrder.find(c => c.name === '全部');
                    const otherCategories = newCategoryOrder.filter(c => c.name !== '全部');
                    if (allCategory) {
                        currentConfig.categories = [allCategory, ...otherCategories];
                    } else {
                        currentConfig.categories = newCategoryOrder;
                    }
                }
                
                saveGlobalConfig('Reorder items via drag and drop');
            }

            // 公开的初始化方法
            return {
                init() {
                    console.log("Drag and Sort functionality initialized.");
                    const mainContainer = document.getElementById('navContainer');
                    const categoryContainer = document.getElementById('categoryNav');
                    const albumContainer = document.getElementById('album-list-container');
                    // [新增] 获取备忘录文件夹的容器
                    const memoFolderContainer = document.getElementById('folder-list-container');

                    mainContainer.addEventListener('mousedown', onDragStart);
                    mainContainer.addEventListener('touchstart', onDragStart, { passive: true });
                    
                    categoryContainer.addEventListener('mousedown', onDragStart);
                    categoryContainer.addEventListener('touchstart', onDragStart, { passive: true });

                    albumContainer.addEventListener('mousedown', onDragStart);
                    albumContainer.addEventListener('touchstart', onDragStart, { passive: true });

                    // [新增] 为备忘录文件夹容器也绑定事件
                    memoFolderContainer.addEventListener('mousedown', onDragStart);
                    memoFolderContainer.addEventListener('touchstart', onDragStart, { passive: true });
                }
            };
        })();

        // 初始化拖拽排序功能
        DragAndSort.init();
        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */
        


         /* =============================================================== */
        /* ============== [更新] 手机模式管理逻辑 V5 (功能实现版) ===== */
        /* =============================================================== */

        // [新增] 在 MobileModeManager 外部定义一个渲染函数，方便多处调用
        function showMemoPopup(memoId) {
            const memo = memoryCache.memo.notes.find(n => n.id === memoId);
            if (!memo) return;

            document.querySelector('.memo-popup-overlay')?.remove();

            const overlay = document.createElement('div');
            overlay.className = 'memo-popup-overlay';
            overlay.innerHTML = `
                <div class="memo-popup-content">
                    <div class="memo-popup-title">${memo.title || '无标题'}</div>
                    <div class="memo-popup-body">${memo.content || '没有内容'}</div>
                </div>
            `;
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.classList.remove('show');
                    overlay.addEventListener('transitionend', () => overlay.remove(), { once: true });
                }
            });
            
            document.body.appendChild(overlay);
            setTimeout(() => overlay.classList.add('show'), 10);
        }
        


        const MobileModeManager = (() => {
            let isEnabled = false;
            let currentPickerWindow = null;
            let pendingWidgetContent = null; 
            let ghostEl = null;
            let draggedWidgetInfo = null;
            let dragTargetCell = null;
            let isSwiping = false;
            let startX = 0;
            let currentTranslate = 0;
            let currentPage = 0;

            const ui = {
                toggle: document.getElementById('mobileModeToggle'),
                wrapper: document.getElementById('mainWrapper'),
                slider: document.getElementById('pageSlider'),
                settingsEntry: document.getElementById('lockscreenSettingsEntry'),
                openSettingsBtn: document.getElementById('openLockscreenSettingsBtn'),
            };

            function closeAnyOpenWindow() {
                if (currentPickerWindow) {
                    const windowContainerToClose = currentPickerWindow;

                    // [核心修复] 在移除主窗口前，先检查并移除其关联的“兄弟”窗口
                    const siblingId = windowContainerToClose.dataset.siblingId;
                    if (siblingId) {
                        const siblingElement = document.getElementById(siblingId);
                        if (siblingElement && siblingElement.parentNode) {
                            siblingElement.remove();
                        }
                    }

                    const innerWindow = windowContainerToClose.querySelector('.floating-project-window');
                    if (innerWindow) {
                        innerWindow.classList.remove('visible');
                        innerWindow.addEventListener('transitionend', () => {
                            if (windowContainerToClose.parentNode) {
                                windowContainerToClose.remove();
                            }
                        }, { once: true });
                    } else {
                        if (windowContainerToClose.parentNode) {
                           windowContainerToClose.remove();
                        }
                    }
                    currentPickerWindow = null;
                }
            }

            function createPickerWindow(title, content) {
                closeAnyOpenWindow();
                const container = document.createElement('div');
                container.className = 'picker-window-container';
                const winEl = document.createElement('div');
                winEl.className = 'floating-project-window visible';
                winEl.style.cssText = 'z-index: 2025; width: 340px; height: auto; max-height: 80vh;';
                winEl.innerHTML = `
                    <div class="fpw-header"><span class="fpw-title">${title}</span>
                    <div class="fpw-controls"><button class="fpw-close" title="关闭">×</button></div></div>
                    <div class="fpw-content" style="padding: 15px;"></div>
                `;
                winEl.querySelector('.fpw-content').appendChild(content);

                // [核心修正] 在这里添加联动关闭逻辑
                winEl.querySelector('.fpw-close').addEventListener('click', () => {
                    // 移除主窗口
                    if (container && container.parentNode) {
                        container.remove();
                    }
                    // 查找并移除与之关联的背景选择器窗口
                    const siblingId = container.dataset.siblingId;
                    if (siblingId) {
                        const siblingElement = document.getElementById(siblingId);
                        if (siblingElement && siblingElement.parentNode) {
                            siblingElement.remove();
                        }
                    }
                });

                container.appendChild(winEl);
                document.getElementById('floating-projects-container').appendChild(container);
                currentPickerWindow = container;
                return container;
            }


            function showImagePicker(onSelect) {
                const grid = document.createElement('div');
                grid.className = 'picker-grid';
                const allPhotos = memoryCache.album.items.filter(item => item.type === 'photo' || (item.type === 'photoset' && item.photos.length > 0));
                if (allPhotos.length === 0) grid.textContent = '相册中没有图片。';
                else {
                    allPhotos.forEach(item => {
                        const photoToShow = item.type === 'photo' ? item : item.photos[0];
                        const gridItem = document.createElement('div');
                        gridItem.className = 'picker-grid-item';
                        const img = document.createElement('img');
                        getSecureFileUrl(photoToShow.path).then(url => { if (url) img.src = url; });
                        gridItem.appendChild(img);
                        gridItem.onclick = () => onSelect(photoToShow.path);
                        grid.appendChild(gridItem);
                    });
                }
                createPickerWindow('选择一张图片', grid);
            }

            function showMemoPicker(onSelect) {
                const list = document.createElement('div');
                list.className = 'picker-list';
                if (!memoryCache.memo.notes || memoryCache.memo.notes.length === 0) list.textContent = '没有备忘录。';
                else {
                    memoryCache.memo.notes.forEach(note => {
                        const itemEl = document.createElement('div');
                        itemEl.className = 'picker-item';
                        itemEl.textContent = note.title || '无标题';
                        itemEl.onclick = () => onSelect(note.id);
                        list.appendChild(itemEl);
                    });
                }
                createPickerWindow('选择一个备忘录', list);
            }

             function showContentAndBackgroundPicker(type, onSelect) {
                let listContent;
                let pickerTitle = '';
                let tempSelectedBg = null;

                let bgPickerContainer = null;
                
                const closeBothPickers = () => {
                    closeAnyOpenWindow(); 
                };

                if (type === 'shortcut') {
                    pickerTitle = '选择一个快捷方式';
                    listContent = document.createElement('div');
                    listContent.className = 'picker-list';
                    const allButtons = currentConfig.categories.flatMap(c => c.buttons);
                    if (allButtons.length === 0) {
                        listContent.textContent = '没有已添加的项目。';
                    } else {
                        const uniqueButtons = Array.from(new Map(allButtons.map(item => [item.href, item])).values());
                        uniqueButtons.forEach(btn => {
                            const itemEl = document.createElement('div');
                            itemEl.className = 'picker-item';
                            itemEl.textContent = btn.text;
                            itemEl.onclick = () => onSelect({ content: btn.href, text: btn.text, background: tempSelectedBg });
                            listContent.appendChild(itemEl);
                        });
                    }
                } else if (type === 'memo') {
                    pickerTitle = '选择一个备忘录';
                    listContent = document.createElement('div');
                    listContent.className = 'picker-list';
                    if (!memoryCache.memo.notes || memoryCache.memo.notes.length === 0) {
                        listContent.textContent = '没有备忘录。';
                    } else {
                        memoryCache.memo.notes.forEach(note => {
                            const itemEl = document.createElement('div');
                            itemEl.className = 'picker-item';
                            itemEl.textContent = note.title || '无标题';
                            itemEl.onclick = () => onSelect({ content: note.id, background: tempSelectedBg });
                            listContent.appendChild(itemEl);
                        });
                    }
                }

                const pickerContainer = createPickerWindow(pickerTitle, listContent);
                const pickerWindow = pickerContainer.querySelector('.floating-project-window');
                
                pickerWindow.querySelector('.fpw-close').addEventListener('click', closeBothPickers);

                // 创建并附加背景选择器
                bgPickerContainer = document.createElement('div');
                
                // [核心修正：建立关联]
                const siblingId = 'widget-bg-picker-container-' + Date.now();
                bgPickerContainer.id = siblingId;
                pickerContainer.dataset.siblingId = siblingId; // 将背景选择器的ID存到主窗口上

                bgPickerContainer.style.cssText = `
                    position: fixed;
                    z-index: 2024; 
                    pointer-events: none; 
                    width: auto;
                `;

                const bgPicker = document.createElement('div');
                bgPicker.className = 'widget-bg-picker-popup';
                bgPicker.innerHTML = `
                    <input type="color" id="widgetBgColorPicker" value="#ffffff">
                    <button class="bg-picker-button">导入图片</button>
                    <input type="file" accept="image/*" style="display:none;">
                `;
                bgPickerContainer.appendChild(bgPicker);
                document.body.appendChild(bgPickerContainer);
                
                requestAnimationFrame(() => {
                    const mainRect = pickerWindow.getBoundingClientRect();
                    const bgPickerRect = bgPicker.getBoundingClientRect();
                    
                    bgPickerContainer.style.top = `${mainRect.bottom}px`;
                    bgPickerContainer.style.left = `${mainRect.left + (mainRect.width / 2) - (bgPickerRect.width / 2)}px`;
                });

                const colorInput = bgPicker.querySelector('input[type="color"]');
                const fileInput = bgPicker.querySelector('input[type="file"]');
                const fileButton = bgPicker.querySelector('.bg-picker-button');

                colorInput.addEventListener('input', () => {
                    tempSelectedBg = colorInput.value;
                    fileButton.textContent = '导入图片';
                    fileInput.value = ''; 
                });
                
                fileButton.addEventListener('click', () => fileInput.click());

                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            tempSelectedBg = event.target.result; 
                            fileButton.textContent = '已选择图片';
                            colorInput.value = '#ffffff';
                        };
                        reader.readAsDataURL(file);
                    }
                });
                setTimeout(() => bgPicker.classList.add('show'), 50);
            }



            function showHtmlInputWindow(onSave) {
                const contentWrapper = document.createElement('div');
                contentWrapper.style.display = 'flex';
                contentWrapper.style.flexDirection = 'column';
                contentWrapper.style.gap = '15px';

                const textarea = document.createElement('textarea');
                textarea.className = 'modal-textarea html-editor-textarea';
                textarea.placeholder = '在此输入您的HTML代码...';
                
                const completeButton = document.createElement('button');
                completeButton.className = 'modal-button';
                completeButton.textContent = '完成';
                
                completeButton.onclick = () => {
                    onSave(textarea.value);
                };

                contentWrapper.appendChild(textarea);
                contentWrapper.appendChild(completeButton);
                
                createPickerWindow('输入HTML内容', contentWrapper);
            }





             async function saveWidgetConfig(cellIndex, widgetData, onCompleteCallback) {
                if (!currentConfig.lockscreenWidgets[cellIndex]) {
                    currentConfig.lockscreenWidgets[cellIndex] = [];
                }
                currentConfig.lockscreenWidgets[cellIndex].unshift(widgetData);

                // [V3 修复] 等待保存操作完成
                await saveGlobalConfig(`Add widget to cell ${cellIndex}`);

                // [V3 修复] 在保存完成后，才执行UI更新和回调
                renderLockscreenWidgets();
                const settingsModal = document.getElementById('lockscreen-settings-modal');
                if (settingsModal?.classList.contains('show')) {
                    renderSettingsGrid(settingsModal.querySelector('.settings-grid'));
                }
                
                // [V3 修复] 执行传入的回调，例如关闭选择器窗口
                if (typeof onCompleteCallback === 'function') {
                    onCompleteCallback();
                }
                
                // === 新增：显示成功提示 ===
                showTopToast("小组件已添加", 2000);
            }


            async function deleteWidgetFromCell(cellIndex) {
                delete currentConfig.lockscreenWidgets[cellIndex];
                
                // [V3 修复] 等待删除操作完成
                await saveGlobalConfig(`Delete widget from cell ${cellIndex}`);

                // [V3 修复] 在保存完成后，才执行UI更新
                renderLockscreenWidgets();
                const settingsModal = document.getElementById('lockscreen-settings-modal');
                if (settingsModal?.classList.contains('show')) {
                    renderSettingsGrid(settingsModal.querySelector('.settings-grid'));
                }
                
                // === 新增：显示成功提示 ===
                showTopToast("小组件已删除", 2000);
            }


            function showAlbumPicker(onSelectCallback) {
                const list = document.createElement('div');
                list.className = 'picker-list';

                const folders = memoryCache.album.folders;
                if (!folders || folders.length === 0) {
                    list.textContent = '相册中没有文件夹。';
                } else {
                    folders.forEach(folder => {
                        const itemCount = memoryCache.album.items.filter(p => p.albumId === folder.id).length;
                        const itemEl = document.createElement('div');
                        itemEl.className = 'picker-item';
                        itemEl.innerHTML = `<span>${folder.name}</span><span style="font-size: 0.8em; color: #889; float: right;">${itemCount} ></span>`;
                        itemEl.onclick = () => {
                            showPhotosInAlbumPicker(folder.id, onSelectCallback);
                        };
                        list.appendChild(itemEl);
                    });
                }
                createPickerWindow('选择一个相册', list);
            }

            function showPhotosInAlbumPicker(albumId, onSelectCallback) {
                const grid = document.createElement('div');
                grid.className = 'picker-grid';

                const allItems = memoryCache.album.items.filter(item => item.albumId === albumId);
                const allPhotos = allItems.flatMap(item => item.type === 'photo' ? item : (item.photos || []));

                if (allPhotos.length === 0) {
                    grid.textContent = '此相册中没有图片。';
                } else {
                    allPhotos.forEach(photo => {
                        const gridItem = document.createElement('div');
                        gridItem.className = 'picker-grid-item';
                        const img = document.createElement('img');
                        getSecureFileUrl(photo.path).then(url => { if (url) img.src = url; });
                        gridItem.appendChild(img);

                        gridItem.onclick = () => {
                            const adderContainer = document.getElementById('lockscreen-settings-modal').querySelector('.component-adder');
                            
                            const infoSpan = document.createElement('span');
                            infoSpan.id = 'selection-info';
                            infoSpan.style.fontSize = '12px';
                            infoSpan.style.color = '#889';
                            infoSpan.style.textAlign = 'center';
                            infoSpan.style.display = 'block';
                            infoSpan.style.marginTop = '-10px';
                            infoSpan.style.marginBottom = '10px';
                            const fileName = photo.path.split('/').pop();
                            infoSpan.textContent = `已选择：${photo.title || fileName}`;
                            
                            const confirmBtn = adderContainer.querySelector('#confirm-widget-btn');
                            adderContainer.insertBefore(infoSpan, confirmBtn);

                            closeAnyOpenWindow();
                            onSelectCallback({ path: photo.path, title: photo.title || fileName });
                        };
                        grid.appendChild(gridItem);
                    });
                }
                const folderName = memoryCache.album.folders.find(f => f.id === albumId)?.name || '相册';
                createPickerWindow(folderName, grid);
            }

            
             async function ensureMemoryDataIsLoaded(signal) {
                // 如果内存中已有缓存，直接返回成功
                if (memoryCache && memoryCache.album && memoryCache.memo) {
                    return { success: true };
                }

                const MEMORY_DATA_PATH = 'memory/data.json';

                const getInitialData = () => ({ 
                    memo: { 
                        folders: [{ id: Date.now(), name: "默认文件夹" }], 
                        notes: [] 
                    }, 
                    album: { 
                        folders: [{ id: Date.now() + 1, name: "我的照片" }],
                        items: [] 
                    } 
                });
                
                try {
                    const { data, error, response } = await fetchFromGithub(MEMORY_DATA_PATH, 'GET', null, signal);
                    
                    if (signal?.aborted) {
                        console.log('Data loading cancelled by user.');
                        return { success: false, reason: 'cancelled' };
                    }

                    if (error) {
                        alert(`加载记忆数据失败: ${error}\n\n请检查您的网络连接和GitHub配置。`);
                        return { success: false, reason: 'error' };
                    }
                    
                    let loadedData = null;
                    if ((response && response.status === 404) || !data || !data.content) {
                         console.log('memory/data.json not found or is empty on remote. Using initial data.');
                         loadedData = getInitialData();
                    } else {
                        // 只有在确定内容非空时才尝试解析
                        loadedData = JSON.parse(b64_to_utf8(data.content));
                    }

                    // [核心最终修复] 使用正确的 mergeDeep 顺序
                    // 1. 创建一个全新的空对象 {} 作为安全的目标。
                    // 2. 将 defaultConfig (最新的数据结构) 合并进去作为基础。
                    // 3. 将 loadedData (你的数据) 合并进去，你的数据会覆盖掉默认值，从而被完整保留。
                    const defaultConfig = getInitialData();
                    memoryCache = mergeDeep({}, defaultConfig, loadedData);

                    // 兼容旧版 `photos` 字段到 `items` 的迁移
                    if (memoryCache.album && memoryCache.album.photos && (!memoryCache.album.items || memoryCache.album.items.length === 0)) {
                        console.log("Migrating legacy 'photos' array to 'items'.");
                        memoryCache.album.items = memoryCache.album.photos.map(p => ({...p, type: 'photo'}));
                        delete memoryCache.album.photos;
                    }

                    return { success: true };

                } catch (e) {
                    // 捕获所有致命错误，包括JSON解析失败
                    console.error('Critical error in ensureMemoryDataIsLoaded:', e);
                    alert(`处理记忆数据时发生严重错误: ${e.message}\n\n这可能是因为云端文件格式已损坏。您可以尝试进入“记忆”功能，它会自动尝试修复或重建数据。`);
                    return { success: false, reason: 'critical' };
                }
            }

            function openLockscreenSettingsWindow() {
                const modalId = 'lockscreen-settings-modal';
                // [修复] 移除防止重复创建的判断，因为关闭时元素会被彻底销毁，需要能够重新创建
                // if (document.getElementById(modalId)) return;
                const LoadingIndicator = (() => {
                    let overlay = null;

                    let abortController = null;

                    function show(message, onCancel) {
                        if (overlay) return;
                        abortController = new AbortController();

                        overlay = document.createElement('div');
                        overlay.className = 'loading-indicator-overlay';
                        overlay.innerHTML = `
                            <div class="loading-indicator-box">
                                <div class="loading-indicator-text">${message}</div>
                                <button class="loading-indicator-cancel-btn">取消</button>
                            </div>
                        `;
                        document.body.appendChild(overlay);

                        overlay.querySelector('.loading-indicator-cancel-btn').onclick = () => {
                            abortController.abort();
                            hide();
                            if (onCancel) onCancel();
                        };
                        
                        requestAnimationFrame(() => overlay.classList.add('show'));
                    }

                    function hide() {
                        if (!overlay) return;
                        const overlayToRemove = overlay;
                        overlayToRemove.classList.remove('show');
                        overlayToRemove.addEventListener('transitionend', () => overlayToRemove.remove(), { once: true });
                        overlay = null;
                        abortController = null;
                    }

                    return {
                        show,
                        hide,
                        getSignal: () => abortController?.signal
                    };
                })();
                const modalOverlay = document.createElement('div');
                modalOverlay.id = modalId;
                modalOverlay.className = 'modal-overlay show';
                modalOverlay.style.zIndex = '1001';
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                const settingsContainer = document.createElement('div');
                settingsContainer.style.cssText = 'display: flex; flex-direction: column; height: 100%;';
                const header = document.createElement('div');
                header.className = 'modal-header';
                header.innerHTML = `<div class="modal-title-group"><span>锁屏组件设置</span></div><button class="close-btn">&times;</button>`;
                const body = document.createElement('div');
                body.className = 'modal-body';
                body.style.paddingTop = '10px';
                const phoneScreen = document.createElement('div');
                phoneScreen.className = 'simulated-phone-screen';
                const gridContainer = document.createElement('div');
                gridContainer.className = 'settings-grid';
                phoneScreen.appendChild(gridContainer);
                const adderContainer = document.createElement('div');
                adderContainer.className = 'component-adder';
                adderContainer.innerHTML = `
                    <div class="adder-controls-row">
                        <div class="adder-control-group"> <label>尺寸 (宽x高)</label> <div class="size-selector"> <div class="roller-container"> <button class="roller-btn" data-roller="width" data-dir="-1">-</button> <span class="roller-display" id="width-display">1</span> <button class="roller-btn" data-roller="width" data-dir="1">+</button> </div> <span>&times;</span> <div class="roller-container"> <button class="roller-btn" data-roller="height" data-dir="-1">-</button> <span class="roller-display" id="height-display">1</span> <button class="roller-btn" data-roller="height" data-dir="1">+</button> </div> </div> </div>
                        <div class="adder-control-group"> <label>类型</label> <select id="widget-type-selector" class="modal-select"> <option value="shortcut">快捷按钮</option> <option value="image">图片</option> <option value="memo">备忘录</option> <option value="html">HTML</option> </select> </div>
                    </div>
                    <button id="confirm-widget-btn" class="modal-button">确认并生成</button>
                    <div id="new-widget-preview-area" style="display: flex; justify-content: center; align-items: center; gap: 15px;">将生成的组件拖入上方屏幕</div>
                `;
                body.append(phoneScreen, adderContainer);
                settingsContainer.append(header, body);
                modalContent.appendChild(settingsContainer);
                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);

                const closeModal = () => { closeAnyOpenWindow(); modalOverlay.classList.remove('show'); modalOverlay.addEventListener('transitionend', () => modalOverlay.remove(), { once: true }); };
                header.querySelector('.close-btn').onclick = closeModal;
                modalOverlay.onclick = (e) => { if (e.target === modalOverlay) closeModal(); };
                renderSettingsGrid(gridContainer);
                const widthDisplay = adderContainer.querySelector('#width-display'), heightDisplay = adderContainer.querySelector('#height-display');
                adderContainer.querySelectorAll('.roller-btn').forEach(btn => btn.addEventListener('click', () => { const t = btn.dataset.roller, d = parseInt(btn.dataset.dir, 10), el = t === 'width' ? widthDisplay : heightDisplay, max = t === 'width' ? 4 : 8; let val = parseInt(el.textContent, 10) + d; el.textContent = Math.max(1, Math.min(val, max)); }));
                
                adderContainer.querySelector('#widget-type-selector').addEventListener('change', function() {
                    adderContainer.querySelector('#new-widget-preview-area').innerHTML = '将生成的组件拖入上方屏幕';
                    adderContainer.querySelector('#new-widget-preview-area').classList.remove('has-widget');
                    pendingWidgetContent = null;
                    adderContainer.querySelector('#selection-info')?.remove();
                });

                // ============ [核心修改点 1: "确认并生成" 按钮逻辑] ============
                adderContainer.querySelector('#confirm-widget-btn').addEventListener('click', () => {
                    const type = adderContainer.querySelector('#widget-type-selector').value;
                    const previewArea = adderContainer.querySelector('#new-widget-preview-area');

                    adderContainer.querySelector('#selection-info')?.remove();
                    previewArea.innerHTML = ''; 

                    const size = `${widthDisplay.textContent}x${heightDisplay.textContent}`;
                    const typeTextMap = { 'shortcut': '快捷方式', 'image': '图片', 'memo': '备忘录', 'html': 'HTML' };
                    const descriptiveText = `${size} ${typeTextMap[type] || type}`;
                    
                    // 创建函数，用于生成一个预览项
                    const createPreviewItem = (shape) => {
                        const item = document.createElement('div');
                        item.className = 'widget-preview-item';
                        if (shape === 'circle') {
                            item.classList.add('shape-circle');
                        }
                        Object.assign(item.dataset, { 
                            widgetSize: size, 
                            widgetType: type,
                            widgetShape: shape // [新增] 将形状信息存入 dataset
                        });
                        item.textContent = descriptiveText;
                        item.draggable = true;
                        item.addEventListener('mousedown', handleDragStart);
                        item.addEventListener('touchstart', handleDragStart, { passive: false });
                        return item;
                    };

                    // 创建并添加方形和圆形预览项
                    const squarePreview = createPreviewItem('square');
                    const circlePreview = createPreviewItem('circle');

                    previewArea.appendChild(circlePreview);
                    previewArea.appendChild(squarePreview);
                    
                    previewArea.classList.toggle('has-widget', previewArea.childElementCount > 0);
                });
            }

            async function renderSettingsGrid(gridContainer) {
                if (!gridContainer) return;
                gridContainer.innerHTML = '';
                for (let i = 0; i < 32; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'settings-grid-cell';
                    cell.dataset.cellIndex = i;
                    gridContainer.appendChild(cell);
                }
                const gridRect = gridContainer.getBoundingClientRect();
                const gap = 4;
                const cellWidth = (gridRect.width - (3 * gap)) / 4;
                const cellHeight = (gridRect.height - (7 * gap)) / 8;

                if (cellWidth <= 0 || cellHeight <= 0) {
                    return;
                }

                const widgets = currentConfig.lockscreenWidgets || {};

                for (const startIndexStr in widgets) {
                    const startIndex = parseInt(startIndexStr);
                    const widgetConfig = widgets[startIndex]?.[0];
                    if (!widgetConfig) continue;

                    const [cols, rows] = widgetConfig.size.split('x').map(Number);
                    const startRow_0based = Math.floor(startIndex / 4);
                    const startCol_0based = startIndex % 4;
                    const top = startRow_0based * (cellHeight + gap);
                    const left = startCol_0based * (cellWidth + gap);
                    const width = cols * cellWidth + (cols - 1) * gap;
                    const height = rows * cellHeight + (rows - 1) * gap;

                    const container = document.createElement('div');
                    container.className = 'widget-container-wrapper';
                    Object.assign(container.style, { position: 'absolute', top: `${top}px`, left: `${left}px`, width: `${width}px`, height: `${height}px` });

                    const placeholder = document.createElement('div');
                    placeholder.className = 'widget-placeholder';
                    placeholder.style.position = 'absolute';
                    placeholder.style.inset = '0';

                    switch (widgetConfig.type) {
                        case 'image':
                            placeholder.style.padding = '0';
                            placeholder.style.overflow = 'hidden';
                            const img = document.createElement('img');
                            Object.assign(img.style, { width: '100%', height: '100%', objectFit: 'cover', borderRadius: 'inherit' });
                            img.alt = 'Image Preview';
                            getSecureFileUrl(widgetConfig.content).then(url => { if (url) img.src = url; });
                            placeholder.appendChild(img);
                            break;
                        case 'memo':
                            const memo = memoryCache.memo.notes.find(n => n.id === widgetConfig.content);
                            placeholder.innerHTML = memo ? `<div class="settings-widget-preview-memo-title">${memo.title||'无标题'}</div><div class="settings-widget-preview-memo-content">${memo.content||''}</div>` : '备忘录丢失';
                            break;
                        case 'shortcut':
                            const btnCfg = findButtonConfigByHref(widgetConfig.content);
                            placeholder.textContent = btnCfg ? btnCfg.text : '快捷方式丢失';
                            break;
                        case 'html':
                            placeholder.textContent = 'HTML';
                            break;
                    }

                    const deleteWrapper = document.createElement('div');
                    deleteWrapper.className = 'widget-delete-wrapper';
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'widget-delete-btn-centered';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm('确定要删除这个组件吗？')) {
                            // [V3 修复] 调用修改后的异步函数
                            deleteWidgetFromCell(startIndex);
                        }
                    };
                    deleteWrapper.appendChild(deleteBtn);
                    container.appendChild(placeholder);
                    container.appendChild(deleteWrapper);
                    gridContainer.appendChild(container);
                }
            }


            // ============ [核心修改点 2: 拖拽开始时捕获形状信息] ============
            function handleDragStart(e) {
                e.preventDefault();
                const item = e.currentTarget;
                draggedWidgetInfo = { 
                    size: item.dataset.widgetSize, 
                    type: item.dataset.widgetType,
                    shape: item.dataset.widgetShape, // [新增] 捕获形状
                    content: item.dataset.widgetContent
                };
                ghostEl = document.createElement('div');
                ghostEl.className = 'widget-ghost';
                if (draggedWidgetInfo.shape === 'circle') { // [新增] 让拖拽虚影也变成圆形
                    ghostEl.style.borderRadius = '50%';
                }
                ghostEl.textContent = item.textContent;
                document.body.appendChild(ghostEl);
                
                const gridEl = document.querySelector('#lockscreen-settings-modal .settings-grid');
                if (!gridEl) return;
                
                const gridRect = gridEl.getBoundingClientRect();
                const singleCellWidth = (gridRect.width - (3 * 5)) / 4;
                const singleCellHeight = (gridRect.height - (7 * 5)) / 8;
                const gap = 5;

                const [cols, rows] = draggedWidgetInfo.size.split('x').map(Number);

                ghostEl.style.width = `${cols * singleCellWidth + (cols - 1) * gap}px`;
                ghostEl.style.height = `${rows * singleCellHeight + (rows - 1) * gap}px`;

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                ghostEl.style.left = `${clientX - ghostEl.offsetWidth / 2}px`;
                ghostEl.style.top = `${clientY - ghostEl.offsetHeight / 2}px`;
                ghostEl.style.zIndex = '9999';
                document.addEventListener('mousemove', handleDragMove);
                document.addEventListener('mouseup', handleDragEnd, { once: true });
                document.addEventListener('touchmove', handleDragMove, { passive: false });
                document.addEventListener('touchend', handleDragEnd, { once: true });
            }


            function isPlacementValid(startCell, size) {
                const occupied = new Set();
                Object.keys(currentConfig.lockscreenWidgets || {}).forEach(iStr => {
                     const i = parseInt(iStr);
                     const w = currentConfig.lockscreenWidgets[i][0];
                     const [c, r] = w.size.split('x').map(Number);
                     for(let y=0; y<r; y++) for(let x=0; x<c; x++) occupied.add(i + y*4 + x);
                });

                const startIndex = parseInt(startCell.dataset.cellIndex, 10);
                const [cols, rows] = size.split('x').map(Number);

                if ((startIndex % 4) + cols > 4) return false;
                if (Math.floor(startIndex/4) + rows > 8) return false;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (occupied.has(startIndex + r * 4 + c)) return false;
                    }
                }
                return true;
            }

            function handleDragMove(e) {
                if (!ghostEl) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                ghostEl.style.left = `${clientX - ghostEl.offsetWidth / 2}px`;
                ghostEl.style.top = `${clientY - ghostEl.offsetHeight / 2}px`;
                if (dragTargetCell) dragTargetCell.classList.remove('drag-over');
                ghostEl.style.display = 'none';
                const elBelow = document.elementFromPoint(clientX, clientY);
                ghostEl.style.display = 'flex';
                const cell = elBelow ? elBelow.closest('.settings-grid-cell') : null;
                if (cell && isPlacementValid(cell, draggedWidgetInfo.size)) {
                    dragTargetCell = cell;
                    dragTargetCell.classList.add('drag-over');
                } else {
                    dragTargetCell = null;
                }
            }
            
              async function handleDragEnd() {
                if (dragTargetCell) {
                    dragTargetCell.classList.remove('drag-over');
                    const cellIndex = parseInt(dragTargetCell.dataset.cellIndex, 10);
                    const newWidget = { id: Date.now(), ...draggedWidgetInfo };

                    // [V3 修复] onSelectContent 现在调用带回调的 saveWidgetConfig
                    const onSelectContent = (data) => {
                        newWidget.content = data.content;
                        if (data.text) newWidget.text = data.text;
                        if (data.background) newWidget.background = data.background;
                        
                        // 传入 closeAnyOpenWindow 作为保存成功后的回调函数
                        saveWidgetConfig(cellIndex, newWidget, closeAnyOpenWindow);
                    };

                    if (['memo', 'image', 'shortcut'].includes(newWidget.type)) {
                        const { success } = await ensureMemoryDataIsLoaded();
                        if (success) {
                            if (newWidget.type === 'image') {
                                showAlbumPicker(photoData => onSelectContent({ content: photoData.path }));
                            } else {
                                showContentAndBackgroundPicker(newWidget.type, onSelectContent);
                            }
                        }
                    } else if (newWidget.type === 'html') {
                        showHtmlInputWindow(htmlContent => onSelectContent({ content: htmlContent }));
                    }
                }

                if (ghostEl) ghostEl.remove();
                ghostEl = null; draggedWidgetInfo = null; dragTargetCell = null;
                document.removeEventListener('mousemove', handleDragMove);
                document.removeEventListener('touchmove', handleDragMove);
            }



            async function applyMode(enable) {
                const homeScreenPage = document.getElementById('homeScreenPage');
                const mainWrapper = document.getElementById('mainWrapper');
                const elementsToMove = [document.getElementById('pageOverlay'), document.getElementById('titleCard'), document.getElementById('categoryNavContainer'), document.querySelector('.scrollable-nav-wrapper')].filter(Boolean);
                isEnabled = enable;
                document.body.classList.toggle('mobile-mode', enable);
                ui.settingsEntry.style.display = enable ? 'block' : 'none';
                
                if (enable) {
                    // 确保记忆数据已加载，以便锁屏组件能获取信息
                    const { success } = await ensureMemoryDataIsLoaded();
                    if (!success) {
                        alert("加载锁屏组件数据失败，部分组件可能无法显示。请检查网络后刷新重试。");
                    }
                    
                    // 将主页元素移动到手机模式的 home-screen-page 中
                    elementsToMove.forEach(el => homeScreenPage.appendChild(el));
                    currentPage = 0; currentTranslate = 0;
                    ui.slider.style.transition = 'none';
                    ui.slider.style.transform = `translateX(0px)`;
                    ui.slider.classList.remove('show-home-screen');
                    renderLockscreenWidgets();
                    attachSwipeListeners();
                } else {
                    // 当关闭手机模式时，将元素移回 body
                    elementsToMove.forEach(el => {
                        // fab-container 是一个很好的参照点，我们将元素插到它前面
                        const fabContainer = document.getElementById('fabContainer');
                        if (fabContainer) {
                             document.body.insertBefore(el, fabContainer);
                        } else {
                             document.body.appendChild(el); // 兜底方案
                        }
                    });
                    detachSwipeListeners();
                    ui.slider.style.transition = 'none';
                    ui.slider.style.transform = `translateX(0px)`;
                    ui.slider.classList.remove('show-home-screen');
                    document.body.classList.remove('mobile-home-screen-active');
                }
                
                if (!currentConfig.settings.mobileMode) currentConfig.settings.mobileMode = {};
                currentConfig.settings.mobileMode.enabled = enable;
                saveGlobalConfig('Toggle mobile mode');
            }



            // [V3 终极修复] 重构滑动逻辑，解决事件冲突
            let startY = 0, diffX = 0, diffY = 0, swipeIntention = null; // null, 'horizontal', 'vertical'

             function handleTouchStart(e) {
                // [最终修复] 如果触摸起始点在日历组件内部，则完全中止全局滑动逻辑，将事件控制权交还给日历自身。
                if (e.target.closest('.calendar-flipper')) {
                    return;
                }

                // 如果正在滑动中，或者目标是其他交互组件，则忽略新的触摸
                if (isSwiping || !isEnabled || e.target.closest('.widget, .widget-placeholder, .component-adder')) return;
                
                // 重置所有状态
                swipeIntention = null;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                diffX = 0;
                diffY = 0;

                ui.slider.style.transition = 'none';
                const transformMatrix = window.getComputedStyle(ui.slider).transform;
                currentTranslate = (transformMatrix !== 'none') ? parseFloat(transformMatrix.split(',')[4]) : 0;
                
                // 标记触摸 sequence 开始
                isSwiping = true; 
            }


            function handleTouchMove(e) {
                if (!isSwiping || !isEnabled) return;

                diffX = e.touches[0].clientX - startX;
                diffY = e.touches[0].clientY - startY;

                // 首次移动时，判断用户的意图
                if (swipeIntention === null) {
                    // 水平移动大于垂直移动，且超过阈值，判定为页面滑动
                    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                        swipeIntention = 'horizontal';
                    } 
                    // 垂直移动大于水平移动，判定为页面滚动 (或长按前的微小抖动)
                    else if (Math.abs(diffY) > Math.abs(diffX)) {
                        swipeIntention = 'vertical';
                    }
                }
                
                // 只有明确是水平滑动意图时，才阻止默认行为并移动页面
                if (swipeIntention === 'horizontal') {
                    e.preventDefault();
                    const pageWidth = ui.slider.offsetWidth / 2;
                    const limitedTranslate = Math.max(-pageWidth, Math.min(0, currentTranslate + diffX));
                    ui.slider.style.transform = `translateX(${limitedTranslate}px)`;
                } 
                // 如果是垂直意图，或者意图未定（移动太小），则什么都不做
                // 这允许了垂直滚动、点击和长按的正常触发
            }
            
            function handleTouchEnd(e) {
                if (!isSwiping || !isEnabled) return;
                
                // 只有当意图是水平滑动时，才处理页面切换逻辑
                if (swipeIntention === 'horizontal') {
                    const threshold = window.innerWidth / 4;
                    if (Math.abs(diffX) > threshold) {
                        if (diffX < 0 && currentPage === 0) currentPage = 1;
                        else if (diffX > 0 && currentPage === 1) currentPage = 0;
                    }
                    snapToPage();
                }

                // 重置状态，准备下一次触摸
                isSwiping = false;
                swipeIntention = null;
            }


            function snapToPage() {
                const pageWidth = ui.slider.offsetWidth / 2;
                const targetTranslate = currentPage === 1 ? -pageWidth : 0;
                ui.slider.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1)';
                ui.slider.style.transform = `translateX(${targetTranslate}px)`;
                currentTranslate = targetTranslate;
                ui.slider.classList.toggle('show-home-screen', currentPage === 1);
                document.body.classList.toggle('mobile-home-screen-active', currentPage === 1);
            }

            function attachSwipeListeners() {
                const options = { passive: false };
                ui.wrapper.addEventListener('touchstart', handleTouchStart, options);
                ui.wrapper.addEventListener('touchmove', handleTouchMove, options);
                ui.wrapper.addEventListener('touchend', handleTouchEnd, { passive: true });
            }

            function detachSwipeListeners() {
                const options = { passive: false };
                ui.wrapper.removeEventListener('touchstart', handleTouchStart, options);
                ui.wrapper.removeEventListener('touchmove', handleTouchMove, options);
                ui.wrapper.removeEventListener('touchend', handleTouchEnd, { passive: true });
            }

            return {
                init() {
                    if (!currentConfig.settings) currentConfig.settings = {};
                    const mobileSettings = currentConfig.settings.mobileMode || { enabled: false };
                    ui.toggle.checked = mobileSettings.enabled;
                    if (!currentConfig.lockscreenWidgets) currentConfig.lockscreenWidgets = {};
                    if (mobileSettings.enabled) applyMode(true);
                    ui.toggle.addEventListener('change', (e) => applyMode(e.target.checked));
                    ui.openSettingsBtn.addEventListener('click', openLockscreenSettingsWindow);
                }
            };
        })();

         function renderLockscreenWidgets() {
            const grid = document.getElementById('lockscreenGrid');
            if (!grid) return;
            grid.innerHTML = '';

            // [V3 最终修复] 
            // 采用 title-card 模式，直接读取 grid 自身的渲染宽度
            
            // 1. 获取 grid 元素当前的实际宽度 (由 CSS 'width: calc(100% - 40px)' 决定)
            const gridRect = grid.getBoundingClientRect();
            const actualGridWidth = gridRect.width;

            if (actualGridWidth <= 0) { // 如果元素不可见，则延迟执行
                setTimeout(renderLockscreenWidgets, 50);
                return;
            }

            const gap = 15;

            // 2. 根据 grid 的实际宽度，计算出完美的1:1单元格尺寸
            const cellSize = (actualGridWidth - (3 * gap)) / 4;
            
            if (cellSize <= 0) return; // 防止无效计算

            // 3. 根据单元格尺寸，反向计算出网格容器应有的总高度
            const requiredGridHeight = (8 * cellSize) + (7 * gap);
            
            // 4. 关键：只强制设置高度，宽度由CSS类控制
            grid.style.height = `${requiredGridHeight}px`;

            const widgetsData = currentConfig.lockscreenWidgets || {};
            
            Object.keys(widgetsData).forEach(startIndexStr => {
                const startIndex = parseInt(startIndexStr, 10);
                const widgetConfig = widgetsData[startIndex]?.[0];

                if (!widgetConfig) return;

                const startRow_0based = Math.floor(startIndex / 4);
                const startCol_0based = startIndex % 4;
                const [cols, rows] = widgetConfig.size.split('x').map(Number);
                
                // 5. 使用统一的 cellSize 进行所有位置和尺寸的计算
                const top = startRow_0based * (cellSize + gap);
                const left = startCol_0based * (cellSize + gap);
                const width = (cols * cellSize) + ((cols - 1) * gap);
                const height = (rows * cellSize) + ((rows - 1) * gap);

                const componentContainer = document.createElement('div');
                componentContainer.style.position = 'absolute';
                Object.assign(componentContainer.style, { top: `${top}px`, left: `${left}px`, width: `${width}px`, height: `${height}px` });

                if (widgetConfig.type === 'html') componentContainer.classList.add('html-widget-container');
                
                const widgetEl = document.createElement('div');
                widgetEl.className = 'widget';

                if (widgetConfig.shape === 'circle') {
                    widgetEl.classList.add(cols === rows ? 'widget-shape-circle' : 'widget-shape-capsule');
                } else {
                    widgetEl.classList.add('widget-shape-square');
                }

                if (widgetConfig.background) {
                    if (widgetConfig.background.startsWith('data:image')) {
                        widgetEl.style.backgroundImage = `url(${widgetConfig.background})`;
                        widgetEl.style.backgroundSize = 'cover';
                        widgetEl.style.backgroundPosition = 'center';
                        if (widgetConfig.type === 'shortcut') {
                           widgetEl.style.color = 'transparent';
                           widgetEl.style.textIndent = '9999px';
                           widgetEl.style.overflow = 'hidden';
                        }
                    } else {
                        widgetEl.style.backgroundColor = widgetConfig.background;
                        widgetEl.style.backgroundImage = 'none';
                    }
                }

                switch (widgetConfig.type) {
                    case 'image':
                        widgetEl.classList.add('widget-image');
                        const img = document.createElement('img');
                        img.alt = 'Image Widget';
                        getSecureFileUrl(widgetConfig.content).then(url => { if (url) img.src = url; });
                        widgetEl.appendChild(img);
                        break;
                    case 'memo':
                        const memo = memoryCache.memo.notes.find(n => n.id === widgetConfig.content);
                        widgetEl.classList.add('widget-memo');
                        if (memo) {
                            if (widgetConfig.size === '1x1') {
                                widgetEl.innerHTML = '&#9993;';
                                widgetEl.style.fontSize = '2em';
                            } else {
                                widgetEl.classList.remove('widget-shape-circle', 'widget-shape-capsule');
                                widgetEl.classList.add('widget-shape-square');
                                
                                const titleEl = document.createElement('div');
                                titleEl.className = 'widget-memo-title';
                                titleEl.textContent = memo.title || '无标题';
                                
                                const contentEl = document.createElement('div');
                                contentEl.className = 'widget-memo-content';
                                contentEl.innerHTML = memo.content || '无内容';
                                
                                // [V2 修复] 计算并应用 line-clamp
                                const heightInUnits = parseInt(rows, 10);
                                if (heightInUnits > 0) {
                                    const lineClampValue = 1 + (heightInUnits - 1) * 2;
                                    contentEl.style.webkitLineClamp = lineClampValue;
                                    contentEl.style.setProperty('-webkit-line-clamp', lineClampValue); // 确保生效
                                }

                                widgetEl.append(titleEl, contentEl);
                            }
                            widgetEl.style.cursor = 'pointer';
                            widgetEl.onclick = () => showMemoPopup(widgetConfig.content);
                        } else {
                            widgetEl.textContent = '备忘录未找到';
                        }
                        break;
                    case 'shortcut':
                        const buttonConfig = findButtonConfigByHref(widgetConfig.content);
                        widgetEl.classList.add('widget-shortcut');
                        widgetEl.textContent = buttonConfig ? buttonConfig.text : '快捷方式';
                        widgetEl.dataset.href = widgetConfig.content;
                        widgetEl.addEventListener('click', function (e) {
                            e.stopPropagation();
                            const href = this.dataset.href;
                            
                            // [新增] 开始计时 (因为这个点击事件会直接打开iframe)
                            startUsageTracking(href);

                            const config = findButtonConfigByHref(href);
                            if (config && config.openExternally) {
                                window.open(href, '_blank', 'noopener,noreferrer');
                            } else {
                                openIframeModal(href);
                            }
                        });
                        break;

                    case 'html':
                        Object.assign(widgetEl.style, { padding: '0', overflow: 'hidden' });
                        const iframe = document.createElement('iframe');
                        iframe.className = 'widget-html-iframe';
                        iframe.srcdoc = widgetConfig.content || '<p style="color: inherit; opacity: 0.6;">未提供HTML内容</p>';
                        iframe.scrolling = 'no';
                        widgetEl.appendChild(iframe);
                        break;
                }
                
                componentContainer.appendChild(widgetEl);
                grid.appendChild(componentContainer);
            });

            // ★ 核心修复：在此处添加判断逻辑
            if (Object.keys(widgetsData).length === 0) {
                grid.innerHTML = '<p style="color: var(--text-day); opacity: 0.6; font-size: 16px; text-align: center; line-height: 1.5;">无组件<br>右滑进入主屏幕</p>';
            }
        }

        // 初始化手机模式管理器
        MobileModeManager.init();
        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */
        // ★★★ 新增：通过 GitHub GraphQL API 获取 Giscus 统计数据的函数
        async function fetchGiscusStats(phoneId, phoneName) {
            // 检查 GitHub 配置是否完整
            if (!GITHUB_CONFIG.owner || !GITHUB_CONFIG.repo || !GITHUB_CONFIG.token) {
                console.warn("GitHub config is incomplete. Cannot fetch Giscus stats.");
                return null;
            }
            // [核心修改] 硬编码为社区评论仓库，而不是使用用户的个人数据仓库
            const repoOwner = 'Yeexein';
            const repoName = 'Jellyfish-Comments';
            // Giscus 讨论区的固定 ID，从你的 HTML 配置中获取
            const categoryId = "DIC_kwDOQBfb-84CwlT0";
            // Giscus 用来唯一标识帖子的标题
            const discussionTitle = `手机安利区: ${phoneName} (${phoneId})`;

            // 构造 GraphQL 查询语句
            const query = `
                query DiscussionStats($repoOwner: String!, $repoName: String!, $categoryId: ID!, $discussionTitle: String!) {
                  repository(owner: $repoOwner, name: $repoName) {
                    discussions(categoryId: $categoryId, first: 1, filterBy: {discussionTitle: $discussionTitle}) {
                      nodes {
                        comments {
                          totalCount
                        }
                        reactions {
                          totalCount
                        }
                        reactionGroups {
                          content
                          users {
                            totalCount
                          }
                        }
                      }
                    }
                  }
                }
            `;

            try {
                const response = await fetch('https://api.github.com/graphql', {
                    method: 'POST',
                    headers: {
                        'Authorization': `bearer ${GITHUB_CONFIG.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query,
                        variables: {
                            repoOwner: repoOwner, // [核心修改] 使用硬编码的 owner
                            repoName: repoName,   // [核心修改] 使用硬编码的 repo name
                            categoryId,
                            discussionTitle
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`GitHub API Error: ${response.status}`);
                }

                const json = await response.json();
                const discussion = json.data?.repository?.discussions?.nodes[0];
                
                if (!discussion) {
                    return { reactions: [], comments: 0 }; // 讨论还未创建
                }

                // Giscus 支持的表情和顺序
                const reactionOrder = ['THUMBS_UP', 'THUMBS_DOWN', 'LAUGH', 'HOORAY', 'CONFUSED', 'HEART', 'ROCKET', 'EYES'];
                const emojiMap = { 'THUMBS_UP': '👍', 'THUMBS_DOWN': '👎', 'LAUGH': '😄', 'HOORAY': '🎉', 'CONFUSED': '😕', 'HEART': '❤️', 'ROCKET': '🚀', 'EYES': '👀' };

                const reactions = reactionOrder.map(content => {
                    const group = discussion.reactionGroups.find(g => g.content === content);
                    return {
                        emoji: emojiMap[content],
                        count: group ? group.users.totalCount : 0
                    };
                }).filter(r => r.count > 0); // 只保留有计数的表情

                return {
                    reactions,
                    comments: discussion.comments.totalCount
                };
            } catch (error) {
                console.error('Failed to fetch Giscus stats:', error);
                return null;
            }
        }

        /* =============================================================== */
        /* ================== [重构] 手机收藏馆逻辑 v2 (支持筛选) ========== */
        /* =============================================================== */
        const PhoneCollectionManager = (() => {
            // 数据源保持不变
            const phoneData = [
                { id: 'eve-phone', name: 'EVE', authorId: '7551854600', acquisition: 'QQ群购买', price: '19.9元', status: '暂时停售' },
                { id: 'jrsy-phone', name: 'jrsy小手机', authorId: '6536602273', acquisition: 'QQ群', price: '5.2元', status: '在售' },
                { id: 'threeseven-phone', name: '37 Chat', authorId: '26299019345', acquisition: '小红书购买', price: '21.14元', status: '内测' },
                { id: 'fruit-phone', name: '果咩机', authorId: '26962794223', acquisition: '小红书进群', price: '无偿', status: '开放' },
                { id: 'bubble-phone', name: '气泡机', authorId: '26962794223', acquisition: '小红书进群', price: '无偿', status: '开放' },
                { id: 'glutinousrice-phone', name: '糯米机', authorId: '933580405', acquisition: 'QQ群', price: '无偿', status: '开放' },
                { id: 'whale-phone', name: 'WhaleLLT', authorId: '42944921236', acquisition: 'QQ群', price: '无偿', status: '获取版权，暂关闭' },
                { id: 'koko-phone', name: 'koko小手机', authorId: '970432882', acquisition: 'QQ群', price: '14.9元', status: '在售' },
                { id: 'mumu-phone', name: '慕慕小手机', authorId: '26211349174', acquisition: 'QQ群', price: '19.9元', status: '内测，在售' },
                { id: 'raven-phone', name: 'RavenPhone', authorId: '999988424', acquisition: 'DC专属社区，需审核', price: '无偿', status: '开放' },
                { id: 'threethree-phone', name: '33聊天室', authorId: '124491716', acquisition: '小红书购买', price: '9.9元', status: '已停售' },
                { id: 'mujian-phone', name: '幕间小手机', authorId: '9240783072', acquisition: 'QQ群', price: '无偿', status: '2.0内测中' },
                { id: 'tuk-phone', name: 'EPhone-兔K', authorId: 'glacier1024', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'maomaoning-phone', name: 'EPhone-猫猫宁', authorId: '94903121580', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'yique-phone', name: 'EPhone-以雀', authorId: '571856738', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'threethreezero-phone', name: 'EPhone-330', authorId: '（没找到）', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'jcy-phone', name: 'EPhone-JCY', authorId: '（没找到）', acquisition: 'DC社区：尾巴镇', price: '无偿', status: '开放' },
                { id: 'youzi-phone', name: '柚子机', authorId: '5007799940', acquisition: 'QQ群', price: '无偿', status: '开放测试' },
                { id: 'jing-phone', name: '镜', authorId: 'il_057', acquisition: 'QQ群', price: '无偿', status: '开放' },
            ];

            const ui = {
                collectionModal: document.getElementById('phoneCollectionModal'),
                detailModal: document.getElementById('phoneDetailModal'),
                listContainer: document.getElementById('phone-list-container'),
                detailContainer: document.getElementById('phone-detail-content'),
                detailTitle: document.getElementById('phone-detail-title'),
                searchInput: document.getElementById('phoneSearchInput'),
                // 新增筛选相关UI元素
                filterBtn: document.getElementById('phoneFilterBtn'),
                filterModal: document.getElementById('phoneFilterModal'),
                selectedFiltersContainer: document.getElementById('selected-filters-container'),
                applyFiltersBtn: document.getElementById('apply-filters-btn'),
                clearFiltersBtn: document.getElementById('clear-filters-btn'),
            };

            const filterOptions = {
                status: [ '开放', '在售', '停售', '内测', '关闭' ],
                price: [ '有偿', '无偿' ],
                user: [
                    { text: '已拥有', value: 'owned' },
                    { text: '愿望单', value: 'wishlist' },
                    { text: '未拥有', value: 'not_owned' }
                ]
            };
            
            let activeFilters = []; // 存储结构: { group: 'status', value: '在售' }

            // 状态管理函数保持不变
            function getCollectionStatus() { try { return JSON.parse(localStorage.getItem('phoneCollectionStatus') || '{}'); } catch (e) { return {}; } }
            function saveCollectionStatus(statusData) { localStorage.setItem('phoneCollectionStatus', JSON.stringify(statusData)); }
            function getRandomMacaronColor() { const p = ['#FFD1DC','#C5E0F2','#D9C7F5','#D5ECD9','#FFEDCC','#FBBEAD','#FFF4F4','#D6F0E6','#F0D6E8','#E5F2BC','#A5E1D4','#F8F5F0','#F7E0B3']; const u = new Set(Object.values(getCollectionStatus()).map(s=>s.color)); const a = p.filter(c=>!u.has(c)); return a.length>0?a[Math.floor(Math.random()*a.length)]:p[Math.floor(Math.random()*p.length)]; }
            function getPinnedPhones() { try { return JSON.parse(localStorage.getItem('pinnedPhones') || '[]'); } catch (e) { return []; } }
            function savePinnedPhones(pinnedIds) { localStorage.setItem('pinnedPhones', JSON.stringify(pinnedIds)); }
            // Giscus 相关函数保持不变
            function getGiscusTheme() { const i=document.body.classList.contains('dark-mode'),g=document.body.classList.contains('theme-glass'); return g?(i?'transparent_dark':'light'):(i?'dark':'light'); }
            function showGiscusComments(phoneId, phoneName) { const m=document.getElementById('phoneCommentsModal'),c=m.querySelector('.giscus');c.innerHTML='';const s=document.createElement('script'),a={'src':'https://giscus.app/client.js','data-repo':'Yeexein/Jellyfish-Comments','data-repo-id':'R_kgDOQBfb-w','data-category':'Announcements','data-category-id':'DIC_kwDOQBfb-84CwlT0','data-mapping':'specific','data-term':`手机安利区: ${phoneName} (${phoneId})`,'data-strict':'0','data-reactions-enabled':'1','data-emit-metadata':'0','data-input-position':'top','data-theme':getGiscusTheme(),'data-lang':'zh-CN','crossorigin':'anonymous','async':''};Object.entries(a).forEach(([k,v])=>s.setAttribute(k,v));c.appendChild(s);document.getElementById('phone-comments-title').textContent=`${phoneName} - 安利区`;m.classList.add('show');}

            
            // ★★★ 新增：核心标签映射逻辑 ★★★
            function getPhoneTags(phone) {
                const tags = [];
                // 价格标签
                if (phone.price.includes('无偿') || phone.price.includes('免费')) {
                    tags.push({ group: 'price', value: '无偿' });
                } else {
                    tags.push({ group: 'price', value: '有偿' });
                }
                // 状态标签 (简化逻辑)
                if (phone.status.includes('开放')) tags.push({ group: 'status', value: '开放' });
                else if (phone.status.includes('在售')) tags.push({ group: 'status', value: '在售'});
                else if (phone.status.includes('停售')) tags.push({ group: 'status', value: '停售' });
                else if (phone.status.includes('内测')) tags.push({ group: 'status', value: '内测' });
                else tags.push({ group: 'status', value: '关闭' });
                
                return tags;
            }

            // ★★★ 新增：检查手机是否匹配筛选条件的函数 ★★★
            function checkPhoneFilter(phone, filter) {
                switch(filter.group) {
                    case 'status':
                    case 'price':
                        return getPhoneTags(phone).some(tag => tag.group === filter.group && tag.value === filter.value);
                    case 'user':
                        const userStatusData = getCollectionStatus()[phone.id];
                        const userStatus = userStatusData ? userStatusData.status : 'not_owned';
                        return userStatus === filter.value;
                    default:
                        return true;
                }
            }
            
            // ★★★ 新增：填充筛选模态框的选项 ★★★
            function populateFilterOptions() {
                Object.keys(filterOptions).forEach(group => {
                    const container = document.getElementById(`filter-options-${group}`);
                    if (!container) return;
                    container.innerHTML = '';
                    filterOptions[group].forEach(option => {
                        const text = typeof option === 'string' ? option : option.text;
                        const value = typeof option === 'string' ? option : option.value;
                        const optionEl = document.createElement('button');
                        optionEl.className = 'filter-tag-option';
                        optionEl.textContent = text;
                        optionEl.dataset.group = group;
                        optionEl.dataset.value = value;
                        container.appendChild(optionEl);
                    });
                });
            }

            // ★★★ 新增：更新筛选器UI的函数 ★★★
            function updateFilterSelectionUI() {
                // 更新已选中的标签区域
                ui.selectedFiltersContainer.innerHTML = '';
                activeFilters.forEach(filter => {
                    const text = filterOptions[filter.group].find(opt => (typeof opt === 'string' ? opt : opt.value) === filter.value)?.text || filter.value;
                    const tagEl = document.createElement('div');
                    tagEl.className = 'selected-filter-tag';
                    tagEl.innerHTML = `<span>${text}</span><span class="remove-tag-btn" data-group="${filter.group}" data-value="${filter.value}">&times;</span>`;
                    ui.selectedFiltersContainer.appendChild(tagEl);
                });

                // 更新可选标签的 .selected 状态
                ui.filterModal.querySelectorAll('.filter-tag-option').forEach(optionEl => {
                    const isSelected = activeFilters.some(f => f.group === optionEl.dataset.group && f.value === optionEl.dataset.value);
                    optionEl.classList.toggle('selected', isSelected);
                });
            }
            
            // ★★★ 重构：主列表渲染函数 ★★★
            function displayPhoneList() {
                const searchTerm = ui.searchInput.value.toLowerCase().trim();
                const pinnedIds = getPinnedPhones();

                // 1. 文本搜索过滤
                let filteredPhones = phoneData.filter(phone => 
                    phone.name.toLowerCase().includes(searchTerm) ||
                    phone.authorId.toLowerCase().includes(searchTerm)
                );

                // 2. 标签筛选
                if (activeFilters.length > 0) {
                    const groupedFilters = activeFilters.reduce((acc, filter) => {
                        if (!acc[filter.group]) acc[filter.group] = [];
                        acc[filter.group].push(filter);
                        return acc;
                    }, {});

                    filteredPhones = filteredPhones.filter(phone => {
                        // AND logic between groups
                        return Object.values(groupedFilters).every(group => {
                            // OR logic within a group
                            return group.some(filter => checkPhoneFilter(phone, filter));
                        });
                    });
                }
                
                // 3. 置顶和排序逻辑 (保持不变)
                const pinnedPhones = [];
                const unpinnedPhones = [];
                filteredPhones.forEach(phone => {
                    if (pinnedIds.includes(phone.id)) {
                        pinnedPhones.push(phone);
                    } else {
                        unpinnedPhones.push(phone);
                    }
                });
                for (let i = unpinnedPhones.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [unpinnedPhones[i], unpinnedPhones[j]] = [unpinnedPhones[j], unpinnedPhones[i]];
                }
                
                renderPhoneList([...pinnedPhones, ...unpinnedPhones]);
            }

            // ★★★ 重构：列表项渲染函数 (保持不变，因为状态是在CSS中应用的) ★★★
             function renderPhoneList(phonesToRender) {
                ui.listContainer.innerHTML = '';
                if (phonesToRender.length === 0) {
                    ui.listContainer.innerHTML = '<p class="empty-list-placeholder" style="grid-column: 1 / -1;">未找到匹配的手机</p>';
                    return;
                }
                const allStatuses = getCollectionStatus();
                phonesToRender.forEach(phone => {
                    const item = document.createElement('div');
                    item.className = 'phone-partition-item';
                    item.dataset.phoneId = phone.id;
                    item.innerHTML = `<div class="phone-partition-icon">${phone.icon || ''}</div><div class="phone-partition-name">${phone.name}</div>`;
                    item.style.animationDelay = `${Math.random() * -6}s`;
                    const statusData = allStatuses[phone.id];
                    if (statusData) {
                        item.classList.add(`status-${statusData.status}`);
                        item.style.setProperty('--status-color', statusData.color);
                    }
                    item.addEventListener('click', () => renderPhoneDetail(phone.id));
                    ui.listContainer.appendChild(item);
                });
            }

            // ★★★ 重构：详情页渲染函数 v2 (恢复独立售价和状态) ★★★
            function renderPhoneDetail(phoneId) {
                const phone = phoneData.find(p => p.id === phoneId);
                if (!phone) return;

                const statusBtn = document.getElementById('phoneStatusBtn');
                const statusMenu = document.getElementById('phoneStatusMenu');

                // 核心：更新状态按钮的UI
                function updateStatusButtonUI() {
                    const currentStatus = getCollectionStatus()[phoneId];
                    if (!currentStatus) {
                        statusBtn.innerHTML = '◌';
                        statusBtn.style.color = 'inherit';
                    } else if (currentStatus.status === 'owned') {
                        statusBtn.innerHTML = '★';
                        statusBtn.style.color = '#ffc107'; // 黄色
                    } else if (currentStatus.status === 'wishlist') {
                        statusBtn.innerHTML = '♥';
                        statusBtn.style.color = '#ff85a2'; // 粉色
                    }
                }
                
                ui.detailTitle.textContent = phone.name;
                updateStatusButtonUI();

                // 移除并重新绑定事件，防止重复监听
                if (statusMenu.handler) statusMenu.removeEventListener('click', statusMenu.handler);
                if (statusBtn.handler) statusBtn.removeEventListener('click', statusBtn.handler);
                if (window.currentHideMenuHandler) document.body.removeEventListener('click', window.currentHideMenuHandler);

                statusBtn.handler = (e) => { e.stopPropagation(); statusMenu.classList.toggle('show'); };
                statusBtn.addEventListener('click', statusBtn.handler);

                statusMenu.handler = (e) => {
                    const button = e.target.closest('.status-option-btn');
                    if (button) {
                        const newStatus = button.dataset.status;
                        const allStatuses = getCollectionStatus();
                        if (newStatus === 'none') {
                            delete allStatuses[phoneId];
                            showTopToast(`已将 "${phone.name}" 恢复为未拥有`, 2000);
                        } else {
                            const currentColor = allStatuses[phoneId]?.color || getRandomMacaronColor();
                            allStatuses[phoneId] = { status: newStatus, color: currentColor };
                            const statusText = newStatus === 'owned' ? '已拥有' : '已加入愿望单';
                            showTopToast(`已将 "${phone.name}" 标记为 ${statusText}`, 2000);
                        }
                        saveCollectionStatus(allStatuses);
                        statusMenu.classList.remove('show');
                        updateStatusButtonUI();
                        displayPhoneList(); // 刷新主列表以同步状态颜色
                    }
                };
                statusMenu.addEventListener('click', statusMenu.handler);

                window.currentHideMenuHandler = (e) => {
                    if (!statusBtn.contains(e.target) && !statusMenu.contains(e.target)) {
                        statusMenu.classList.remove('show');
                    }
                };
                document.body.addEventListener('click', window.currentHideMenuHandler);
                
                // ★★★ 核心修改：恢复独立的售价和状态展示 ★★★
                ui.detailContainer.innerHTML = `
                    <div class="detail-info-group">
                        <label>作者ID</label>
                        <div class="detail-info-value copyable" data-id="${phone.authorId}">
                            <span>${phone.authorId}</span>
                            <span>❏</span>
                        </div>
                    </div>
                    <div class="detail-info-group">
                        <label>获取方式</label>
                        <div class="detail-info-value">${phone.acquisition}</div>
                    </div>
                    <div class="detail-info-group">
                        <label>售价</label>
                        <div class="detail-info-value">${phone.price}</div>
                    </div>
                    <div class="detail-info-group">
                        <label>状态</label>
                        <div class="detail-info-value">${phone.status}</div>
                    </div>
                    <button id="enterCommentsBtn" class="modal-button" data-phone-id="${phone.id}" style="margin-top: 10px;">进入安利区</button>
                    `;
                
                // 为复制和评论按钮绑定事件
                ui.detailContainer.querySelector('.copyable').addEventListener('click', function() {
                    navigator.clipboard.writeText(this.dataset.id).then(() => showTopToast(`已复制作者ID: ${this.dataset.id}`, 2000));
                });
                
                ui.detailContainer.querySelector('#enterCommentsBtn').addEventListener('click', function() {
                    const phoneForComment = phoneData.find(p => p.id === this.dataset.phoneId);
                    if (!phoneForComment) return;
                    const hasSeenNotice = localStorage.getItem('communityNoticeSeen') === 'true';
                    if (hasSeenNotice) {
                        ui.detailModal.classList.remove('show');
                        setTimeout(() => showGiscusComments(phoneForComment.id, phoneForComment.name), 200);
                    } else {
                        const noticeModal = document.getElementById('communityNoticeModal');
                        noticeModal.classList.add('show');
                        const confirmBtn = document.getElementById('confirmNoticeBtn');
                        const newConfirmBtn = confirmBtn.cloneNode(true);
                        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                        newConfirmBtn.addEventListener('click', () => {
                            if (document.getElementById('dontRemindCheckbox').checked) {
                                localStorage.setItem('communityNoticeSeen', 'true');
                                document.getElementById('showNoticeBell').style.display = 'block';
                            }
                            noticeModal.classList.remove('show');
                            ui.detailModal.classList.remove('show');
                            setTimeout(() => showGiscusComments(phoneForComment.id, phoneForComment.name), 200);
                        });
                    }
                });

                ui.detailModal.classList.add('show');
            }


             return {
                init() {
                    // ★★★ 新增：清除筛选条件的函数 ★★★
                    const clearAllFilters = () => {
                        activeFilters = [];
                        ui.searchInput.value = '';
                        updateFilterSelectionUI();
                    };

                    document.getElementById('phoneCollectionBtn').addEventListener('click', () => {
                        clearAllFilters(); // 打开时先清除旧的
                        displayPhoneList(); 
                        ui.collectionModal.classList.add('show'); 
                        toggleFabMenu(false);
                        document.getElementById('showNoticeBell').style.display = localStorage.getItem('communityNoticeSeen') === 'true' ? 'block' : 'none';
                    });

                    // ★★★ 新增：为主模态框的关闭按钮和背景点击添加清除筛选的逻辑 ★★★
                    const closeBtn = ui.collectionModal.querySelector('.close-btn');
                    if(closeBtn) closeBtn.addEventListener('click', clearAllFilters);
                    ui.collectionModal.addEventListener('click', (e) => {
                        if (e.target === ui.collectionModal) {
                            clearAllFilters();
                        }
                    });

                    document.getElementById('showNoticeBell').addEventListener('click', () => document.getElementById('communityNoticeModal').classList.add('show'));
                    ui.searchInput.addEventListener('input', displayPhoneList);
                    
                    // 初始化筛选器
                    populateFilterOptions();
                    
                    ui.filterBtn.addEventListener('click', () => ui.filterModal.classList.add('show'));
                    ui.applyFiltersBtn.addEventListener('click', () => { displayPhoneList(); ui.filterModal.classList.remove('show'); });
                    ui.clearFiltersBtn.addEventListener('click', () => { activeFilters = []; updateFilterSelectionUI(); });
                    
                    // 筛选模态框内的点击事件委托
                    ui.filterModal.addEventListener('click', (e) => {
                        const option = e.target.closest('.filter-tag-option');
                        const removeBtn = e.target.closest('.remove-tag-btn');
                        
                        if (option && !option.classList.contains('selected')) {
                            // 增加 text 属性，方便在“已选”区域显示
                            activeFilters.push({ group: option.dataset.group, value: option.dataset.value, text: option.textContent });
                        } else if (removeBtn) {
                            activeFilters = activeFilters.filter(f => !(f.group === removeBtn.dataset.group && f.value === removeBtn.dataset.value));
                        } else {
                            return;
                        }
                        updateFilterSelectionUI();
                    });
                },
                getGiscusTheme: getGiscusTheme
            };
        })();

        // 初始化手机收藏馆
        PhoneCollectionManager.init();
        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */
        
        /* =============================================================== */
        /* ================== [新增] 全局字体管理逻辑 (V2) =================== */
        /* =============================================================== */
        const FontManager = (() => {
            const FONT_FAMILY_NAME = 'GlobalCustomFont'; // 使用一个固定的内部字体族名

            const ui = {
                styleTag: document.getElementById('global-font-style'),
                urlInput: document.getElementById('fontUrlInput'),
                applyBtn: document.getElementById('applyFontBtn'),
                clearBtn: document.getElementById('clearFontBtn'),
                presetSelector: document.getElementById('fontPresetSelector'),
                addPresetBtn: document.getElementById('addFontPresetBtn'),
                updatePresetBtn: document.getElementById('updateFontPresetBtn'),
                deletePresetBtn: document.getElementById('deleteFontPresetBtn'),
            };

            function applyFont(fontUrl) {
                if (fontUrl) {
                    const fontFaceRule = `@font-face {
                        font-family: '${FONT_FAMILY_NAME}';
                        src: url('${fontUrl}');
                        font-display: swap;
                    }`;
                    const globalRule = `* {
                        font-family: '${FONT_FAMILY_NAME}', Arial, -apple-system, BlinkMacSystemFont, sans-serif !important;
                    }`;
                    ui.styleTag.innerHTML = fontFaceRule + '\n' + globalRule;
                } else {
                    ui.styleTag.innerHTML = ''; // 清空样式以恢复默认
                }
            }

            function populatePresetDropdown() {
                const currentVal = ui.presetSelector.value;
                ui.presetSelector.innerHTML = '<option value="">选择或管理预设...</option>';
                if (!currentConfig.settings.fontPresets) {
                    currentConfig.settings.fontPresets = [];
                }
                currentConfig.settings.fontPresets.forEach((preset, index) => {
                    ui.presetSelector.innerHTML += `<option value="${index}">${preset.name}</option>`;
                });
                if (currentVal) ui.presetSelector.value = currentVal;
            }

            function loadCurrentSettings() {
                const fontSettings = currentConfig.settings.globalFont || { url: '' };
                ui.urlInput.value = fontSettings.url;
                applyFont(fontSettings.url);
                populatePresetDropdown();
            }

            function setupEventListeners() {
                ui.applyBtn.addEventListener('click', () => {
                    const fontUrl = ui.urlInput.value.trim();
                    if (!fontUrl) {
                        alert('字体链接不能为空！');
                        return;
                    }
                    applyFont(fontUrl);
                    currentConfig.settings.globalFont = { name: FONT_FAMILY_NAME, url: fontUrl };
                    saveGlobalConfig('Apply global font');
                    showTopToast('全局字体已应用！', 2000);
                });

                ui.clearBtn.addEventListener('click', () => {
                    ui.urlInput.value = '';
                    applyFont('');
                    currentConfig.settings.globalFont = { name: '', url: '' };
                    saveGlobalConfig('Clear global font');
                    showTopToast('已恢复默认字体。', 2000);
                });

                ui.presetSelector.addEventListener('change', () => {
                    const index = ui.presetSelector.value;
                    if (index === '') {
                        // 如果选择 "选择预设"，则恢复到当前非预设状态
                        const currentFont = currentConfig.settings.globalFont;
                        ui.urlInput.value = currentFont.url;
                        applyFont(currentFont.url);
                        return;
                    }
                    const preset = currentConfig.settings.fontPresets[index];
                    if (preset) {
                        ui.urlInput.value = preset.url;
                        applyFont(preset.url);
                        currentConfig.settings.globalFont = { name: FONT_FAMILY_NAME, url: preset.url };
                        saveGlobalConfig('Apply font preset');
                    }
                });

                ui.addPresetBtn.addEventListener('click', () => {
                    const presetName = prompt('请输入新预设的名称：');
                    if (!presetName || presetName.trim() === '') return;
                    
                    const fontUrl = ui.urlInput.value.trim();
                    if (!fontUrl) {
                        alert('字体链接不能为空，无法保存预设。');
                        return;
                    }
                    if (currentConfig.settings.fontPresets.some(p => p.name === presetName.trim())) {
                        alert('该预设名称已存在！');
                        return;
                    }
                    
                    currentConfig.settings.fontPresets.push({
                        name: presetName.trim(),
                        url: fontUrl
                    });
                    saveGlobalConfig(`Save font preset: ${presetName.trim()}`);
                    populatePresetDropdown();
                    ui.presetSelector.value = currentConfig.settings.fontPresets.length - 1;
                    showTopToast('预设已保存！', 2000);
                });

                ui.updatePresetBtn.addEventListener('click', () => {
                    const index = ui.presetSelector.value;
                    if (index === '') {
                        alert('请先从下拉框中选择一个要修改的预设。');
                        return;
                    }

                    const presetToUpdate = currentConfig.settings.fontPresets[index];
                    const newName = prompt('请输入新的预设名称：', presetToUpdate.name);

                    if (!newName || newName.trim() === '') {
                        return; // 用户取消或输入为空
                    }
                    
                    const trimmedNewName = newName.trim();
                    
                    // 检查新名称是否与自身相同（大小写不敏感）
                    if (trimmedNewName.toLowerCase() === presetToUpdate.name.toLowerCase()) {
                        return; // 名称未改变
                    }

                    // 检查新名称是否与其他预设冲突（排除自身）
                    const isDuplicate = currentConfig.settings.fontPresets.some((p, i) => 
                        i !== parseInt(index) && p.name.toLowerCase() === trimmedNewName.toLowerCase()
                    );

                    if (isDuplicate) {
                        alert('该预设名称已存在，请换一个名称。');
                        return;
                    }

                    const oldName = presetToUpdate.name;
                    presetToUpdate.name = trimmedNewName;
                    
                    saveGlobalConfig(`Rename font preset from "${oldName}" to "${trimmedNewName}"`);
                    // 刷新下拉列表以显示新名称，并保持选中状态
                    populatePresetDropdown();
                    ui.presetSelector.value = index; 
                    
                    showTopToast(`预设已重命名为 "${trimmedNewName}"！`, 2000);
                });


                ui.deletePresetBtn.addEventListener('click', () => {
                    const index = ui.presetSelector.value;
                    if (index === '') {
                        alert('请先从下拉框中选择一个要删除的预设。');
                        return;
                    }
                    
                    const presetName = currentConfig.settings.fontPresets[index].name;
                    if (confirm(`确定要删除预设 "${presetName}" 吗？`)) {
                        currentConfig.settings.fontPresets.splice(index, 1);
                        saveGlobalConfig(`Delete font preset: ${presetName}`);
                        populatePresetDropdown();
                        // 删除后，将输入框和应用状态恢复到当前保存的全局设置
                        const currentFont = currentConfig.settings.globalFont;
                        ui.urlInput.value = currentFont.url;
                        applyFont(currentFont.url);
                        showTopToast('预设已删除。', 2000);
                    }
                });
            }

            return {
                init() {
                    loadCurrentSettings();
                    setupEventListeners();
                }
            };
        })();


        // 初始化字体管理器
        FontManager.init();
        
        // [核心修正] 初始化备份提醒管理器
        // 1. 先调用 initUI() 找到所有HTML元素
        BackupReminderManager.initUI();
        // 2. 再调用 init() 为这些元素绑定事件
        BackupReminderManager.init();
        /* =============================================================== */
        /* ==================== [新增] 初始化挂件与签到管理器 ===================== */
        /* =============================================================== */
        PendantManager.init();
        // [V3.0 最终修复] 确保签到管理器在挂件系统之后初始化，保证数据流正确
        CheckInManager.init();

        /* =============================================================== */
        /* ========================= [新增结束] ========================== */
        /* =============================================================== */

    });

/* =============================================================== */
/* ================== [新增] 留言板功能管理器 V2 ================== */
/* =============================================================== */
const MessageBoardManager = (() => {
    let ui = {};
    let isEditing = false;
    let editingMessageId = null;
    let reminderInterval = null;
    let pendingBgImageDataUrl = null;

    // [新增] 日期格式化辅助函数
    function getFormattedDate(dateObj) {
        const year = dateObj.getFullYear();
        const month = String(dateObj.getMonth() + 1).padStart(2, '0');
        const day = String(dateObj.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    };

    function init() {

        ui = {
            container: document.getElementById('message-board-container'),
            modal: document.getElementById('messageBoardModal'),
            modalTitle: document.getElementById('messageModalTitle'),
            titleInput: document.getElementById('messageTitleInput'),
            linkProjectSelect: document.getElementById('messageLinkProjectSelect'),
            reminderToggle: document.getElementById('messageReminderToggle'),
            reminderDetails: document.getElementById('messageReminderDetails'),
            reminderTimeInput: document.getElementById('messageReminderTime'),
            allDayToggle: document.getElementById('messageAllDayToggle'),
            saveBtn: document.getElementById('saveMessageBtn'),
            deleteBtn: document.getElementById('deleteMessageBtn'), // [需求新增] 删除按钮
            bgImagePicker: document.getElementById('messageBgImagePicker'),
            uploadBgBtn: document.getElementById('uploadMessageBgBtn'),
            clearBgBtn: document.getElementById('clearMessageBgBtn'),
        };

        ui.container.addEventListener('mousedown', handleSwipeStart);
        ui.container.addEventListener('touchstart', handleSwipeStart, { passive: true });
        
        ui.reminderToggle.addEventListener('change', () => {
            ui.reminderDetails.style.display = ui.reminderToggle.checked ? 'flex' : 'none';
        });

        // [需求修改] 全天提醒开关控制时间选择器的显隐
        ui.allDayToggle.addEventListener('change', () => {
             // 获取时间输入框的父容器（通常是 .form-section）
            const timeInputContainer = ui.reminderTimeInput.closest('.form-section') || ui.reminderTimeInput;
            const isAllDay = ui.allDayToggle.checked;
            
            timeInputContainer.style.display = isAllDay ? 'none' : 'block';

            if(isAllDay) {
                // 如果是全天，可以自动填充一个默认时间，但这部分对用户不可见
                const today = new Date();
                today.setHours(9, 0, 0, 0);
                ui.reminderTimeInput.value = today.toISOString().slice(0, 16);
            }
        });

        ui.saveBtn.addEventListener('click', saveMessage);
        
        // [需求新增] 为删除按钮绑定事件
        ui.deleteBtn.addEventListener('click', deleteMessage);

        ui.uploadBgBtn.addEventListener('click', () => ui.bgImagePicker.click());
        ui.bgImagePicker.addEventListener('change', handleImageUpload);
        ui.clearBgBtn.addEventListener('click', () => {
            pendingBgImageDataUrl = 'CLEARED';
            ui.uploadBgBtn.textContent = '上传图片';
            showTopToast("背景图已清除，保存后生效", 2000);
        });
        
        startReminderChecker();
    }

    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            pendingBgImageDataUrl = e.target.result;
            ui.uploadBgBtn.textContent = '已选择图片';
            showTopToast("图片已选择，保存后生效", 2000);
        };
        reader.readAsDataURL(file);
        event.target.value = '';
    }

    async function renderBoard() {
        if (!ui.container) return;

        const messageData = await DataManager.get('messageBoardData');
        if (!messageData.messages) messageData.messages = [];

        // --- [核心刷新逻辑开始] ---
        const todayStr = getFormattedDate(new Date());
        const lastResetDate = localStorage.getItem('lastMessageBoardResetDate');
        let wasReset = false;

        if (todayStr !== lastResetDate) {
            console.log("新的一天，开始重置每日提醒卡片...");
            messageData.messages.forEach(msg => {
                if (msg.reminder && msg.reminder.enabled && msg.reminder.type === 'daily' && msg.isCompleted) {
                    msg.isCompleted = false;
                    wasReset = true;
                }
            });

            if (wasReset) {
                await DataManager.save('messageBoardData', 'Reset daily message cards');
                localStorage.setItem('lastMessageBoardResetDate', todayStr);
                showTopToast("每日提醒已刷新！", 2000);
            } else {
                // 即使没有需要重置的卡片，也更新日期，避免当天重复检查
                localStorage.setItem('lastMessageBoardResetDate', todayStr);
            }
        }
        // --- [核心刷新逻辑结束] ---

        ui.container.innerHTML = '';

        const sortedMessages = [...messageData.messages].sort((a, b) => (a.isCompleted ? 1 : 0) - (b.isCompleted ? 1 : 0));

        sortedMessages.forEach(msg => {
            const card = document.createElement('div');
            card.className = `message-card ${msg.isCompleted ? 'completed' : ''}`;
            card.dataset.messageId = msg.id;

            if (msg.background) {
                card.style.backgroundImage = `url(${msg.background})`;
                card.style.backgroundSize = 'cover';
                card.style.backgroundPosition = 'center';
                card.style.color = '#FFFFFF';
            }

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-card-content-wrapper';

            const headerContainer = document.createElement('div');
            headerContainer.className = 'message-card-header';

            const titleHtml = `<div class="message-card-title">${msg.title}</div>`;
            headerContainer.innerHTML = titleHtml;

            if (msg.linkedProjectHref) {
                const project = findButtonConfigByHref(msg.linkedProjectHref);
                const projectName = project ? project.text : '未知项目';
                const linkStyle = msg.background ? 'style="background-color: rgba(0,0,0,0.3);"' : '';
                const linkHtml = `
                    <div class="message-card-link-info" ${linkStyle}>
                        <span class="link-icon">链接</span>
                        <span class="link-name">${projectName}</span>
                    </div>`;
                headerContainer.innerHTML += linkHtml;
            }

            contentWrapper.appendChild(headerContainer);
            card.appendChild(contentWrapper);
            ui.container.appendChild(card);
        });

        const addCard = document.createElement('div');
        addCard.className = 'message-card message-card--add';
        addCard.dataset.action = 'add-message-card';
        addCard.innerHTML = `<svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg><span>添加新留言</span>`;
        addCard.addEventListener('click', () => openModal());
        ui.container.appendChild(addCard);
    }

    
    let isDragging = false, startX = 0, currentX = 0, targetCard = null, isClick = true;

    function handleSwipeStart(e) {
        targetCard = e.target.closest('.message-card:not(.message-card--add)');
        if (!targetCard) return;

        isClick = true;
        isDragging = true;
        startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        targetCard.classList.add('swiping');
        
        document.addEventListener('mousemove', handleSwipeMove);
        document.addEventListener('touchmove', handleSwipeMove, { passive: false });
        document.addEventListener('mouseup', handleSwipeEnd, { once: true });
        document.addEventListener('touchend', handleSwipeEnd, { once: true });
    }

    function handleSwipeMove(e) {
        if (!isDragging || !targetCard) return;
        
        currentX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        let diffX = currentX - startX;

        if (Math.abs(diffX) > 10) {
            isClick = false; 
        }

        if (diffX < 0) diffX = 0;

        targetCard.style.transform = `translateX(${diffX}px)`;
        targetCard.style.opacity = 1 - (diffX / (targetCard.offsetWidth * 0.7));
    }

// (这是替换后的新代码)
    async function handleSwipeEnd(e) {
        if (!isDragging || !targetCard) return;
        isDragging = false;
        
        document.removeEventListener('mousemove', handleSwipeMove);
        document.removeEventListener('touchmove', handleSwipeMove);

        const diffX = currentX - startX;
        const threshold = targetCard.offsetWidth * 0.4;

        if (diffX > threshold) {
            const messageId = parseInt(targetCard.dataset.messageId, 10);
            const messageData = await DataManager.get('messageBoardData');
            const msg = messageData.messages.find(m => m.id === messageId);

            if (msg) {
                if (msg.reminder.type === 'once' && msg.reminder.enabled) {
                    targetCard.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
                    targetCard.style.transform = `translateX(${targetCard.offsetWidth}px)`;
                    targetCard.style.opacity = '0';
                    messageData.messages = messageData.messages.filter(m => m.id !== messageId);
                    await DataManager.save('messageBoardData', 'Remove one-time message');
                    PendantManager.updateReminderAnimation();
                    showTopToast("留言已完成并移除", 2000);
                    setTimeout(() => targetCard.remove(), 300);
                } else {
                    msg.isCompleted = true;
                    await DataManager.save('messageBoardData', 'Complete message');
                    PendantManager.updateReminderAnimation();
                    renderBoard();
                }
            } else {
                resetCardPosition();
            }

        } else if (isClick) {
            const linkElement = e.target.closest('.message-card-link-info');
            const messageId = parseInt(targetCard.dataset.messageId, 10);
            
            if (linkElement) {
                // --- [需求 1 实现] ---
                const messageData = await DataManager.get('messageBoardData');
                const msg = messageData.messages.find(m => m.id === messageId);
                if (msg && msg.linkedProjectHref) {
                    const projectConfig = findButtonConfigByHref(msg.linkedProjectHref);
                    // 检查项目配置是否存在以及 openExternally 是否为 true
                    if (projectConfig && projectConfig.openExternally) {
                        window.open(msg.linkedProjectHref, '_blank', 'noopener,noreferrer');
                    } else {
                        // 否则，在应用内打开
                        openIframeModal(msg.linkedProjectHref);
                    }
                }
            } else {
                openModal(messageId);
            }
            resetCardPosition();
            // --- [需求 1 实现结束] ---
        } else {
            resetCardPosition();
        }
        
        function resetCardPosition() {
            targetCard.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
            targetCard.style.transform = 'translateX(0px)';
            targetCard.style.opacity = '1';
            setTimeout(() => {
                if (targetCard) { // 添加安全检查
                    targetCard.classList.remove('swiping');
                    targetCard.style.transition = '';
                }
            }, 300);
        }
        
        targetCard = null;
        startX = 0;
        currentX = 0;
    }

    function populateProjectSelector() {
        const select = ui.linkProjectSelect;
        select.innerHTML = '<option value="">不链接任何项目</option>';
        const allButtons = currentConfig.categories.flatMap(c => c.buttons);
        const uniqueButtons = Array.from(new Map(allButtons.map(item => [item.href, item])).values());
        uniqueButtons.forEach(btn => {
            select.innerHTML += `<option value="${btn.href}">${btn.text}</option>`;
        });
    }

    async function openModal(messageId = null) {
        isEditing = !!messageId;
        editingMessageId = messageId;
        populateProjectSelector();
        pendingBgImageDataUrl = null; 
        ui.uploadBgBtn.textContent = '上传图片';
        
        // [需求修改] 控制删除按钮的显隐
        ui.deleteBtn.style.display = isEditing ? 'block' : 'none';

        if (isEditing) {
            ui.modalTitle.textContent = '编辑留言';
            const messageData = await DataManager.get('messageBoardData');
            const msg = messageData.messages.find(m => m.id === messageId);
            if (!msg) { console.error('找不到要编辑的留言'); return; }

            ui.titleInput.value = msg.title;
            ui.linkProjectSelect.value = msg.linkedProjectHref || '';
            ui.reminderToggle.checked = msg.reminder?.enabled || false;
            ui.reminderDetails.style.display = ui.reminderToggle.checked ? 'flex' : 'none';

            if (msg.background) {
                ui.uploadBgBtn.textContent = '已设置背景';
            }

            if (msg.reminder && msg.reminder.enabled) {
                ui.allDayToggle.checked = msg.reminder.isAllDay;
                // [需求修改] 控制时间输入框显隐
                const timeInputContainer = ui.reminderTimeInput.closest('.form-section') || ui.reminderTimeInput;
                timeInputContainer.style.display = msg.reminder.isAllDay ? 'none' : 'block';

                if (msg.reminder.time) {
                    const reminderDate = new Date(msg.reminder.time);
                    ui.reminderTimeInput.value = reminderDate.toISOString().slice(0, 16);
                } else {
                     ui.reminderTimeInput.value = '';
                }
                
                document.querySelector(`input[name="reminder-type"][value="${msg.reminder.type}"]`).checked = true;
            } else {
                resetReminderFields();
            }

        } else {
            ui.modalTitle.textContent = '添加新留言';
            ui.titleInput.value = '';
            ui.linkProjectSelect.value = '';
            ui.reminderToggle.checked = false;
            ui.reminderDetails.style.display = 'none';
            resetReminderFields();
        }
        
        ui.modal.classList.add('show');
    }

    function resetReminderFields() {
        ui.reminderTimeInput.value = '';
        const timeInputContainer = ui.reminderTimeInput.closest('.form-section') || ui.reminderTimeInput;
        timeInputContainer.style.display = 'block';
        ui.allDayToggle.checked = false;
        document.getElementById('reminder-type-once').checked = true;
    }

    async function saveMessage() {
        const title = ui.titleInput.value.trim();
        if (!title) return alert('标题不能为空！');
        
        const messageData = await DataManager.get('messageBoardData');
        
        let message;
        if (isEditing) {
            const index = messageData.messages.findIndex(m => m.id === editingMessageId);
            if (index > -1) message = messageData.messages[index];
            else isEditing = false;
        }
        
        if (!isEditing) {
            message = { id: Date.now(), isCompleted: false };
        }
        
        message.title = title;
        message.linkedProjectHref = ui.linkProjectSelect.value;
        message.reminder = {
            enabled: ui.reminderToggle.checked,
            time: ui.reminderTimeInput.value,
            isAllDay: ui.allDayToggle.checked,
            type: document.querySelector('input[name="reminder-type"]:checked').value
        };

        if (pendingBgImageDataUrl) {
            if (pendingBgImageDataUrl === 'CLEARED') delete message.background;
            else message.background = pendingBgImageDataUrl;
        }

        if (isEditing) {
            const index = messageData.messages.findIndex(m => m.id === editingMessageId);
            messageData.messages[index] = message;
        } else {
            messageData.messages.push(message);
        }

        await DataManager.save('messageBoardData', isEditing ? 'Edit message' : 'Add new message');
        PendantManager.updateReminderAnimation(); // ★ 核心修复：立即更新挂件状态
        ui.modal.classList.remove('show');
        renderBoard();
        showTopToast(isEditing ? '留言已更新' : '留言已添加', 2000);
    }

    // [需求新增] 删除留言的函数
    async function deleteMessage() {
        if (!isEditing || !editingMessageId) return;

        if (confirm("确定要永久删除这条留言吗？")) {
            const messageData = await DataManager.get('messageBoardData');
            messageData.messages = messageData.messages.filter(m => m.id !== editingMessageId);
            
            await DataManager.save('messageBoardData', 'Delete message');
            ui.modal.classList.remove('show');
            renderBoard();
            showTopToast('留言已删除', 2000);
        }
    }

    function startReminderChecker() {
        if (reminderInterval) clearInterval(reminderInterval);
        
        reminderInterval = setInterval(async () => {
            const messageData = await DataManager.get('messageBoardData');
            if (!messageData.messages || messageData.messages.length === 0) return;

            const now = new Date();
            let needsAction = false;

            for (const msg of messageData.messages) {
                if (!msg.reminder || !msg.reminder.enabled || !msg.reminder.time || msg.isCompleted) continue;

                const reminderTime = new Date(msg.reminder.time);
                
                let shouldTrigger = false;
                if (msg.reminder.type === 'once') {
                    if (now >= reminderTime) shouldTrigger = true;
                } else if (msg.reminder.type === 'daily') {
                    const reminderHours = reminderTime.getHours();
                    const reminderMinutes = reminderTime.getMinutes();
                    if (now.getHours() === reminderHours && now.getMinutes() === reminderMinutes) shouldTrigger = true;
                }
                
                if (shouldTrigger && msg.id.toString() !== localStorage.getItem('lastTriggeredMessage')) {
                    const pendantWrap = document.getElementById('pendant-all-wrap');
                    if (pendantWrap) {
                        pendantWrap.classList.add('remind-active');
                        setTimeout(() => pendantWrap.classList.remove('remind-active'), 5000);
                    }
                    
                    showTopToast(`留言提醒: ${msg.title}`, 5000);
                    localStorage.setItem('lastTriggeredMessage', msg.id.toString());
                    
                    if(msg.reminder.type === 'once') needsAction = true;
                }
            }
            if(needsAction) {
                // 对于一次性提醒，我们不再自动完成，仅提醒
            }

        }, 30 * 1000);
    }

    return { init, renderBoard };
})();

// 在主 DOMContentLoaded 事件中初始化留言板管理器
document.addEventListener('DOMContentLoaded', () => {
    // 确保其他模块都初始化完毕
    setTimeout(() => {
        MessageBoardManager.init();
    }, 150); // 稍微延迟以确保 DataManager 等已准备好

    // 当切换到留言板页面时，强制刷新
    const capsuleButton = document.querySelector('[data-target="widget-page-board"]');
    if (capsuleButton) {
        capsuleButton.addEventListener('click', () => {
            MessageBoardManager.renderBoard();
        });
    }
});

/* =============================================================== */
/* ========================= [新增结束] ========================== */
/* =============================================================== */


            // [新增] 锁屏组件交互事件监听
            document.getElementById('lockscreenGrid').addEventListener('click', (e) => {
                const li = e.target.closest('li[data-note-id]');
                if (!li) return;

                const noteId = parseInt(li.dataset.noteId, 10);
                const lineIndex = parseInt(li.dataset.lineIndex, 10);

                const note = memoryCache.memo.notes.find(n => n.id === noteId);
                if (!note) return;
                
                // 解析 note.content 为一个临时的DOM结构
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = note.content;

                const targetLi = tempDiv.querySelectorAll('li')[lineIndex];
                if (targetLi) {
                    // 切换完成状态
                    targetLi.classList.toggle('completed');

                    // 将修改后的 HTML 写回数据模型
                    note.content = tempDiv.innerHTML;

                    // 立即重新渲染锁屏以提供即时反馈
                    renderLockscreenWidgets();

                    // 安排云同步
                    MemoryApp.scheduleSave(); // 复用 MemoryApp 的保存逻辑
                }
            });
/* =============================================================== */
/* ================ [重构] 挂件中心功能与设置逻辑 ================= */
/* =============================================================== */
document.addEventListener('DOMContentLoaded', () => {
    // ---- 辅助函数：压缩图片 ----
    function compressAndSetPendantImage(file, inputElement, statusElement) {
        if (!file.type.startsWith('image/')) {
            statusElement.textContent = '请选择图片文件';
            return;
        }
        statusElement.textContent = '处理中...';
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                // 挂件图片尺寸不需要很大，128px足够清晰
                const MAX_DIMENSION = 128;
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > MAX_DIMENSION) {
                        height = Math.round(height * (MAX_DIMENSION / width));
                        width = MAX_DIMENSION;
                    }
                } else {
                    if (height > MAX_DIMENSION) {
                        width = Math.round(width * (MAX_DIMENSION / height));
                        height = MAX_DIMENSION;
                    }
                }
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                // 压缩为PNG格式，质量0.8
                const compressedDataUrl = canvas.toDataURL('image/png', 0.8);
                inputElement.value = compressedDataUrl;
                statusElement.textContent = '处理成功!';
                setTimeout(() => { statusElement.textContent = ''; }, 2000);
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }
    
    // 1. 获取所有需要的DOM元素
    const pendantShape = document.getElementById('pendant-shape');
    const pendantContainer = document.getElementById('pendant-container');
    const settingsModal = document.getElementById('pendant-settings-modal');
    
    if (!pendantShape || !pendantContainer || !settingsModal) {
        console.warn("摇摆挂件所需的核心元素未找到，功能将不被初始化。");
        return;
    }
    
    // 挂件设置相关元素
    const lineLengthSlider = document.getElementById('line-length-slider');
    const lineLengthValue = document.getElementById('line-length-value');
    const lineColorPicker = document.getElementById('line-color-picker');
    const shapeInput = document.getElementById('pendant-shape-input');
    const applyBtn = document.getElementById('apply-pendant-settings');
    const resetBtn = document.getElementById('reset-pendant-settings');
    const pendantUploadBtn = document.getElementById('upload-pendant-image-btn');
    const pendantImagePicker = document.getElementById('pendant-local-image-picker');
    const pendantUploadStatus = document.getElementById('pendant-upload-status');

    // 签到设置相关元素
    const checkinHeaderColorPicker = document.getElementById('checkinHeaderColorPicker');
    const checkinCardColorPicker = document.getElementById('checkinCardColorPicker');
    const checkinHeaderColorHex = document.getElementById('checkinHeaderColorHex');
    const checkinCardColorHex = document.getElementById('checkinCardColorHex');

    // 胶囊导航和页面相关
    const capsuleContainer = document.getElementById('widget-hub-capsule');
    const modalTitle = document.getElementById('pendant-modal-title').querySelector('span');

    const PENDANT_CONFIG_KEY = 'jellyfish_pendant_config';

    // 2. 默认设置
    const defaultSettings = {
        lineLength: '5rem',
        lineColor: '#000000',
        shapeContent: 'https://tc.z.wiki/autoupload/fr/0x9Zm_rdfaeRRjK8iV0xPw5cKjQnMC1OZdesfpjt90qyl5f0KlZfm6UsKj-HyTuv/20251105/Nh10/1024X440/IMG_7008.png?imageMogr2/thumbnail/100x'
    };

    // 3. 应用设置到DOM的函数
    function applyPendantSettings(settings) {
        pendantContainer.style.setProperty('--line-length', settings.lineLength);
        pendantContainer.style.setProperty('--line-color', settings.lineColor);
        const content = settings.shapeContent || ''; // Add a fallback for empty content
        const isUrl = content.startsWith('http') || content.startsWith('/') || content.startsWith('data:image');
        if (isUrl) {
            pendantShape.innerHTML = `<img src="${content}" alt="挂件" id="pendant-img">`;
        } else {
            pendantShape.innerHTML = `<span class="emoji">${content}</span>`;
        }
    }
    
    // ---- [新增] 应用签到日历颜色的函数 ----
    function applyCheckinColors() {
        const settings = currentConfig.settings.checkinSettings || { headerColor: '#8B4513', cardColor: '#ffffff' };
        const headerColor = settings.headerColor || '#8B4513';
        const cardColor = settings.cardColor || '#ffffff';
        document.querySelectorAll('.calendar-header').forEach(el => el.style.backgroundColor = headerColor);
        document.querySelectorAll('.calendar-date-current, .calendar-date-next, .monthly-calendar').forEach(el => el.style.backgroundColor = cardColor);
        if (checkinHeaderColorPicker) checkinHeaderColorPicker.value = headerColor;
        if (checkinCardColorPicker) checkinCardColorPicker.value = cardColor;
        if (checkinHeaderColorHex) checkinHeaderColorHex.value = headerColor;
        if (checkinCardColorHex) checkinCardColorHex.value = cardColor;
    }

    // 4. 加载设置的函数
    async function loadSettings() {
        // [修改] 加载挂件设置 - 从DataManager异步获取
        const pendantSettings = await DataManager.get('pendantData');
        applyPendantSettings({ ...defaultSettings, ...pendantSettings });

        // 更新UI
        lineLengthSlider.value = parseFloat(pendantSettings.lineLength);
        lineLengthValue.textContent = `${pendantSettings.lineLength}`;
        lineColorPicker.value = pendantSettings.lineColor;
        shapeInput.value = pendantSettings.shapeContent;
        
        // 加载签到颜色设置 (从全局配置) - 此处不变
        applyCheckinColors();
    }


    // 5. 页面切换函数
    function switchHubPage(targetId, title) {
        capsuleContainer.querySelectorAll('.capsule-btn').forEach(btn => btn.classList.remove('active'));
        settingsModal.querySelectorAll('.widget-hub-page').forEach(page => page.classList.remove('active'));
        const targetButton = capsuleContainer.querySelector(`[data-target="${targetId}"]`);
        const targetPage = document.getElementById(targetId);
        if(targetButton) targetButton.classList.add('active');
        if(targetPage) targetPage.classList.add('active');
        if(modalTitle) modalTitle.textContent = title || '挂件中心';
    }


    // 6. 事件监听器
    pendantShape.addEventListener('click', (e) => {
        // 如果是长按触发的，则不执行点击事件
        if(pendantShape.dataset.isLongPress === 'true') {
            e.stopPropagation();
            return;
        }
        e.stopPropagation();
        settingsModal.classList.add('show');
        loadSettings(); // 每次打开时重新加载并应用当前设置
        // [修改] 默认显示“签到”页面
        switchHubPage('widget-page-checkin', '签到');
        // [新增] 确保在打开弹窗时初始化一次日历
        if (typeof CheckInManager !== 'undefined' && CheckInManager.init) {
            CheckInManager.init();
        }
    });

    capsuleContainer.addEventListener('click', (e) => {
        const button = e.target.closest('.capsule-btn');
        if (button) {
            switchHubPage(button.dataset.target, button.dataset.title);
            if (button.dataset.target === 'widget-page-usage') renderUsageLeaderboard();
             // [修复] 确保在切换到签到页面时初始化日历，避免UI元素未找到的错误
            if (button.dataset.target === 'widget-page-checkin') CheckInManager.init();
        }
    });

    // --- 挂件设置监听 ---
    lineLengthSlider.addEventListener('input', () => { lineLengthValue.textContent = `${lineLengthSlider.value}rem`; });
    pendantUploadBtn.addEventListener('click', () => { pendantImagePicker.click(); });
    pendantImagePicker.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) compressAndSetPendantImage(file, shapeInput, pendantUploadStatus);
    });

    applyBtn.addEventListener('click', async () => {
        const newSettings = {
            lineLength: `${lineLengthSlider.value}rem`,
            lineColor: lineColorPicker.value,
            shapeContent: shapeInput.value.trim() || '☁️' // 默认值也改为云朵
        };
        
        // [修改] 从DataManager获取当前数据对象并更新
        const pendantData = await DataManager.get('pendantData');
        Object.assign(pendantData, newSettings);
        
        // [修改] 通过DataManager保存到云端
        await DataManager.save('pendantData', 'Update pendant settings');
        
        applyPendantSettings(newSettings);
        settingsModal.classList.remove('show');
        if (typeof showTopToast === 'function') showTopToast("挂件设置已保存！", 2000);
    });

    resetBtn.addEventListener('click', async () => {
        if (confirm("确定要恢复挂件的默认设置吗？")) {
            // [修改] 获取、应用并保存默认设置
            const pendantData = await DataManager.get('pendantData');
            Object.assign(pendantData, defaultSettings);
            await DataManager.save('pendantData', 'Reset pendant settings');
            
            loadSettings();
            applyPendantSettings(defaultSettings); // 立即应用以获得反馈
            settingsModal.classList.remove('show');
        }
    });

    
    // --- 签到颜色设置监听 ---
    const setupColorSync = (picker, hexInput, key) => {
        picker.addEventListener('input', () => {
            const color = picker.value;
            if (!currentConfig.settings.checkinSettings) currentConfig.settings.checkinSettings = {};
            currentConfig.settings.checkinSettings[key] = color;
            hexInput.value = color;
            applyCheckinColors();
            saveGlobalConfig('Update check-in color settings');
        });
        hexInput.addEventListener('change', () => {
            let value = hexInput.value.trim();
            if(!value.startsWith('#')) value = '#' + value;
            if (/^#([0-9a-f]{3}){1,2}$/i.test(value)) {
                picker.value = value;
                picker.dispatchEvent(new Event('input'));
            } else { hexInput.value = picker.value; }
        });
    };
    setupColorSync(checkinHeaderColorPicker, checkinHeaderColorHex, 'headerColor');
    setupColorSync(checkinCardColorPicker, checkinCardColorHex, 'cardColor');

});


/* =============================================================== */
/* ============= [新增] 签到功能管理器 V3.0 (数据持久化修复) ========= */
/* =============================================================== */
const CheckInManager = (() => {
    let ui = {};
    let displayedDate = new Date(); // 用于跟踪当前显示的月份
    let isInitialized = false; // 防止重复初始化

    function getFormattedDate(dateObj) {
        const year = dateObj.getFullYear();
        const month = String(dateObj.getMonth() + 1).padStart(2, '0');
        const day = String(dateObj.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    };

    // 更新撕页日历 (正面)
    async function updateTearOffCalendar() {
        const checkInData = await DataManager.get('checkInData');
        const totalDays = checkInData.dates.length;
        
        ui.header.textContent = `成为水母宝宝已经`;

        // 更新当前日期卡片
        const now = new Date();
        ui.currentNumEl.textContent = totalDays;
        ui.currentFullEl.textContent = `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()}`;
        
        // 更新下一张卡片 (明日)
        const tomorrow = new Date();
        tomorrow.setDate(now.getDate() + 1);
        ui.nextNumEl.textContent = totalDays + 1;
        ui.nextFullEl.textContent = `${tomorrow.getFullYear()}-${tomorrow.getMonth() + 1}-${tomorrow.getDate()}`;
    };

    // 处理签到逻辑
    async function handleCheckIn() {
        const checkInData = await DataManager.get('checkInData');
        const todayStr = getFormattedDate(new Date());
        
        if (checkInData.dates.includes(todayStr)) {
            showTopToast("今天已经签过到啦！", 2000);
            // 如果已经签到，也需要更新挂件状态，以防万一
            if (typeof PendantManager !== 'undefined' && PendantManager.updateCheckInStatus) {
                PendantManager.updateCheckInStatus(true);
            }
            return false; // 返回false表示未进行新的签到
        } else {
            checkInData.dates.push(todayStr);
            await DataManager.save('checkInData', 'Perform daily check-in');
            
            showTopToast("今日签到成功！", 2000);
            
            // 通知挂件管理器更新签到状态
            if (typeof PendantManager !== 'undefined' && PendantManager.updateCheckInStatus) {
                PendantManager.updateCheckInStatus(true);
            }
            // 核心修复：签到成功后直接返回，避免后续函数重复显示提示
            // UI的更新将由调用此函数的 resetCard() 统一处理
            return true; // 返回true表示签到成功
        }
    }

    // 渲染月度日历 (背面)
    async function renderMonthlyCalendar(year, month) {
        const checkInData = await DataManager.get('checkInData');
        const checkInDates = new Set(checkInData.dates);
        const todayStr = getFormattedDate(new Date());

        ui.monthYearEl.textContent = `${year} 年 ${month + 1} 月`;
        
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const daysInMonth = lastDay.getDate();
        const startDayOfWeek = firstDay.getDay();

        const tableBody = ui.table.querySelector('tbody') || document.createElement('tbody');
        tableBody.innerHTML = '';
        ui.table.appendChild(tableBody);

        let date = 1;
        for (let i = 0; i < 6; i++) {
            const row = document.createElement('tr');
            for (let j = 0; j < 7; j++) {
                const cell = document.createElement('td');
                if (i === 0 && j < startDayOfWeek) {
                    cell.classList.add('other-month');
                } else if (date > daysInMonth) {
                    cell.classList.add('other-month');
                } else {
                    const cellDate = new Date(year, month, date);
                    const cellDateStr = getFormattedDate(cellDate);
                    cell.textContent = date;
                    if (cellDateStr === todayStr) cell.classList.add('today');
                    if (checkInDates.has(cellDateStr)) cell.classList.add('checked-in');
                    date++;
                }
                row.appendChild(cell);
            }
            tableBody.appendChild(row);
            if (date > daysInMonth) break;
        }
    }

        async function init() {
            // [核心修复] 每次调用init时，都重新获取所有UI元素的引用
            ui = {
                flipper: document.querySelector('.calendar-flipper'),
                header: document.getElementById('checkin-header'),
                slidableCard: document.getElementById('slidableCard'),
                currentNumEl: document.getElementById('currentDateNum'),
                currentFullEl: document.getElementById('currentDateFull'),
                nextNumEl: document.getElementById('nextDateNum'),
                nextFullEl: document.getElementById('nextDateFull'),
                prevMonthBtn: document.getElementById('prev-month-btn'),
                nextMonthBtn: document.getElementById('next-month-btn'),
                monthYearEl: document.getElementById('current-month-year'),
                table: document.getElementById('monthly-calendar-table')
            };
            
            // 如果关键元素找不到（说明日历还没显示），则中止
            if (!ui.flipper || !ui.slidableCard || !ui.table) {
                console.warn("签到日历UI元素不完整，CheckInManager 初始化中止。");
                return;
            }

            // [核心修复] 只有在首次初始化时才绑定事件，避免重复绑定
            if (!isInitialized) {
                // 1. 翻转事件 (使用事件委托到父容器，更稳健)
                ui.flipper.addEventListener('click', (e) => {
                    // ★★★ 最终修复：精确判断点击目标 ★★★
                    if (e.target.closest('.calendar-header') || e.target.closest('#current-month-year')) {
                        ui.flipper.classList.toggle('flipped');
                    }
                });

                // 2. 月份切换事件
                ui.prevMonthBtn.addEventListener('click', () => {
                    displayedDate.setMonth(displayedDate.getMonth() - 1);
                    renderMonthlyCalendar(displayedDate.getFullYear(), displayedDate.getMonth());
                });
                ui.nextMonthBtn.addEventListener('click', () => {
                    displayedDate.setMonth(displayedDate.getMonth() + 1);
                    renderMonthlyCalendar(displayedDate.getFullYear(), displayedDate.getMonth());
                });

                // 3. 拖拽签到逻辑
                let startX = 0, startY = 0, isDragging = false, hasMoved = false;
                const dragThreshold = 10;
                
                const resetCard = async (shouldCheckIn) => {
                    if (shouldCheckIn) {
                        await handleCheckIn();
                    }
                    setTimeout(async () => {
                        if (!ui.slidableCard) return; // 增加安全检查
                        ui.slidableCard.style.transition = 'none';
                        ui.slidableCard.style.transform = 'translate(0, 0) rotate(0deg)';
                        ui.slidableCard.style.opacity = '1';
                        await updateTearOffCalendar();
                        setTimeout(() => {
                           if (ui.slidableCard) ui.slidableCard.style.transition = 'all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1.2)';
                        }, 50);
                    }, 500);
                };

                const onDragStart = (e) => {
                    if (e.target.closest('.calendar-header')) return;
                    isDragging = true; hasMoved = false;
                    if (!ui.slidableCard) return;
                    ui.slidableCard.style.transition = 'none';
                    const touch = e.touches ? e.touches[0] : e;
                    startX = touch.clientX; startY = touch.clientY;

                    document.addEventListener('mousemove', onDragMove);
                    document.addEventListener('mouseup', onDragEnd, { once: true });
                    document.addEventListener('touchmove', onDragMove, { passive: false });
                    document.addEventListener('touchend', onDragEnd, { once: true });
                };

                const onDragMove = (e) => {
                    if (!isDragging || !ui.slidableCard) return;
                    const touch = e.touches ? e.touches[0] : e;
                    const deltaX = touch.clientX - startX;
                    const deltaY = touch.clientY - startY;
                    if (!hasMoved && (Math.abs(deltaX) > dragThreshold || Math.abs(deltaY) > dragThreshold)) hasMoved = true;
                    if (hasMoved) { e.preventDefault(); ui.slidableCard.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${deltaX / 15}deg)`; }
                };

                const onDragEnd = (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    document.removeEventListener('mousemove', onDragMove); document.removeEventListener('mouseup', onDragEnd);
                    document.removeEventListener('touchmove', onDragMove); document.removeEventListener('touchend', onDragEnd);
                     if (hasMoved && ui.slidableCard) {
                        const touch = e.changedTouches ? e.changedTouches[0] : e;
                        const deltaX = touch.clientX - startX;
                        const deltaY = touch.clientY - startY;
                        ui.slidableCard.style.transition = 'all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1.2)';
                        ui.slidableCard.style.transform = `translate(${deltaX * 3}px, ${deltaY * 3}px) rotate(${deltaX > 0 ? 30 : -30}deg)`;
                        ui.slidableCard.style.opacity = '0';
                        resetCard(true);
                    } else if (ui.slidableCard) {
                        ui.slidableCard.style.transform = 'translate(0, 0) rotate(0deg)';
                    }
                };
                
                // 将拖拽事件绑定到父容器，而不是可变的卡片本身
                const calendarFront = document.querySelector('.calendar-front');
                if (calendarFront) {
                    calendarFront.addEventListener('mousedown', onDragStart);
                    calendarFront.addEventListener('touchstart', onDragStart, { passive: true });
                }

                // 创建表头
                const thead = ui.table.querySelector('thead') || document.createElement('thead');
                if (!thead.innerHTML) {
                    thead.innerHTML = `<tr>${['日', '一', '二', '三', '四', '五', '六'].map(d => `<th>${d}</th>`).join('')}</tr>`;
                    ui.table.appendChild(thead);
                }

                isInitialized = true; // 设置标志，确保事件只绑定一次
            }
            
            // 每次调用都刷新数据和UI
            await updateTearOffCalendar();
            await renderMonthlyCalendar(displayedDate.getFullYear(), displayedDate.getMonth());
        }

    return { init };
})();

/* =============================================================== */
/* ============= [重构/新增] 摇摆挂件总控管理器 V3.0 (最终修正版) ==== */
/* =============================================================== */
const PendantManager = (() => {
    let ui = {};
    const VISIBILITY_STORAGE_KEY = 'jellyfish_pendant_visibility';
    let longPressTimer = null;
    let isLongPressTriggered = false;
    let reminderCheckInterval = null;
    const LONG_PRESS_DURATION = 700;

    const defaultPendantSettings = {
        enabled: false,
        lineLength: '5rem',
        lineColor: '#000000',
        shapeContent: '☁️'
    };

    function updateButtonText() {
        if (ui.visibilityBtn) {
            const isHidden = ui.container.classList.contains('pendant-hidden');
            ui.visibilityBtn.textContent = isHidden ? '显示挂件' : '隐藏挂件';
        }
    }

    // [需求新增] 新的、独立的留言板提醒检查函数
    async function updateMessageBoardReminder() {
        try {
            const messageData = await DataManager.get('messageBoardData');
            if (!messageData || !messageData.messages) return false;

            const hasUncompleted = messageData.messages.some(msg => !msg.isCompleted);
            return hasUncompleted;
        } catch (error) {
            console.error("更新留言板提醒状态失败:", error);
            return false;
        }
    }

    async function updateCheckinReminder() {
        try {
            const checkInData = await DataManager.get('checkInData');
            const reminderEnabled = checkInData?.reminder?.enabled === true;
            const todayStr = new Date().toISOString().split('T')[0];
            const hasCheckedInToday = checkInData?.dates?.includes(todayStr) || false;
            return reminderEnabled && !hasCheckedInToday;
        } catch (error) {
            console.error("更新签到提醒状态失败:", error);
            return false;
        }
    }

    async function updateReminderAnimation() {
        const shouldAnimateForCheckin = await updateCheckinReminder();
        const shouldAnimateForBoard = await updateMessageBoardReminder();
        
        const shouldAnimate = shouldAnimateForCheckin || shouldAnimateForBoard;

        if (ui.allWrap) {
            ui.allWrap.classList.toggle('remind-active', shouldAnimate);
        }
    }

    async function updateCheckInStatus(hasCheckedIn) {
        // 这个函数现在只负责签到部分，但最终的动画状态由 updateReminderAnimation 决定
         await updateReminderAnimation();
    }

    function handleMasterToggle(enabled) {
        ui.visibilityControls.style.display = enabled ? 'block' : 'none';
        if (enabled) {
            const isHidden = localStorage.getItem(VISIBILITY_STORAGE_KEY) === 'true';
            ui.container.classList.toggle('pendant-hidden', isHidden);
            CheckInManager.init();
            updateReminderAnimation();
            if (!reminderCheckInterval) {
                 reminderCheckInterval = setInterval(updateReminderAnimation, 60 * 1000); // 每分钟检查一次
            }
        } else {
            ui.container.classList.add('pendant-hidden');
            if (ui.allWrap) ui.allWrap.classList.remove('remind-active');
            if (reminderCheckInterval) {
                clearInterval(reminderCheckInterval);
                reminderCheckInterval = null;
            }
        }
        updateButtonText();
    }

    function applyPendantSettings(settings) {
        ui.container.style.setProperty('--line-length', settings.lineLength);
        ui.container.style.setProperty('--line-color', settings.lineColor);
        const content = settings.shapeContent || defaultPendantSettings.shapeContent;
        const isUrl = content.startsWith('http') || content.startsWith('/') || content.startsWith('data:image');
        ui.shape.innerHTML = isUrl ? `<img src="${content}" alt="挂件" id="pendant-img">` : `<span class="emoji">${content}</span>`;
    }

    function loadAndDisplaySettings() {
        const settings = { ...defaultPendantSettings, ...(currentConfig.settings.pendant || {}) };
        applyPendantSettings(settings);
        if (ui.lineLengthSlider) {
           ui.lineLengthSlider.value = parseFloat(settings.lineLength);
           ui.lineLengthValue.textContent = `${settings.lineLength}`;
           ui.lineColorPicker.value = settings.lineColor;
           ui.shapeInput.value = settings.shapeContent;
        }
    }

    const handlePressStart = (e) => {
        e.preventDefault(); isLongPressTriggered = false;
        longPressTimer = setTimeout(() => {
            isLongPressTriggered = true; if (navigator.vibrate) navigator.vibrate(50);
            ui.container.classList.add('pendant-hidden');
            localStorage.setItem(VISIBILITY_STORAGE_KEY, true);
            updateButtonText(); showTopToast("挂件已隐藏，可在主题设置中重新显示", 2500);
        }, LONG_PRESS_DURATION);
    };
    
    const handlePressEnd = (e) => {
        clearTimeout(longPressTimer);
        if (!isLongPressTriggered && ui.settingsModal) {
            e.stopPropagation();
            ui.settingsModal.classList.add('show');
            loadAndDisplaySettings();
            
            DataManager.get('checkInData').then(data => {
                if (ui.reminderToggle) {
                    ui.reminderToggle.checked = data?.reminder?.enabled === true;
                }
            });
            const checkinTab = document.querySelector('#widget-hub-capsule [data-target="widget-page-checkin"]');
            if (checkinTab) checkinTab.click();
        }
    };
    
    const cancelPress = () => clearTimeout(longPressTimer);

    function init() {
        ui = {
            masterToggle: document.getElementById('pendantMasterToggle'),
            visibilityControls: document.getElementById('pendantVisibilityControls'),
            visibilityBtn: document.getElementById('togglePendantVisibilityBtn'),
            container: document.getElementById('pendant-container'),
            allWrap: document.getElementById('pendant-all-wrap'),
            shape: document.getElementById('pendant-shape'),
            settingsModal: document.getElementById('pendant-settings-modal'),
            lineLengthSlider: document.getElementById('line-length-slider'),
            lineLengthValue: document.getElementById('line-length-value'),
            lineColorPicker: document.getElementById('line-color-picker'),
            shapeInput: document.getElementById('pendant-shape-input'),
            applyBtn: document.getElementById('apply-pendant-settings'),
            resetBtn: document.getElementById('reset-pendant-settings'),
            reminderToggle: null
        };
       
        if (!ui.masterToggle || !ui.container) {
            console.error('PendantManager 初始化失败: 找不到HTML元素。');
            return;
        }

        if (!currentConfig.settings.pendant) {
            currentConfig.settings.pendant = { ...defaultPendantSettings };
        }
        
        loadAndDisplaySettings();
        ui.masterToggle.checked = currentConfig.settings.pendant.enabled;
        handleMasterToggle(ui.masterToggle.checked);
        
        if (ui.masterToggle.checked) {
            updateReminderAnimation();
        }

        ui.masterToggle.addEventListener('change', (e) => {
            currentConfig.settings.pendant.enabled = e.target.checked;
            handleMasterToggle(e.target.checked);
            saveGlobalConfig('Toggle Pendant Feature');
        });
        ui.visibilityBtn.addEventListener('click', () => {
            const isCurrentlyHidden = ui.container.classList.toggle('pendant-hidden');
            localStorage.setItem(VISIBILITY_STORAGE_KEY, isCurrentlyHidden);
            updateButtonText();
        });
        
        ui.shape.addEventListener('mousedown', handlePressStart); ui.shape.addEventListener('mouseup', handlePressEnd);
        ui.shape.addEventListener('mouseleave', cancelPress); ui.shape.addEventListener('touchstart', handlePressStart, { passive: false });
        ui.shape.addEventListener('touchend', handlePressEnd);

        ui.applyBtn?.addEventListener('click', () => {
            currentConfig.settings.pendant.lineLength = `${ui.lineLengthSlider.value}rem`;
            currentConfig.settings.pendant.lineColor = ui.lineColorPicker.value;
            currentConfig.settings.pendant.shapeContent = ui.shapeInput.value.trim() || '☁️';
            saveGlobalConfig('Update pendant settings');
            loadAndDisplaySettings();
            ui.settingsModal.classList.remove('show');
            showTopToast("挂件设置已保存！", 2000);
        });

        ui.resetBtn?.addEventListener('click', () => {
            if (confirm("确定要恢复挂件的默认设置吗？")) {
                currentConfig.settings.pendant = { ...defaultPendantSettings, enabled: currentConfig.settings.pendant.enabled };
                saveGlobalConfig('Reset pendant settings');
                loadAndDisplaySettings();
                ui.settingsModal.classList.remove('show');
            }
        });
        
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === 'childList') {
                    const reminderToggle = document.getElementById('checkin-reminder-toggle');
                    if (reminderToggle && !ui.reminderToggle) {
                        ui.reminderToggle = reminderToggle;
                        ui.reminderToggle.addEventListener('change', async (e) => {
                            const checkInData = await DataManager.get('checkInData');
                            if (!checkInData.reminder) checkInData.reminder = {};
                            checkInData.reminder.enabled = e.target.checked;
                            await DataManager.save('checkInData', 'Toggle check-in reminder');
                            await updateReminderAnimation();
                        });
                        observer.disconnect();
                        break;
                    }
                }
            }
        });
        observer.observe(document.body, { childList: true, subtree: true });
    }

    return { init, applyPendantSettings, updateCheckInStatus, updateReminderAnimation };
})();

/* =============================================================== */
/* ========================= [重构/新增结束] ======================== */
/* =============================================================== */


// [修改] 移除此处的 CheckInManager 初始化，统一由 PendantManager 根据开关状态控制
// document.addEventListener('DOMContentLoaded', () => { CheckInManager.init(); });

    </script>
    <!-- ★★★ 新增：社区须知弹窗 ★★★ -->
    <div class="modal-overlay" id="communityNoticeModal">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header">
                <div class="modal-title-group">社区须知</div>
                <button class="close-btn" data-modal-id="communityNoticeModal">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-top: 0;">为维护一个友好、互相尊重的交流环境，请遵守以下规范：</p>
                <!-- 使用你已经润色好的文字 -->
                <ul style="padding-left: 20px; line-height: 1.8;">
                    <li><b>尊重原创</b>：禁止分享作者不允许公开的网址链接和文件。</li>
                    <li><b>友好交流</b>：禁止拉踩对比。</li>
                    <li><b>文明发言</b>：禁止辱骂、阴阳、交换私下联系方式。</li>
                </ul>
                <p>有以上行为可截图私信群内管理员进行删除和拉黑。</p>
                <p><b>小提示</b>：想要删除评论，添加图片、链接等可以点击账号旁边的时间，进入github界面进行操作。</p>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center; padding: 15px 20px 20px; flex-shrink: 0;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 14px; color: #889;">
                    <input type="checkbox" id="dontRemindCheckbox"> 不再提醒
                </label>
                <button id="confirmNoticeBtn" class="modal-button" style="width: auto; padding: 10px 20px;">我已阅读并同意</button>
            </div>
        </div>
    </div>
    <!-- [新增] 数据恢复确认模态框 V2 -->
    <div class="modal-overlay" id="dataRecoveryModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title-group">
                    <span>🛡️ 选择要恢复的版本</span>
                </div>
            </div>
            <div class="modal-body">
                <p>检测到云端数据为空！我们在您的历史记录中找到了以下几个最近的有效版本：</p>
                
                <div id="recovery-versions-list">
                    <!-- JS 动态填充版本列表 -->
                </div>
                
                <p style="margin-top: 15px;"><strong>请选择一个版本进行恢复。</strong></p>
                <div class="important-note" style="font-size: 13px; padding: 8px 12px; margin-top: 5px;">
                    <p>此操作将恢复您的主配置和“记忆”功能的数据，并覆盖云端的空数据。操作不可撤销。</p>
                </div>
            </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button id="cancelRecoveryBtn" class="modal-button">取消</button>
                <button id="confirmRecoveryBtn" class="modal-button primary" disabled>恢复选中版本</button>
            </div>
        </div>
    </div>
    <!-- [新增] 记忆数据损坏恢复模态框 -->
    <div class="modal-overlay" id="memoryDataRecoveryModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title-group">
                    <span>🛡️ 记忆数据恢复</span>
                </div>
            </div>
            <div class="modal-body">
                <p style="color: #e53e3e; font-weight: bold;">检测到您的“记忆”云端数据文件为空或已损坏！</p>
                <p>为防止数据丢失，请从以下最近的几个历史版本中选择一个进行恢复。</p>
                
                <div id="memory-recovery-versions-list">
                    <!-- JS 将在此处填充历史版本 -->
                </div>
                
                <p style="margin-top: 15px;"><strong>选择一个版本后，点击下方的恢复按钮。</strong></p>
            </div>
            <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button id="cancelMemoryRecoveryBtn" class="modal-button">取消</button>
                <button id="confirmMemoryRecoveryBtn" class="modal-button primary" disabled>恢复选中版本</button>
            </div>
        </div>
    </div>
        <!-- [新增] 首次使用引导模态框 -->
    <div class="modal-overlay" id="firstTimeGuideModal">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header">
                <div class="modal-title-group">欢迎使用 Jellyfish Island</div>
            </div>
            <div class="modal-body" id="welcome-modal-content">
                <p>为了同步和备份您的所有个性化数据，您需要先完成一个简单的云端配置。</p>
                <p>配置步骤：</p>
                <ul>
                    <li>✔ 创建一个安全的GitHub“钥匙”</li>
                    <li>✔ 创建一个私密的云端“仓库”</li>
                    <li>✔ 在本应用中填入信息</li>
                </ul>
                <p>我们将引导您完成每一步。</p>
                <button id="startConfigGuideBtn" class="modal-button" style="margin-top: 15px;">开始配置</button>
            </div>
        </div>
    </div>

    <!-- [CORE-ADD] 自定义备份提醒设置弹窗 V2 -->
    <div class="modal-overlay" id="backupReminderSettingsModal">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>备份提醒设置</span></div>
                <button class="close-btn" data-modal-id="backupReminderSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- [MODIFIED] 提醒文字移到顶部并作为标题 -->
                <div class="form-section">
                    <h4 style="margin-bottom: 8px; text-align: left; font-size: 1em; color: #5a6778;">自定义提醒弹窗文字</h4>
                    <textarea id="backupMessageTextarea" class="modal-textarea" rows="2" placeholder="例如：该备份啦！"></textarea>
                </div>

                <!-- [MODIFIED] 自定义提醒时间部分重构 -->
                <div class="toggle-section" style="margin-top:20px; flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
                        <span>启用定时提醒</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="backupTimeBasedToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="backupTimeContainer" style="width: 100%; display: none; flex-direction: column; gap: 10px; margin-top: 10px;">
                        <!-- JS动态增加时间输入行 -->
                        <div id="backupTimeListContainer"></div>
                    </div>
                </div>

                <!-- [UNCHANGED] 关闭项目时提醒部分 -->
                <div class="toggle-section" style="margin-top: 15px;">
                    <span>退出项目时弹出提醒</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="backupOnExitToggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <!-- [UNCHANGED] 选择需要提醒的项目 (条件显示) -->
                <div id="backupProjectsSection" class="form-section" style="display: none; border-top: 1px solid rgba(128,128,128,0.1); padding-top: 15px; margin-top: 15px;">
                    <label>选择需要提醒的项目 (不选则全部提醒)</label>
                    <div id="backupProjectList" style="max-height: 150px; overflow-y: auto; display:flex; flex-direction:column; gap:8px; padding: 10px; border-radius: 10px; background:var(--bg-day-element); box-shadow: inset 2px 2px 4px var(--shadow-dark-day), inset -2px -2px 4px var(--shadow-light-day);">
                        <!-- JS动态填充项目列表 -->
                    </div>
                </div>
                
                <button id="saveBackupSettingsBtn" class="modal-button" style="margin-top: 20px;">保存设置</button>
            </div>
        </div>
    </div>
    <!-- [CORE-ADD END] -->
    <!-- [新增] 百度网盘设置模态框 -->
    <div class="modal-overlay" id="baiduNetdiskSettingsModal">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>百度网盘账户管理</span></div>
                <button class="close-btn" data-modal-id="baiduNetdiskSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-section">
                    <label>已关联账户</label>
                    <ul id="baidu-account-list">
                        <!-- JS 动态填充 -->
                        <p style="text-align: center; color: #889; padding: 20px 0;">暂未关联任何账户</p>
                    </ul>
                </div>

                <div class="important-note" style="font-size: 13px; padding: 10px 15px;">
                  <p>点击下方按钮将通过百度官方页面授权，您的账户信息将得到安全保护。</p>
                  <p>本应用将在您的网盘根目录下的 “/apps/JellyfishDrive/” 文件夹内读写文件。</p>
                </div>
                
                <button id="add-baidu-account-btn" class="modal-button">关联新的百度网盘账户</button>

                <div id="baidu-auth-status"></div>
            </div>
        </div>
    </div>
    <!-- [新增结束] -->
    <!-- ============= [ 新增：备忘录导入模态框 ] ============= -->
    <div class="modal-overlay" id="importMemoModal">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>导入备忘录</span></div>
                <button class="close-btn" data-modal-id="importMemoModal">&times;</button>
            </div>
            <div class="modal-body" style="gap: 15px;">
                <div class="important-note" style="margin-top: 0;">
                    <p style="margin: 0; line-height: 1.6;">支持导入 <strong>.txt, .doc, .docx, .xml</strong> 格式的文件。将提取纯文本，并以文件名作为标题批量创建备忘录。</p>
                </div>
                
                <div class="file-select-wrapper" style="flex-direction: column; gap: 15px;">
                    <input type="file" id="memoFilePicker" multiple accept=".txt,.doc,.docx,.xml" style="display: none;">
                    <button id="memoFilePickerBtn" class="modal-button" style="width: 100%;">选择文件</button>
                    <span id="memoFilePickerStatus" class="status-text" style="text-align: center; min-height: 20px;">未选择任何文件</span>
                </div>
                
                <div id="memoImportProgressContainer" style="display: none; text-align: center; color: #889;">
                    <div class="music-loader" style="margin-bottom: 8px;"></div>
                    <span id="memoImportStatus"></span>
                </div>

                <button id="startMemoImportBtn" class="modal-button" disabled>开始导入</button>
            </div>
        </div>
    </div>
    <!-- ============= [ 新增结束 ] ============= -->

    <!-- [新增] 选择性数据清理模态框 -->
    <div class="modal-overlay" id="selectiveClearModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <div class="modal-title-group"><span>请选择您要清理的数据</span></div>
                <button class="close-btn" data-modal-id="selectiveClearModal">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: #e53e3e; font-weight: bold;">⚠️ 警告：此操作不可逆，请谨慎选择！</p>
                <!-- [V2 修正] 调整样式并为JS交互做准备 -->
                <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid rgba(128,128,128,0.2); margin: 15px 0; cursor: pointer;">
                    <input type="checkbox" id="selectAllClearOptions" style="width: 16px; height: 16px; flex-shrink: 0;">
                    <strong style="user-select: none; font-size: 14px; font-weight: 600;">一键全选</strong>
                </label>
                <div id="clear-options-container" style="display: flex; flex-direction: column; gap: 15px;">
                    <!-- 选项列表保持不变，但移除了margin-top -->
                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.03); cursor: pointer;"><input type="checkbox" data-clear-target="config" style="width: 18px; height: 18px; flex-shrink: 0;"><div><strong>主配置和按钮</strong><br><span style="font-size: 12px; color: #889;">(config.json)</span></div></label>
                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.03); cursor: pointer;"><input type="checkbox" data-clear-target="memory" style="width: 18px; height: 18px; flex-shrink: 0;"><div><strong>记忆数据 (备忘录/相册结构)</strong><br><span style="font-size: 12px; color: #889;">(memory/data.json)</span></div></label>
                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.03); cursor: pointer;"><input type="checkbox" data-clear-target="photos" style="width: 18px; height: 18px; flex-shrink: 0;"><div><strong>相册照片文件</strong><br><span style="font-size: 12px; color: #889;">(/memory/photos/ 文件夹)</span></div></label>
                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.03); cursor: pointer;"><input type="checkbox" data-clear-target="music" style="width: 18px; height: 18px; flex-shrink: 0;"><div><strong>漫游音乐及歌词</strong><br><span style="font-size: 12px; color: #889;">(/memory/music/ 等)</span></div></label>
                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.03); cursor: pointer;"><input type="checkbox" data-clear-target="projects" style="width: 18px; height: 18px; flex-shrink: 0;"><div><strong>上传的项目文件</strong><br><span style="font-size: 12px; color: #889;">(/projects/ 文件夹)</span></div></label>
                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.03); cursor: pointer;"><input type="checkbox" data-clear-target="drive" style="width: 18px; height: 18px; flex-shrink: 0;"><div><strong>文件夹(云盘)文件</strong><br><span style="font-size: 12px; color: #889;">(/jellyfish_drive/ 文件夹)</span></div></label>
                    <label style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.03); cursor: pointer;"><input type="checkbox" data-clear-target="local" style="width: 18px; height: 18px; flex-shrink: 0;"><div><strong>浏览器本地缓存</strong><br><span style="font-size: 12px; color: #889;">(主题、背景、GitHub配置等)</span></div></label>
                </div>
                <button id="confirmSelectiveClearBtn" class="modal-button" style="margin-top: 20px; background: #e53e3e; color: white;">清除选中项</button>
            </div>
        </div>
    </div>
<!-- ===== [重构] 全新挂件设置悬浮窗 V2.0 ===== -->
<div class="modal-overlay" id="pendant-settings-modal">
    <div class="modal-content">
        <div class="modal-header">
            <!-- 标题会由JS动态改变 -->
            <div class="modal-title-group" id="pendant-modal-title"><span>挂件中心</span></div>
            <button class="close-btn" data-modal-id="pendant-settings-modal">&times;</button>
        </div>
        
        <div class="modal-body">
            <!-- 页面1: 签到 (V2.0 - 翻转日历) -->
            <div class="widget-hub-page active" id="widget-page-checkin" style="align-items: center; justify-content: center;">
                <div class="calendar-flipper">
                    <!-- 正面：撕页日历 -->
                    <div class="calendar-front">
                        <div class="calendar">
                            <div class="calendar-header" id="checkin-header">成为水母宝宝已经 </div>
                            <div class="calendar-date-next">
                                <div class="date-number" id="nextDateNum"></div>
                                <div class="date-full" id="nextDateFull"></div>
                            </div>
                            <div class="calendar-date-current" id="slidableCard">
                                <div class="date-number" id="currentDateNum"></div>
                                <div class="date-full" id="currentDateFull"></div>
                            </div>
                        </div>
                    </div>
                    <!-- 背面：月度日历 -->
                    <div class="calendar-back">
                        <div class="monthly-calendar">
                             <div class="monthly-calendar-header">
                                <button id="prev-month-btn">&lt;</button>
                                <span id="current-month-year"></span>
                                <button id="next-month-btn">&gt;</button>
                            </div>
                            <table id="monthly-calendar-table">
                                <!-- JS 动态填充日历 -->
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 页面2: 使用时长 -->
            <div class="widget-hub-page" id="widget-page-usage">
                <!-- [新增] 排行榜列表容器 -->
                <ol id="usage-leaderboard-list"></ol>
                <!-- [新增] 数据为空时的占位符 -->
              <p id="usage-leaderboard-placeholder" class="placeholder-content" style="display: none;">暂无使用记录</p>
            </div>

             <!-- 页面3: 留言板 -->
            <div class="widget-hub-page" id="widget-page-board">
                <!-- JS动态填充留言板卡片 -->
                <div id="message-board-container">
                    <!-- 示例: 添加按钮 -->
                    <!-- <div class="message-card message-card--add" data-action="add-message-card">
                        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                    </div> -->
                </div>
            </div>
            <!-- 页面4: 页面设置 (重构后) -->
            <div class="widget-hub-page" id="widget-page-settings">

                <!-- 折叠框1: 挂件设置 -->
                <details>
                    <summary>挂件设置</summary>
                    <div class="details-content" style="display: flex; flex-direction: column; gap: 20px;">
                        <!-- 调节线长 -->
                        <div class="pendant-settings-group">
                            <label for="line-length-slider">绳子长度</label>
                            <div class="slider-container">
                                <input type="range" id="line-length-slider" min="0" max="15" value="5" step="0.5">
                                <span id="line-length-value" class="slider-value">5 rem</span>
                            </div>
                        </div>
                        <!-- 调节颜色 -->
                        <div class="pendant-settings-group">
                            <label for="line-color-picker">绳子颜色</label>
                            <input type="color" id="line-color-picker" class="modal-input" value="#000000" style="padding: 5px; height: 40px;">
                        </div>
                        <!-- 更换形状/图片 -->
                        <div class="pendant-settings-group">
                            <label for="pendant-shape-input">挂件内容 (Emoji / 链接 / 本地图片)</label>
                            <input type="text" id="pendant-shape-input" class="modal-input" placeholder="输入Emoji、链接或上传图片">
                            
                            <!-- 新增: 本地图片上传 -->
                            <div class="file-select-wrapper" style="margin-top: 10px;">
                                <input type="file" id="pendant-local-image-picker" accept="image/*" style="display: none;">
                                <button id="upload-pendant-image-btn" class="modal-button" style="padding: 10px 15px; font-size: 14px; flex-grow: 1;">上传本地图片</button>
                                <span id="pendant-upload-status" class="status-text"></span>
                            </div>
                        </div>
                        <!-- 应用按钮 -->
                        <div style="display: flex; gap: 10px;">
                            <button id="reset-pendant-settings" class="modal-button" style="color: #889; flex-grow: 1;">恢复默认</button>
                            <button id="apply-pendant-settings" class="modal-button primary" style="color: var(--hold-border); flex-grow: 2;">应用更改</button>
                        </div>
                    </div>
                </details>

                <!-- 折叠框2: 签到设置 -->
                <details>
                    <summary>签到设置</summary>
                    <div class="details-content" style="display: flex; flex-direction: column; gap: 20px;">
                        <!-- [新增] 签到提醒开关 -->
                        <div class="toggle-section" style="margin-top: 5px;">
                            <span>开启签到提醒</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="checkin-reminder-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                        
                        <div class="color-picker-group">
                            <label>日历顶部颜色</label>
                            <div class="color-input-wrapper">
                                <input type="color" id="checkinHeaderColorPicker">
                                <input type="text" class="modal-input hex-display" id="checkinHeaderColorHex" maxlength="7">
                            </div>
                        </div>
                        <div class="color-picker-group">
                            <label>日历卡片颜色</label>
                            <div class="color-input-wrapper">
                                <input type="color" id="checkinCardColorPicker">
                                <input type="text" class="modal-input hex-display" id="checkinCardColorHex" maxlength="7">
                            </div>
                        </div>

                    </div>
                </details>
                <!-- 折叠框3: 使用时长设置 (已重构) -->
                <details>
                    <summary>使用时长设置</summary>
                    <div class="details-content" style="display: flex; flex-direction: column; gap: 15px;">
                        <!-- 新增: 总开关 -->
                        <div class="toggle-section">
                            <span>启用分类筛选</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="usage-time-filter-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>

                        <!-- 筛选列表容器 (JS控制显隐) -->
                        <div id="usage-time-filter-container" style="display: none;">
                            <span style="font-size: 14px; font-weight: 600; color: #5a6778; display: block; margin-bottom: 12px; margin-top: 5px;">纳入排行榜的分类</span>
                            <div id="usage-time-category-filter" style="display: flex; flex-direction: column; gap: 10px; max-height: 150px; overflow-y: auto; padding-right: 5px;">
                                <!-- JS将填充此区域 -->
                            </div>
                        </div>
                    </div>
                </details>
            </div>


        <!-- 全新的胶囊导航栏 -->
        <div id="widget-hub-capsule">
            <button class="capsule-btn active" data-target="widget-page-checkin" data-title="签到">
                <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24"><rect x="6" y="0" width="2" height="5" fill="#1c1f21"></rect><rect x="16" y="0" width="2" height="5" fill="#1c1f21"></rect><path d="m20,3H4c-1.654,0-3,1.346-3,3v12c0,1.654,1.346,3,3,3h16c1.654,0,3-1.346,3-3V6c0-1.654-1.346-3-3-3Zm0,16H4c-.551,0-1-.448-1-1v-9h18v9c0,.552-.449,1-1,1Z" fill="#1c1f21"></path></svg>
                <span>签到</span>
            </button>
            <button class="capsule-btn" data-target="widget-page-usage" data-title="使用时长">
                <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24"><rect x="1" y="20" width="22" height="2" fill="#1c1f21"></rect><rect x="1" y="7" width="6" height="11" fill="#1c1f21"></rect><rect x="9" y="2" width="6" height="16" fill="#1c1f21"></rect><rect x="17" y="11" width="6" height="7" fill="#1c1f21"></rect></svg>
                <span>时长</span>
            </button>
            <button class="capsule-btn" data-target="widget-page-board" data-title="留言板">
                <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 48 48"> <path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C8.68629 2 6 4.68629 6 8V40C6 43.3137 8.68629 46 12 46H36C39.3137 46 42 43.3137 42 40V8C42 4.68629 39.3137 2 36 2H12ZM12 8H36V22H12V8ZM36 25H12V28H36V25ZM12 31H36V34H12V31ZM26 37H12V40H26V37Z" fill="#1c1f21"></path> </svg>
                <span>留言板</span>
            </button>
            <button class="capsule-btn" data-target="widget-page-settings" data-title="页面设置">
                <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24"><path d="m23,13.75v-3.5l-2.384-.841c-.176-.583-.407-1.142-.691-1.668l1.091-2.281-2.475-2.475-2.281,1.091c-.527-.284-1.086-.515-1.668-.691l-.841-2.384h-3.5l-.841,2.384c-.583-.176-1.142-.407-1.668-.691l-2.281-1.091-2.475,2.475,1.091,2.281c-.284-.527-.515,1.086-.691,1.668l-2.384.841v3.5l2.384.841c.176.583.407,1.142.691,1.668l-1.091,2.281,2.475,2.475,2.281-1.091c.527.284,1.086.515,1.668-.691l.841,2.384h3.5l.841-2.384c.583-.176,1.142-.407,1.668-.691l2.281,1.091,2.475-2.475-1.091-2.281c.284-.527-.515,1.086.691-1.668l2.384-.841Zm-11,2.25c-2.206,0-4-1.794-4-4s1.794-4,4-4,4,1.794,4,4-1.794,4-4,4Z" fill="#1c1f21"></path></svg>
                <span>设置</span>
            </button>
        </div>
    </div>
</div>
<!-- ===== [重构结束] ===== -->
<!-- ============= [ 新增：备忘录导入模态框 ] ============= -->
<div class="modal-overlay" id="importMemoModal">
    <div class="modal-content" style="max-width: 420px;">
        <div class="modal-header">
            <div class="modal-title-group"><span>导入备忘录</span></div>
            <button class="close-btn" data-modal-id="importMemoModal">&times;</button>
        </div>
        <div class="modal-body" style="gap: 15px;">
            <div class="important-note" style="margin-top: 0;">
                <p style="margin: 0; line-height: 1.6;">支持导入 <strong>.txt, .doc, .docx, .xml</strong> 格式的文件。将提取纯文本，并以文件名作为标题批量创建备忘录。</p>
            </div>
            
            <div class="file-select-wrapper" style="flex-direction: column; gap: 15px;">
                <input type="file" id="memoFilePicker" multiple accept=".txt,.doc,.docx,.xml" style="display: none;">
                <button id="memoFilePickerBtn" class="modal-button" style="width: 100%;">选择文件</button>
                <span id="memoFilePickerStatus" class="status-text" style="text-align: center; min-height: 20px;">未选择任何文件</span>
            </div>
            
            <div id="memoImportProgressContainer" style="display: none; text-align: center; color: #889;">
                <div class="music-loader" style="margin-bottom: 8px;"></div>
                <span id="memoImportStatus"></span>
            </div>

            <button id="startMemoImportBtn" class="modal-button" disabled>开始导入</button>
        </div>
    </div>
</div>
<!-- ============= [ 新增：留言板功能弹窗 ] ============= -->
    <div class="modal-overlay" id="messageBoardModal">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <div class="modal-title-group"><span id="messageModalTitle">添加新留言</span></div>
                <button class="close-btn" data-modal-id="messageBoardModal">&times;</button>
            </div>
            <div class="modal-body" style="gap: 18px;">
                <div class="form-section">
                    <label for="messageTitleInput">标题</label>
                    <input type="text" id="messageTitleInput" class="modal-input" placeholder="必填，如：项目汇报">
                </div>
                <div class="form-section">
                    <label for="messageLinkProjectSelect">链接项目 (可选)</label>
                    <select id="messageLinkProjectSelect" class="modal-select">
                        <option value="">不链接任何项目</option>
                        <!-- JS动态填充项目 -->
                    </select>
                </div>
                <!-- [需求新增] 卡片背景图片上传功能 -->
                <div class="form-section">
                    <label>卡片背景 (可选)</label>
                    <div class="file-select-wrapper">
                        <input type="file" id="messageBgImagePicker" accept="image/*" style="display: none;">
                        <button id="uploadMessageBgBtn" class="modal-button" style="padding: 10px 15px; font-size: 14px; flex-grow: 1;">上传图片</button>
                        <button id="clearMessageBgBtn" class="modal-button delete" style="padding: 10px 15px; font-size: 14px;">清除</button>
                    </div>
                </div>
                <div class="toggle-section" style="flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px;">
                    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
                        <span>设置提醒</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="messageReminderToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="messageReminderDetails" style="width: 100%; display: none; flex-direction: column; gap: 15px; margin-top: 10px;">
                        <!-- 新增：全天开关 -->
                        <div class="toggle-section">
                            <span>全天提醒</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="messageAllDayToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <!-- 修改：时间选择器 -->
                        <input type="datetime-local" id="messageReminderTime" class="modal-input">
                        <!-- 提醒类型保持不变 -->
                        <div class="segmented-control three-segments">
                            <input type="radio" id="reminder-type-once" name="reminder-type" value="once" checked hidden>
                            <label for="reminder-type-once">仅一次</label>
                            <input type="radio" id="reminder-type-daily" name="reminder-type" value="daily" hidden>
                            <label for="reminder-type-daily">每日</label>
                            <input type="radio" id="reminder-type-periodic" name="reminder-type" value="periodic" hidden disabled>
                            <label for="reminder-type-periodic" style="opacity:0.5; cursor: not-allowed;">定期</label>
                            <div class="slider-indicator"></div>
                        </div>
                        <!-- "提醒后消失" 的 <label> 已被移除 -->
                    </div>
                </div>
                <!-- [需求修改] 将保存和删除按钮放在一个容器中，方便布局 -->
                <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                    <button id="deleteMessageBtn" class="modal-button delete" style="display: none; margin-right: auto;">删除</button>
                    <button id="saveMessageBtn" class="modal-button primary">保存留言</button>
                </div>
            </div>
        </div>
    </div>
    <!-- ============= [ 新增结束 ] ============= -->
<!-- ============= [ 新增结束 ] ============= -->
<!-- 将这个 script 标签放在 </body> 之前 -->
<script src="https://unpkg.com/mammoth@1.7.0/mammoth.browser.min.js"></script>
</body>
</html>
